{
  "id": "e0bb03d6-7aff-4c99-88c5-f08454b80b7e",
  "isFolder": true,
  "name": "DSA",
  "content": [
    {
      "id": "e1babfcc-bc44-46b1-bd2d-2784e41313be",
      "isFolder": true,
      "name": "Concepts",
      "content": [
        {
          "id": "aa65f17c-72fb-484a-9079-f9a659cf7844",
          "isFolder": false,
          "name": "DoublyLinkedList.java",
          "code": "public class DoublyLinkedList {\n    private Node head;\n    private Node tail;\n    private int length = 0;\n\n    class Node {\n        int value;\n        Node next;\n        Node prev;\n\n        Node(int val) {\n            this.value = val;\n        }\n    }\n\n    DoublyLinkedList() {\n        head = tail = null;\n    }\n\n    DoublyLinkedList(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n\n    public static void printList(DoublyLinkedList list) {\n        Node temp = list.head;\n        if (list.length == 0) {\n            System.out.println(\"<List empty>\");\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.length; i++) {\n            sb.append(temp.value);\n            if (temp.next != null) {\n                sb.append(\" <--> \");\n            }\n            temp = temp.next;\n        }\n        System.out.println(sb.toString());\n    }\n\n    public void append(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            tail.next = temp;\n            temp.prev = tail;\n            tail = temp;\n        }\n        length++;\n    }\n\n    public Node removeLast() {\n        if (length == 0) return null;\n        Node temp = tail;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            tail = tail.prev;\n            tail.next = temp.prev = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public void prepend(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            temp.next = head;\n            head.prev = temp;\n            head = temp;\n        }\n        length++;\n    }\n\n    public Node removeFirst() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            head.prev = null;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public Node get(int index) {\n        if (index < 0 || index >= length) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean insert(int index, int val) {\n        if (index < 0 || index > length) return false;\n        if (index == 0) {\n            prepend(val);\n        } else if (index == length) {\n            append(val);\n        } else {\n            Node before = get(index - 1);\n            Node after = before.next;\n            Node temp = new Node(val);\n            before.next = temp;\n            temp.next = after;\n            after.prev = temp;\n            temp.prev = before;\n        }\n        length++;\n        return true;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) {\n            length--;\n            return removeFirst();\n        }\n        if (index == length - 1) {\n            length--;\n            return removeLast();\n        }\n        Node temp = get(index);\n        if (temp != null) {\n            Node before = temp.prev;\n            Node after = temp.next;\n            before.next = after;\n            after.prev = before;\n            length--;\n            return temp;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        DoublyLinkedList list = new DoublyLinkedList(1);\n        list.append(2);\n        list.append(3);\n        list.append(9);\n        list.append(12);\n        System.out.println(list.remove(1));\n//        list.insert(4, 91);\n//        System.out.println(list.set(2, 99));\n//        System.out.println(list.get(2).value);\n//        System.out.println(list.removeFirst().value);\n        DoublyLinkedList.printList(list);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["DataStructures"]
        },
        {
          "id": "f25283e4-df99-4eec-ba4b-32b10224405f",
          "isFolder": false,
          "name": "Queue.java",
          "code": "public class Queue {\n    class Node {\n        int value;\n        Node next;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    Node head;\n    Node tail;\n    int length;\n    Queue(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n    Queue() {\n        head = tail = null;\n        length = 0;\n    }\n    Node enqueue(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n        return newNode;\n    }\n\n    Node dequeue() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        return temp;\n    }\n\n    public static void main(String[] args) {\n        Queue q = new Queue(10);\n        q.enqueue(4);\n        q.enqueue(19);\n        System.out.println(q.dequeue().value);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["DataStructures"]
        },
        {
          "id": "ca43ed29-a43c-4b4e-8029-905546d21d2f",
          "isFolder": false,
          "name": "SinglyLinkedList.java",
          "code": "public class SinglyLinkedList {\n    static class Node {\n        int value;\n        Node next;\n        Node (int val) {\n            this.value = val;\n        }\n    }\n    int length;\n    private Node head;\n    private Node tail;\n    SinglyLinkedList(int value) {\n        Node newNode = new Node(value);\n        head = tail = newNode;\n        length = 1;\n    }\n    SinglyLinkedList() {\n        head = tail = null;\n        length = 0;\n    }\n\n//    Methods\n    public void prepend(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            newNode.next = head;\n            head = newNode;\n        }\n        length++;\n    }\n    public void append(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n    }\n    public Node removeLast() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            Node pre = head;\n            while (temp.next != null) {\n                pre = temp;\n                temp = temp.next;\n            }\n            tail = pre;\n            tail.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node removeFirst() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node get(int index) {\n        if (index >= length || index < 0) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public void insert(int index, int val) {\n        if (index < 0 || index > length) return;\n        else if (index == 0) {\n            prepend(val);\n            return;\n        } else if (index == length) {\n            append(val);\n            return;\n        }\n        Node temp = head;\n        for (int i = 0; i < index - 1; i++) {\n            temp = temp.next;\n        }\n        Node newNode = new Node(val);\n        newNode.next = temp.next;\n        temp.next = newNode;\n        length++;\n        return;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) return removeFirst();\n        if (index == length - 1) return removeLast();\n        Node prev = get(index - 1);\n        Node temp = prev.next;\n        prev.next = temp.next;\n        temp.next = null;\n        length--;\n        return temp;\n    }\n\n    public void reverse() {\n        Node temp = head;\n        head = tail;\n        tail = temp;\n        Node prev = null;\n        Node next = null;\n        for (int i = 0; i < length; i++) {\n            next = temp.next;\n            temp.next = prev;\n            prev = temp;\n            temp = next;\n        }\n    }\n\n    public int getLength() {\n        return length;\n    }\n    public String getString() {\n        Node temp = head;\n        StringBuilder sb = new StringBuilder();\n        while (temp != null) {\n            sb.append(temp.value).append(\" \");\n            temp = temp.next;\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.append(1);\n        list.append(3);\n        list.append(5);\n        list.append(6);\n        System.out.println(list.getString());\n        list.reverse();\n        System.out.println(list.getString());\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["DataStructures"]
        },
        {
          "id": "8d79f93c-461e-4fed-ac38-cc6aa259f0dc",
          "isFolder": false,
          "name": "Stack.java",
          "code": "// Using Singly linked list\n\npublic class Stack {\n    class Node {\n        Node next;\n        int value;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    private Node top;\n    private int height;\n    Stack(int val) {\n        top = new Node(val);\n        height = 1;\n    }\n//    Peek\n    public Node peek() {\n        return top;\n    }\n//    Push\n    public void push(int val) {\n        Node newNode = new Node(val);\n        if (height == 0) {\n            top = newNode;\n        } else {\n            newNode.next = top;\n            top = newNode;\n        }\n        height++;\n    }\n//    Pop\n    public Node pop() {\n        if (isEmpty()) {\n            return null;\n        }\n        Node temp = top;\n        top = top.next;\n        temp.next = null;\n        height--;\n        return temp;\n    }\n//    isEmpty\n    public boolean isEmpty() {\n        return height == 0;\n    }\n\n    public static void main(String[] args) {\n        Stack myStack = new Stack(10);\n        myStack.push(19);\n        myStack.push(13);\n        myStack.push(41);\n        myStack.push(25);\n//        System.out.println(myStack.pop().value);\n//        System.out.println(myStack.peek().value);\n        System.out.println(myStack.isEmpty());\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["DataStructures"]
        },
        {
          "id": "85349c5a-9ad5-4374-95c4-2431f852a036",
          "isFolder": false,
          "name": "BinarySearch.java",
          "code": "// BS on 1D Arrays\npublic class BinarySearch {\n    //    Iterative Binary Search\n    public static int binarySearch(int[] A, int target) {\n        int start = 0;\n        int end = A.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (A[mid] == target) return mid;\n            if (A[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return -1;\n    }\n\n    //    Recursive Binary search\n    public static int binarySearch(int[] A, int target, int start, int end) {\n        if (start > end) return -1;\n        int mid = start + (end - start) / 2;\n        if (A[mid] == target) return mid;\n        if (A[mid] > target)\n            return binarySearch(A, target, start, mid - 1);\n        else\n            return binarySearch(A, target, mid + 1, end);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-1, 0, 3, 5, 9, 12};\n//        int ans = binarySearch(arr, 9);\n        int ans = binarySearch(arr, 9, 0, arr.length - 1);\n        System.out.println(ans);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["Search"]
        },
        {
          "id": "9b7f6928-9c74-433a-9e59-c8b046bed919",
          "isFolder": false,
          "name": "SearchAlgo.java",
          "code": "public class SearchAlgo {\n    static int linearSearch(int arr[], int target) {\n        for (int i = 0; i <= arr.length; i++) {\n            if (target == arr[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    static int binarySearch(int arr[], int target) {\n        int start = 0;\n        int end = arr.length - 1;\n        int mid = ((end - start)/2) + start;\n        while (start <= end) {\n            if (target < arr[mid]) {\n                end = mid - 1;\n            } else if (target > arr[mid]) {\n               start = mid + 1;\n            } else {\n                return mid;\n            }\n            mid = ((end - start) / 2) + start;\n        }\n        return -1;\n    }\n\n    static int orderAgnosticBS(int arr[], int target) {\n        boolean isAscending = arr[0] > arr[arr.length - 1];\n        int start = 0;\n        int end = arr.length - 1;\n        int mid = ((end - start) / 2) + start;\n        while (start <= end) {\n            if (target == arr[mid]) {\n                return mid;\n            }\n            else {\n                if (isAscending) {\n                    if (target > arr[mid]) {\n                        end = mid - 1;\n                    } else {\n                        start = mid + 1;\n                    }\n                } else {\n                    if (target < arr[mid]) {\n                        end = mid - 1;\n                    } else {\n                        start = mid + 1;\n                    }\n                }\n            }\n            mid = ((end - start) / 2) + start;\n        }\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        // int[] arr = { 1, 5, 8, 7, 42, 30, 23, 51, 42, 56, 41, 10, 36, 99 }; // Some randon non-sorted array\n        // int[] sortedArr = { -11, -5, -1, 16, 17, 22, 27, 37, 40, 42, 55, 70, 72, 80, 82, 83 }; // Some randon sorted array\n        // int[] sortedArr = { 2, 3, 5, 9, 14, 16, 18 }; // Some randon sorted array\n        int[] sortedArr = { 52, 45, 42, 39, 31, 23, 20, 15, 13, 5, 1 }; // Some randon sorted array\n        // int result = linearSearch(arr, 51);\n        // int result = binarySearch(sortedArr, 15);\n        int result = orderAgnosticBS(sortedArr, 115);\n        System.out.println(\"Element found at index: \" + result);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["Search"]
        },
        {
          "id": "192961eb-3b69-47f7-9f13-cbe2eea2dd5b",
          "isFolder": false,
          "name": "BubbleSort.java",
          "code": "import java.util.Arrays;\n\npublic class BubbleSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n      boolean swapped = false;\n      for (int j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          swap(arr, j, j + 1);\n          swapped = true;\n        }\n      }\n      if (!swapped) {\n        break;\n      }\n    }\n  }\n  \n  public static void bubbleSortRecursive(int[] arr, int n) {\n    if (n == 1) return;\n    boolean swapped = false;\n    for (int j = 0; j < n - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        swapped = true;\n      }\n    }\n    if (!swapped) return;\n    bubbleSortRecursive(arr, n - 1);\n  }\n\n  public static void main(String[] args) {\n    int[] arr = { 9, 5, 1, 23, 7, 43, -11, -124, 1, 64, 37, 3 };\n    bubbleSortRecursive(arr, arr.length);\n    System.out.println(\"Sorted array: \" + Arrays.toString(arr));\n  }\n}",
          "link": null,
          "notes": "",
          "tags": ["Sorting"]
        },
        {
          "id": "1ae0a440-83c2-43a5-b839-927c5ff8336e",
          "isFolder": false,
          "name": "CyclicSort.java",
          "code": "import java.util.Arrays;\n\npublic class CyclicSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void cyclicSort(int[] arr) {\n    int i = 0;\n    while (i < arr.length) {\n      if (arr[i] != arr[arr[i] - 1])\n        swap(arr, i, arr[i] - 1);\n      else\n        i++;\n    }\n  }\n  public static void main(String[] args) {\n    // arr = { 2, 5, 4, 1, 3 };\n    int[] arr = { 2, 5, 4, 1, 3 };\n    cyclicSort(arr);\n    System.out.println(Arrays.toString(arr));\n  }\n}",
          "link": null,
          "notes": "",
          "tags": ["Sorting"]
        },
        {
          "id": "593591cc-d22a-4873-8b6d-014d7f8252c8",
          "isFolder": false,
          "name": "InsertionSort.java",
          "code": "import java.util.Arrays;\n\npublic class InsertionSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n  public static void insertionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 1; i < n - 1; i++) {\n      for (int j = i; j > 0; j--) {\n        if (arr[j] >= arr[j - 1])\n          break;\n        swap(arr, j, j-1);\n      }\n    }\n  }\n\n  public static void insertionSortRecursive(int[] arr, int i) {\n    if (i == arr.length-1) return;\n    for (int j = i; j > 0; j--) {\n      if (arr[j] >= arr[j - 1])\n        break;\n      swap(arr, j, j-1);\n    }\n    insertionSortRecursive(arr, i+1);\n  }\n\n  public static void main(String[] args) {\n    // int[] arr = { 4, 1, 6, 8, 3, 2, 4, 7, 9, 1, 0 };\n    int[] arr = { 1, -2, -3, 4, 8, -9, 7, 8, 9 };\n    insertionSort(arr);\n    // insertionSortRecursive(arr, 1);\n    System.out.println(Arrays.toString(arr));\n  }\n}",
          "link": null,
          "notes": "",
          "tags": ["Sorting"]
        },
        {
          "id": "fe87a01b-dec8-432c-8032-2dd5a74b53b0",
          "isFolder": false,
          "name": "MergeSort.java",
          "code": "import java.util.Arrays;\n\npublic class MergeSort {\n  public static void mergeArray(int[] arr, int low, int mid, int high) {\n    int[] temp = new int[high - low + 1];\n    int left = low, right = mid + 1, i = 0;\n    while (left <= mid && right <= high) {\n      if (arr[left] <= arr[right])\n        temp[i++] = arr[left++];\n      else\n        temp[i++] = arr[right++];\n    }\n\n    while (left <= mid)\n      temp[i++] = arr[left++];\n\n    while (right <= high)\n      temp[i++] = arr[right++];\n\n    for (int j = 0; j < i; j++)\n      arr[j + low] = temp[j];\n  }\n\n  public static void mergeSort(int[] arr, int low, int high) {\n    if (low == high) {\n      return;\n    }\n    int mid = low + (high - low) / 2;\n    mergeSort(arr, low, mid);\n    mergeSort(arr, mid + 1, high);\n    mergeArray(arr, low, mid, high);\n  }\n\n  public static void main(String[] args) {\n    int[] arr = { 3, 4, 1, 2, 7, 8, 4, 6, 3, 1 };\n    mergeSort(arr, 0, 9);\n    System.out.println(Arrays.toString(arr));\n  }\n}",
          "link": null,
          "notes": "",
          "tags": ["Sorting"]
        },
        {
          "id": "5a91ad66-474b-466e-b97a-98083b23cfb1",
          "isFolder": false,
          "name": "QuickSort.java",
          "code": "public class QuickSort {\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int partition(int[] A, int low, int high) {\n        int pivot = A[low];\n        int i = low, j = high;\n        while (i < j) {\n            while (A[i] <= pivot && i < high) i++;\n            while (A[j] > pivot && j > low) j--;\n            if (i < j) swap(A, i, j);\n        }\n        swap(A, j, low);\n        return j;\n    }\n    public static void quickSort(int[] A, int low, int high) {\n        if (low < high) {\n            int pIdx = partition(A, low, high);\n            quickSort(A, low, pIdx-1);\n            quickSort(A, pIdx+1, high);\n        }\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["Sorting"]
        },
        {
          "id": "9fe45473-e0d2-420e-a333-32866868efca",
          "isFolder": false,
          "name": "SelectionSort.java",
          "code": "import java.util.Arrays;\n\npublic class SelectionSort {\n  public static void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++) {\n      int minIdx = i;\n      for (int j = i + 1; j < n; j++)\n        if (arr[minIdx] > arr[j])\n          minIdx = j;\n      if (i != minIdx) {\n        int temp = arr[i];\n        arr[i] = arr[minIdx];\n        arr[minIdx] = temp;\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    int[] arr = { 4, 1, 6, 8, 3, 2, 4, 7, 9, 1, 0 };\n    selectionSort(arr);\n    System.out.println(Arrays.toString(arr));\n  }\n}",
          "link": null,
          "notes": "",
          "tags": ["Sorting"]
        },
        {
          "id": "3bda5165-8319-4e1a-be60-390cb0a11b56",
          "isFolder": false,
          "name": "CycleDetectionArray.java",
          "code": "// AKA Floyd's algorithm, cycle detection in an array, find the duplicate number in an array of [1 - N]\npublic class CycleDetectionArray {\n    public static int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1,3,4,2,2};\n        int ans = findDuplicate(arr);\n        System.out.println(ans);\n    }\n}",
          "link": "https://leetcode.com/problems/find-the-duplicate-number",
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "217cf31d-0a80-46ed-af17-903e48b51a6b",
          "isFolder": false,
          "name": "CycleDetectionLinkedList.java",
          "code": "// Detect loop or cycle in a linked list\npublic class CycleDetectionLinkedList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(0);\n        ListNode temp = head;\n        temp.next = new ListNode(2);\n        temp = temp.next;\n        temp.next = new ListNode(4);\n        temp = temp.next;\n        temp.next = new ListNode(1);\n        temp = temp.next;\n        temp.next = new ListNode(0);\n//        Created a cycle\n        temp.next.next  = head.next.next;\n\n    }\n}",
          "link": "https://leetcode.com/problems/linked-list-cycle",
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "19d6728d-dd4c-4cd2-9f88-0a57b82823f3",
          "isFolder": false,
          "name": "DutchNationalFlagAlgorithm.java",
          "code": "// Dutch's national flag algorithm\n\nimport java.util.Arrays;\n\npublic class DutchNationalFlagAlgorithm {\n    public static int[] sort012(int[] arr) {\n        int low = 0, mid = 0, high = arr.length - 1;\n        while (mid <= high) {\n            if (arr[mid] == 0) {\n                int temp = arr[low];\n                arr[low] = arr[mid];\n                arr[mid] = temp;\n                low++;\n                mid++;\n            } else if (arr[mid] == 1) mid++;\n            else {\n                int temp = arr[high];\n                arr[high] = arr[mid];\n                arr[mid] = temp;\n                high--;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 0, 1, 2};\n        int[] ans = sort012(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
          "link": "https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/",
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "e602e958-a409-4303-98a4-33daa9743e2a",
          "isFolder": false,
          "name": "FastExponentiation.java",
          "code": "public class FastExponentiation {\n    public static int power(int a, int n) {\n        if (n == 0) return 1;\n        else if (n == 1) return a;\n\n        int r = power(a, n/2);\n\n        if (n%2 == 0) return r*r;\n        return r*a*r;\n    }\n\n    public static void main(String[] args) {\n        int ans = power(4,10);\n        System.out.println(ans);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "d3374fd7-8a79-476c-ae1d-0e82b39d381b",
          "isFolder": false,
          "name": "GCD.java",
          "code": "public class GCD {\n//    a = big, b = small\n    public static int getGCD(int a, int b) {\n        if (a%b == 0) return b;\n        return getGCD(b, a%b);\n    }\n\n    public static void main(String[] args) {\n        int ans = getGCD(24, 51);\n        System.out.println(ans);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "7873fd07-e1c6-47f9-9d08-5115e72dd329",
          "isFolder": false,
          "name": "KadanesAlgorithm.java",
          "code": "// Largest Sum Contiguous Subarray (Kadane's Algorithm)\npublic class KadanesAlgorithm {\n    public static int maxSum(int[] nums) {\n        int sum = 0;\n        int maxSum = 0;\n        for (int num : nums) {\n            sum += num; // Increment\n            maxSum = Math.max(maxSum, sum); // Maximise\n            if (sum < 0) sum = 0; // Check to reset\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, -3, 4, -1, -2, 1, 5, -3};\n        int ans = maxSum(arr);\n        System.out.println(ans);\n    }\n}",
          "link": "https://www.geeksforgeeks.org/largest-sum-contiguous-subarray",
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "0bb5e1af-4ec4-45c5-a881-23771ee9f439",
          "isFolder": false,
          "name": "MooresVotingAlgorithm.java",
          "code": "//  Boyer-Moore Majority Voting Algorithm: used to find the majority element among the given elements that have more than N/ 2 occurrences.\npublic class MooresVotingAlgorithm {\n    public static int findMajority(int[] N) {\n        int element = -1, count = 0;\n        for (int j : N) {\n            if (count == 0) {\n                element = j;\n                count = 1;\n            } else if (element == j) count++;\n            else count--;\n        }\n        return element;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 2, 2, 1, 1, 2, 3, 4};\n        int majority = findMajority(arr);\n        System.out.println(\" The majority element is : \" + majority);\n    }\n}",
          "link": "https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm",
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "42212d26-5cc1-4674-a41e-bb5dca673706",
          "isFolder": false,
          "name": "SieveOfEratosthenes.java",
          "code": "import java.util.*;\n\npublic class SieveOfEratosthenes {\n    public static int sieve(int n) {\n        List<Integer> ans = new ArrayList<>();\n        if (n <= 2) return 0;\n        int count = 0;\n        boolean[] M = new boolean[n];\n        for (int i = 2; i < n; i++) {\n            if (!M[i]) {\n                ans.add(i);\n                count++;\n                for (int j = 2* i; j < n; j += i) {\n                    M[j] = true;\n                }\n            }\n        }\n        System.out.println(ans);\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int ans = sieve(100);\n        System.out.println(ans);\n    }\n}",
          "link": null,
          "notes": "",
          "tags": ["Special Algorithms"]
        },
        {
          "id": "e753bfd4-1fee-4b73-b5e8-ad43d6f0d30d",
          "isFolder": false,
          "name": "SubsequencesOfAString.java",
          "code": "import java.util.*;\n\npublic class SubsequencesOfAString {\n    public static ArrayList<String> subsequences(String str) {\n        // Using power set technique\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n}",
          "link": "https://www.codingninjas.com/studio/problems/subsequences-of-string_985087",
          "notes": "",
          "tags": ["Special Algorithms"]
        }
      ]
    },
    {
      "id": "dc78e35c-c0d7-4615-8ef3-96419cd1933d",
      "isFolder": true,
      "name": "DSAPrepQuestions",
      "content": [
        {
          "id": "f5bd30b1-d793-4cde-b148-4049d721f0e3",
          "isFolder": true,
          "name": "Combined",
          "content": [
            {
              "id": "b2ee5431-5482-4473-9756-08349adcac71",
              "isFolder": false,
              "name": "AddToArrayFormOfInteger.java",
              "code": "import java.util.*;\n\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            num[i] += k;\n            k = num[i] / 10;\n            ans.add(0, num[i] % 10);\n        }\n        while (k != 0) {\n            ans.add(0, k % 10);\n            k /= 10;\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/add-to-array-form-of-integer",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "9cb58c55-be06-477b-86ea-e51790cfd08a",
              "isFolder": false,
              "name": "CellWithOddValuesInMatrix.java",
              "code": "public class CellWithOddValuesInMatrix {\n    public int oddCells(int m, int n, int[][] I) {\n        // M = rows, N = cols\n        boolean[] row = new boolean[m];\n        boolean[] col = new boolean[n];\n        int r=0, c=0;\n        for (int i = 0; i < I.length; i++) {\n            row[I[i][0]] ^= true;\n            col[I[i][1]] ^= true;\n        }\n        for (int j = 0; j < n; j++)\n            if (col[j]) c++;\n\n        for (int j = 0; j < m; j++)\n            if (row[j]) r++;\n\n        // r(n-c) + c(m-r)\n        // rn + cm - rc - rc\n        return r*n + c*m - 2*r*c;\n    }\n}",
              "link": "https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "210e3b88-a206-49cc-b4a3-db44af9ac79b",
              "isFolder": false,
              "name": "GoodArray.java",
              "code": "public class GoodArray {\n    public boolean isGoodArray(int[] N) {\n        int ans = N[0];\n        for (int i = 1; i < N.length; i++)\n            ans = GCD(N[i], ans);\n        return ans == 1;\n    }\n    public int GCD(int a, int b) {\n        if (a%b == 0) return b;\n        return GCD(b, a%b);\n    }\n}",
              "link": "https://leetcode.com/problems/check-if-it-is-a-good-array/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "9198fc57-205e-461e-8e27-29db49764cdf",
              "isFolder": false,
              "name": "JumpGame.java",
              "code": "public class JumpGame {\n    public boolean canJump(int[] nums) {\n        int n = nums.length - 1;\n        int goal = n;\n        for (int i = n; i >= 0; i--) {\n            if (i + nums[i] >= goal)\n                goal = i;\n        }\n        return goal == 0;\n    }\n}",
              "link": "https://leetcode.com/problems/jump-game/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "9d396035-5c69-4aba-8b5a-83e6b20e6779",
              "isFolder": false,
              "name": "MinCostToFlipCoinsToSamePosition.java",
              "code": "public class MinCostToFlipCoinsToSamePosition {\n    public int minCostToMoveChips(int[] position) {\n        int even = 0;\n        for (int i: position){\n            if ((i & 1) == 0){\n                even++;\n            }\n        }\n        return Math.min(even, position.length - even);\n    }\n}",
              "link": "https://leetcode.com/problems/minimum-cost-to-move-chips-to-the-same-position/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "f28e477f-2eba-40a2-88c6-824a50ca7a58",
              "isFolder": false,
              "name": "NumberOfGoodPairs.java",
              "code": "import java.util.*;\n\npublic class NumberOfGoodPairs {\n    public static int numIdenticalPairs(int[] nums) {\n        // O(n) solution\n        int numberOfGoodPairs = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i: nums) {\n            if (hm.containsKey(i)) {\n                numberOfGoodPairs += hm.get(i);\n            }\n            hm.put(i, hm.getOrDefault(i, 0) + 1);\n        }\n        return numberOfGoodPairs;\n\n        // O(n^2) solution\n        // int numberOfGoodPairs = 0;\n        // for (int i=0; i < nums.length -1; i++) {\n        //     for (int j=i+1; j < nums.length; j++) {\n        //         if (nums[i] == nums[j]) {\n        //             numberOfGoodPairs++;\n        //         }\n        //     }\n        // }\n        // return numberOfGoodPairs;\n    }\n}",
              "link": "https://leetcode.com/problems/number-of-good-pairs/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "74aa72ef-23f8-4a45-a913-5a09bad7047e",
              "isFolder": false,
              "name": "NumbersSmallerThanCurrentNumber.java",
              "code": "public class NumbersSmallerThanCurrentNumber {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] counts = new int[102];\n        for (int num : nums)\n            counts[num]++;\n        for (int j = 1; j < counts.length; j++)\n            counts[j] += counts[j - 1];\n        int[] ans = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0)\n                ans[i] = 0;\n            else\n                ans[i] = counts[nums[i] - 1];\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "1e746c2c-2fef-4da7-896a-959b267d8189",
              "isFolder": false,
              "name": "SpiralMatrix3.java",
              "code": "public class SpiralMatrix3 {\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\n        int[] directions = {0, 1, 0, -1, 0};\n        int[][] ans = new int[rows*cols][2];\n        ans[0] = new int[] {rStart, cStart};\n        int len = 0, d = 0, ptr = 1;\n        while (ptr < ans.length) {\n            if (d == 0 || d == 2) len++;\n            for (int i = 0; i < len; i++) {\n                rStart += directions[d];\n                cStart += directions[d+1];\n                if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {\n                    ans[ptr++] = new int[] {rStart, cStart};\n                }\n            }\n            d = ++d%4;\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/spiral-matrix-iii/",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "f7922840-e462-4f3a-83c4-700c4444c21e",
              "isFolder": false,
              "name": "TransposeMatrix.java",
              "code": "public class TransposeMatrix {\n    public int[][] transpose(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int[][] newMatrix = new int[cols][rows];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                newMatrix[j][i] = matrix[i][j];\n            }\n        }\n        return newMatrix;\n    }\n}",
              "link": "https://leetcode.com/problems/transpose-matrix",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "e6bc3197-31c5-4c22-9755-ce20c21a891b",
              "isFolder": false,
              "name": "WavePrint.java",
              "code": "import java.util.Arrays;\n\npublic class WavePrint {\n    public static int[] wavePrint(int arr[][], int nRows, int mCols) {\n        // Write your code here.\n        int[] ans = new int[nRows*mCols];\n        int ptr = 0;\n        for (int i = 0; i < mCols; i++) {\n            if ((i&1) == 0) {\n                // TB\n                for (int j = 0; j < nRows; j++) {\n                    ans[ptr++] = arr[j][i];\n                }\n            } else {\n                // BT\n                for (int j = nRows - 1; j >= 0; j--) {\n                    ans[ptr++] = arr[j][i];\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12}\n        };\n        int[] ans = wavePrint(mat, mat.length, mat[0].length);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              "link": "https://www.codingninjas.com/studio/problems/print-like-a-wave_893268",
              "notes": "",
              "tags": ["Arrays"]
            },
            {
              "id": "f8b33b32-3c96-41d5-a688-296504213906",
              "isFolder": false,
              "name": "ArrangingCoins.java",
              "code": "public class ArrangingCoins {\n    public static int arrangeCoins(int n) {\n//        Brute force solution\n//        if (n <= 1) return n;\n//        int i;\n//        for (i = 0; i < n; i++) {\n//            long ans = ((long) i *(i+1))/2;\n//            if (ans > n) break;\n//        }\n//        return i-1;\n\n//        Better solution\n//        long start = 0, end = n;\n//        while (start <= end) {\n//            long mid = start + (end - start)/2;\n//            long val = (mid * (mid+1))/2;\n//            if (val == n) return (int) mid;\n//            if (val > n) {\n//                end = mid - 1;\n//            } else {\n//                start = mid + 1;\n//            }\n//        }\n//        return (int) end;\n\n//        Optimised solution\n//         Equation: k(k+1)/2 = n\n//         k^2 + k = 2*n\n//         k^2 + k + 1/4 = 2*n + 1/4\n//         (k + 1/2)^2 = 2n + 1/4\n//         k = sqrt(2n + 1/4) - 1/2\n        return (int) (Math.sqrt(2L*n + 0.25) - 0.5);\n    }\n\n    public static void main(String[] args) {\n        int ans = arrangeCoins(1804289383);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/arranging-coins/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "ce8b4afd-c9a4-4cc6-b59e-b1bd9dde92bd",
              "isFolder": false,
              "name": "FindRightInterval.java",
              "code": "import java.util.*;\npublic class FindRightInterval {\n    public static int[] findRightInterval(int[][] intervals) {\n        int[][] copy = new int[intervals.length][2];\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            copy[i] = intervals[i];\n            hm.put(intervals[i][0], i);\n        }\n        Arrays.sort(copy, Comparator.comparingInt(a -> a[0]));\n        int[] ans = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            int pos = search(copy, intervals[i][1]);\n            ans[i] = pos == -1 ? pos : hm.get(copy[pos][0]);\n        }\n        return ans;\n    }\n    public static int search(int[][] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid][0] == target) return mid;\n            if (arr[mid][0] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        if (start == arr.length) return -1;\n        return start;\n    }\n}",
              "link": "https://leetcode.com/problems/find-right-interval/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "340e1045-b891-4120-b365-478cd034530e",
              "isFolder": false,
              "name": "FrequencyOfMostFrequentElement.java",
              "code": "import java.util.*;\n\npublic class FrequencyOfMostFrequentElement {\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums);\n        int l = 0, r = 0;\n        long maxLen = 1, total = 0;\n        while (r < nums.length) {\n            total += nums[r];\n            while ((long) nums[r] * (r - l + 1) > total + k) {\n                total -= nums[l++];\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n            r++;\n        }\n        return (int) maxLen;\n    }\n}",
              "link": "https://leetcode.com/problems/frequency-of-the-most-frequent-element/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "ca606534-dab4-471b-82cf-0f7752d9c9ec",
              "isFolder": false,
              "name": "MaxValueAtGivenIndexInBoundedArray.java",
              "code": "public class MaxValueAtGivenIndexInBoundedArray {\n    public long getFormulaSum(int count, long mid) {\n        long c = Math.min(count, mid-1);\n        return c*mid - c*(c+1)/2 + Math.max(count - (mid-1), 0); // Adds extra 1s if any\n    }\n    public int maxValue(int n, int index, int maxSum) {\n        long start = 1;\n        long end = maxSum;\n        long result = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long totalSum = getFormulaSum(index, mid);\n            totalSum += mid;\n            totalSum += getFormulaSum(n-index-1, mid);\n            if (totalSum <= maxSum) {\n                result = mid;\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return (int)result;\n    }\n}",
              "link": "https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "d46586f0-61cc-4a4c-ba8e-8e27cc750afe",
              "isFolder": false,
              "name": "MinAbsoluteSumDifference.java",
              "code": "import java.util.*;\npublic class MinAbsoluteSumDifference {\n    public int minAbsoluteSumDiff(int[] N, int[] M) {\n        int[] abs = new int[N.length];\n        long maxSum = 0;\n        for (int i = 0; i < N.length; i++) {\n            abs[i] = Math.abs(N[i] - M[i]);\n            maxSum += abs[i];\n        }\n        Arrays.sort(N);\n        int max = 0;\n        for (int j = 0; j < N.length; j++) {\n            int minValue = Math.abs(M[j] - bSearch(N, M[j]));\n            int diff = abs[j] - minValue;\n            max = Math.max(max, diff);\n        }\n        return (int)((maxSum - max) % 1000000007);\n    }\n    public static int bSearch(int[] N, int target){\n        int start = 0, end = N.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (N[mid] == target) return N[mid];\n            if (N[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        if (start == N.length) start--;\n        if (end == -1) end++;\n        int diff1 = Math.abs(target - N[start]);\n        int diff2 = Math.abs(target - N[end]);\n        if (diff1 > diff2) return N[end];\n        return N[start];\n    }\n}",
              "link": "https://leetcode.com/problems/minimum-absolute-sum-difference/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "a29b8ff8-5bb0-43fb-9430-3eb4896dbca8",
              "isFolder": false,
              "name": "ReachANumber.java",
              "code": "public class ReachANumber {\n    public static long formula(long n) {\n        return (n*(n+1))>>1;\n    }\n\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        long start = 1, end = target;\n        int steps = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long distance = formula(mid);\n            if (distance >= target) {\n                steps = (int) mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        long dist = formula(steps) - target;\n        if ((dist&1) != 0) {\n            return steps + ((steps&1) == 0 ? 1 : 2);\n        }\n        return steps;\n    }\n}",
              "link": "https://leetcode.com/problems/reach-a-number/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "13f793fd-0f7b-4a04-b288-c0ebf5f10f2a",
              "isFolder": false,
              "name": "SquareRootWithPrecision.java",
              "code": "public class SquareRootWithPrecision {\n    public static int sqrt(int n) {\n        int start = 0, end = n;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            int root = mid * mid;\n            if (root == n) return mid;\n            if (root > n)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int getClosestSqrt(double n, int val, int num) {\n        int start = 0, end = 9;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            double x = n + mid / (double) val;\n            double root = x * x;\n            if (root < num)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return end;\n    }\n\n    public static double getSquareRootWithPrecision(int n, int p) {\n        double num = sqrt(n);\n        int increment = 10;\n        for (int i = 0; i < p; i++) {\n            int x = getClosestSqrt(num, increment, n); // log10\n            num += (double) x / increment;\n            increment *= 10;\n        }\n        return num;\n    }\n\n    public static void main(String[] args) {\n        int n = 40;\n        int p = 3;\n        double ans = getSquareRootWithPrecision(n, p);\n        System.out.printf(\"%.{%d}f\", p, ans);\n    }\n}",
              "link": "https://www.geeksforgeeks.org/find-square-root-number-upto-given-precision-using-binary-search/",
              "notes": "",
              "tags": ["Maths"]
            },
            {
              "id": "1b2dfe90-9a07-4717-9ad6-a29073b1c979",
              "isFolder": false,
              "name": "XorOfRange.java",
              "code": "public class XorOfRange {\n    public static void main(String[] args) {\n        int n = 9;\n        int ans1 = computeXor(n);\n        int ans2 = computeXorEfficient(n);\n        System.out.println(ans1 + \"  \" + ans2);\n    }\n\n    static int computeXor(int n) {\n        if (n == 0) return 0;\n        int uni = 0;\n        for (int i = 1; i <= n; i++) {\n            uni = uni ^ i;\n        }\n        return uni;\n    }\n\n    static int computeXorEfficient(int n) {\n        int rem = n % 4;\n        switch (rem) {\n            case 0 -> {\n                return n;\n            }\n            case 1 -> {\n                return 1;\n            }\n            case 2 -> {\n                return n + 1;\n            }\n        }\n        return 0;\n    }\n}",
              "link": "https://www.geeksforgeeks.org/find-xor-of-numbers-from-the-range-l-r/",
              "notes": "",
              "tags": ["Maths"]
            },
            {
              "id": "0846a2fc-72bf-4971-b6e7-c63f03950da5",
              "isFolder": false,
              "name": "LetterCombinationsOfPhoneNumber.java",
              "code": "import java.util.*;\npublic class LetterCombinationsOfPhoneNumber {\n    public List<String> letterCombinations(String digs) {\n        List<String> ans = new ArrayList<>();\n        if (digs.length() == 0) return ans;\n        StringBuilder sb = new StringBuilder();\n        String[] mappings = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        solve(mappings, digs, ans, sb, 0);\n        return ans;\n    }\n    public static void solve(String[] mappings, String digs, List<String> ans, StringBuilder sb, int idx) {\n        // Base case\n        if (idx >= digs.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        // Get index\n        int index = digs.charAt(idx) - '0';\n        String val = mappings[index];\n        // Get all letters from mapping[index]\n        for (int i = 0; i < val.length(); i++) {\n            sb.append(val.charAt(i));\n            solve(mappings, digs, ans, sb, idx + 1);\n            sb.replace(sb.length() - 1, sb.length(), \"\");\n        }\n    }\n}",
              "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
              "notes": "",
              "tags": ["Recursion"]
            },
            {
              "id": "f05d6d70-47a2-433a-9eee-9f96f0011645",
              "isFolder": false,
              "name": "Permutations.java",
              "code": "import java.util.*;\npublic class Permutations {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int idx) {\n        // Base case\n        if (idx >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n\n        for (int i = idx; i < nums.length; i++) {\n            op.add(nums[i]);\n            swap(nums, idx, i);\n            solve(nums, ans, op, idx + 1);\n            swap(nums, idx, i);\n            op.remove(op.size() - 1);\n        }\n    }\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
              "link": "https://leetcode.com/problems/permutations/",
              "notes": "",
              "tags": ["Recursion"]
            },
            {
              "id": "04e9942d-cb0c-47e1-a3ec-6aebbae86b50",
              "isFolder": false,
              "name": "SubsequencesOfString.java",
              "code": "import java.util.*;\n// This is the same question as power set but the solution is using recursion\npublic class SubsequencesOfString {\n    public static void getSubsequences(String str, ArrayList<String> ans, StringBuilder sb, int index) {\n        if (index >= str.length()) {\n            if (sb.length() != 0) {\n                ans.add(sb.toString());\n            }\n            return;\n        }\n//        Exclude\n        getSubsequences(str, ans, sb, index+1);\n//        Include\n        sb.append(str.charAt(index));\n        getSubsequences(str, ans, sb, index+1);\n        sb.replace(sb.length() - 1, sb.length(),\"\");\n    }\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getSubsequences(str, ans, sb, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences(\"abc\");\n        System.out.println(ans);\n    }\n}",
              "link": "https://www.codingninjas.com/studio/problems/subsequences-of-string_985087",
              "notes": "",
              "tags": ["Recursion"]
            },
            {
              "id": "43213ed5-6847-4436-b305-dee7f20f7903",
              "isFolder": false,
              "name": "Subsets.java",
              "code": "import java.util.*;\n\npublic class Subsets {\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int index) {\n        if (index >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n//        Exclude\n        solve(nums, ans, op, index+1);\n//        Include\n        op.add(nums[index]);\n        solve(nums, ans, op, index+1);\n        op.remove(op.size() - 1);\n    }\n    public static List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1,2,3};\n        List<List<Integer>> ans =  subsets(nums);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/subsets/",
              "notes": "",
              "tags": ["Recursion"]
            },
            {
              "id": "23c58eed-fe75-41db-af27-6fb390c70a46",
              "isFolder": false,
              "name": "AssignCookies.java",
              "code": "import java.util.Arrays;\n\npublic class AssignCookies {\n    public static int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int gLast = g.length - 1;\n        int sLast = s.length - 1;\n        int count = 0;\n        while (gLast >= 0 && sLast >= 0) {\n            if (g[gLast] <= s[sLast]) {\n                gLast--;\n                sLast--;\n                count++;\n            } else {\n                gLast--;\n            }\n        }\n        return count;\n    }\n}",
              "link": "https://leetcode.com/problems/assign-cookies/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "1b040a38-a1a0-4c44-8117-46890301b993",
              "isFolder": false,
              "name": "CanMakeAPFFromSequence.java",
              "code": "public class CanMakeAPFFromSequence {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    public static boolean canMakeArithmeticProgression(int[] arr) {\n//        Brute force\n//         Arrays.sort(arr);\n//         int diff = arr[1] - arr[0];\n//         for (int i = 1; i < arr.length; i++) {\n//             if (arr[i] - arr[i-1] != diff) return false;\n//         }\n//         return true;\n\n//        Optimal solution\n        int min = Integer.MAX_VALUE, max =Integer.MIN_VALUE;\n        for (int num: arr){\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int n = arr.length;\n//        If difference is not perfectly divisible then return false\n        if ((max - min) % (n - 1) != 0) return false;\n//        To get the difference between any 2 element in a AP\n        int diff = (max - min) / (n - 1);\n        int i = 0;\n        while (i < n) {\n            if (arr[i] == min + i*diff) i++;\n            else if ((arr[i] - min)%diff != 0) return false;\n            else {\n                int j = (arr[i] - min)/diff;\n                if (arr[i] == arr[j]) return false;\n                swap(arr, i, j);\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13, 12, -12, 9, 9, 16, 7, -10, -20, 0, 18, -1, -20, -10, -8, 15, 15, 16, 2, 15};\n//        int[] arr = {2, 10, 7, 8, 3};\n//        int[] arr = {1,2,4};\n        System.out.println(canMakeArithmeticProgression(arr));\n    }\n}",
              "link": "https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "8069d55f-7c6f-49ec-8529-274be94734b0",
              "isFolder": false,
              "name": "InsertionSortList.java",
              "code": "public class InsertionSortList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) {\n            this.val = val;\n        }\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public static ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null)  return head;\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = head;\n        ListNode curr = head.next;\n        while (curr != null) {\n            if (curr.val >= prev.val) {\n                prev = curr;\n                curr = curr.next;\n                continue;\n            }\n            ListNode temp = dummy;\n            while (curr.val > temp.next.val) {\n                temp = temp.next;\n            }\n            prev.next = curr.next;\n            curr.next = temp.next;\n            temp.next = curr;\n            curr = prev.next;\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = insertionSortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + \" => \");\n            temp = temp.next;\n        }\n    }\n}",
              "link": "https://leetcode.com/problems/insertion-sort-list",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "20b63326-4c9a-4a1c-8b3b-8f9267028130",
              "isFolder": false,
              "name": "LargestNumber.java",
              "code": "import java.util.*;\npublic class LargestNumber {\n    public String largestNumber(int[] nums) {\n        Comparator<String> comp = (i, j) -> (j+i).compareTo(i+j);\n        List<String> list = new ArrayList<>();\n        for (int num : nums) {\n            list.add(String.valueOf(num));\n        }\n        list.sort(comp);\n        StringBuilder sb = new StringBuilder();\n        for (String l : list) {\n            sb.append(l);\n        }\n        return String.valueOf(Integer.parseInt(String.valueOf(sb)));\n    }\n\n}",
              "link": "https://leetcode.com/problems/largest-number/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "d642619d-9da0-451e-acd0-eff08c69da26",
              "isFolder": false,
              "name": "MaxProductOfTwoElementsInAnArray.java",
              "code": "public class MaxProductOfTwoElementsInAnArray {\n    public int maxProduct(int[] nums) {\n        int f = 0, s = 0;\n        for (int num : nums) {\n            if (num > f) {\n                s = f;\n                f = num;\n            } else if (num > s) {\n                s = num;\n            }\n        }\n        return (f-1)*(s-1);\n    }\n}",
              "link": "https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "b0c8e14a-14b5-49f7-a1b4-481bc6c7b44d",
              "isFolder": false,
              "name": "RankTransformOfAnArray.java",
              "code": "import java.util.*;\n\npublic class RankTransformOfAnArray {\n    public int[] arrayRankTransform(int[] arr) {\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        int[] h = arr.clone();\n        Arrays.sort(h);\n        int rank = 1;\n        for (int i = 0; i < h.length; i++) {\n            if (!hm.containsKey(h[i])) {\n                hm.put(h[i], rank++);\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            h[i] = hm.get(arr[i]);\n        }\n        return h;\n    }\n}",
              "link": "https://leetcode.com/problems/rank-transform-of-an-array/submissions/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "5fcce500-fa7b-4d2e-be4e-cec482d2c85d",
              "isFolder": false,
              "name": "RelativeSortArray.java",
              "code": "import java.util.Arrays;\n\npublic class RelativeSortArray {\n    public static int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] count = new int[1001];\n        int totalCount = arr1.length;\n        for (int i : arr1) {\n            count[i]++;\n        }\n        int j = 0;\n        for (int k : arr2) {\n            while (count[k] != 0) {\n                arr1[j++] = k;\n                count[k]--;\n                totalCount--;\n            }\n        }\n        if (totalCount != 0) {\n            for (int i = 0; i < 1001; i++) {\n                while (count[i] != 0) {\n                    arr1[j++] = i;\n                    count[i]--;\n                }\n            }\n        }\n        return arr1;\n    }\n    public static void main(String[] args) {\n//        Input:\n        int[] arr1 = {2,3,1,3,2,4,6,7,9,2,19};\n        int[] arr2 = {2,1,4,3,9,6};\n        int[] ans = relativeSortArray(arr1, arr2);\n        System.out.println(Arrays.toString(ans));\n//        Output: [2,2,2,1,4,3,3,9,6,7,19]\n    }\n}",
              "link": "https://leetcode.com/problems/relative-sort-array/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "afb39a3d-6fd4-486a-ab4c-13cb1fd38e55",
              "isFolder": false,
              "name": "SortArrayByIncreasingFrequency.java",
              "code": "import java.util.*;\npublic class SortArrayByIncreasingFrequency {\n    public static int[] frequencySort(int[] nums) {\n        // Count the frequency of each number\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        // Sort the unique numbers by frequency and then by value\n        List<Integer> numList = new ArrayList<>(hm.keySet());\n        numList.sort((a, b) -> {\n            int freqCompare = Integer.compare(hm.get(a), hm.get(b));\n            return (freqCompare != 0) ? freqCompare : Integer.compare(b, a);\n        });\n        // Populate the sorted result array -> O(n) operation\n        int index = 0;\n        for (int num : numList) {\n            int freq = hm.get(num);\n            for (int i = 0; i < freq; i++) {\n                nums[index++] = num;\n            }\n        }\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-1,1,-6,4,5,-6,1,4,1};\n        int[] ans = frequencySort(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              "link": "https://leetcode.com/problems/sort-array-by-increasing-frequency/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "f58feaa6-c3d0-43be-b14f-086a6bceaba3",
              "isFolder": false,
              "name": "SortIntegersByNumberOf1Bits.java",
              "code": "import java.util.*;\n\npublic class SortIntegersByNumberOf1Bits {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int compare(int a, int b) {\n        int aBits = Integer.bitCount(a);\n        int bBits = Integer.bitCount(b);\n        if (aBits != bBits) return aBits - bBits;\n        return a - b;\n    }\n\n    public static void mergeSort(int[] arr, int low, int high) {\n        if (low == high) return;\n        int mid = low + (high - low)/2;\n        mergeSort(arr, low, mid);\n        mergeSort(arr, mid+1, high);\n        merge(arr, low, mid, high);\n    }\n\n    public static void merge(int[] arr, int low, int mid, int high) {\n        int[] temp = new int[high - low + 1];\n        int i = 0, left = low, right = mid+1;\n        while (left <= mid && right <= high) {\n            if (compare(arr[left], arr[right]) > 0)\n                temp[i++] = arr[right++];\n            else\n                temp[i++] = arr[left++];\n        }\n        while (left <= mid) temp[i++] = arr[left++];\n        while (right <= high) temp[i++] = arr[right++];\n\n        for (int j = 0; j < temp.length; j++)\n            arr[j+low] = temp[j];\n    }\n\n    public static int[] sortByBits(int[] arr) {\n//        Brute force solution\n//        int n = arr.length - 1;\n//        for (int i = 0; i < n; i++) {\n//            boolean swapped = false;\n//            for (int j = 0; j < n - i; j++) {\n//                if (compare(arr[j], arr[j + 1]) > 0) {\n//                    swap(arr, j, j + 1);\n//                    swapped = true;\n//                }\n//            }\n//            if (!swapped) break;\n//        }\n//        return arr;\n\n//        Better solution\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] += Integer.bitCount(arr[i]) * 10001;\n//        }\n//        Arrays.sort(arr);\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] = arr[i] % 10001;\n//        }\n//        return arr;\n\n//        Optimised solution\n        mergeSort(arr, 0, arr.length - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n//        int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n//        int[] arr = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\n        int[] arr = {2, 3, 5, 7, 11, 13, 17, 19};\n        int[] ans = sortByBits(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              "link": "https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/description/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "589c86d1-b3d1-4f82-9639-86d87b5a8d03",
              "isFolder": false,
              "name": "SortList.java",
              "code": "class SortList {\n    static class ListNode {\n            int val;\n            ListNode next;\n            ListNode() {}\n            ListNode(int val) {\n                this.val = val;\n            }\n            ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode list2Head = slow.next;\n        slow.next = null;\n        head = mergeSort(head);\n        list2Head = mergeSort(list2Head);\n        return merge(head, list2Head);\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode();\n        ListNode head = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        }\n        if (right != null) {\n            temp.next = right;\n        }\n        return head.next;\n    }\n    public static ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = sortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + \" => \");\n            temp = temp.next;\n        }\n    }\n}",
              "link": "https://leetcode.com/problems/sort-list/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "3435cffb-1cf8-412a-afea-b5e313b8fe7b",
              "isFolder": false,
              "name": "SplArrayWithXElementsGTEToX.java",
              "code": "public class SplArrayWithXElementsGTEToX {\n    public int specialArray(int[] nums) {\n        int start = 1, end = nums.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i: nums) {\n                if (i >= mid) count++;\n            }\n            if (count == mid) return mid;\n            if (count > mid)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}",
              "link": "https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "68a37beb-c60b-4065-8282-7baf0a070160",
              "isFolder": false,
              "name": "SquaresOfASortedArray.java",
              "code": "public class SquaresOfASortedArray {\n    public int[] sortedSquares(int[] nums) {\n//        Brute force\n//        int[] ans = new int[nums.length];\n//        for (int i=0; i < nums.length; i++) {\n//            ans[i] = nums[i]*nums[i];\n//        }\n//        Arrays.sort(ans);\n//        return ans;\n//        Best solution\n        int n = nums.length - 1;\n        int[] ans = new int[n+1];\n        int start = 0, end = n;\n        while(start <= end) {\n            if (Math.abs(nums[start]) >= Math.abs(nums[end])) {\n                ans[n--] = nums[start]*nums[start];\n                start++;\n            } else {\n                ans[n--] = nums[end]*nums[end];\n                end--;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n\n    }\n}",
              "link": "https://leetcode.com/problems/squares-of-a-sorted-array/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "145bd350-1423-48cf-ab7f-ba721da5ea43",
              "isFolder": false,
              "name": "ThirdMaximumNumber.java",
              "code": "// Approach: Ranking technique with conditions to handle the same values as first and second;\n// Use Long instead of int as min and max value is Integer's min and max value\n\npublic class ThirdMaximumNumber {\n    public static int getThirdMaxNumber(int[] arr) {\n        long f = Long.MIN_VALUE;\n        long s = Long.MIN_VALUE;\n        long t = Long.MIN_VALUE;\n        for (int num : arr) {\n            if (num > f) {\n                t = s;\n                s = f;\n                f = num;\n            } else if (num > s && num != f) {\n                t = s;\n                s = num;\n            } else if (num > t && num != s && num != f) {\n                t = num;\n            }\n        }\n        if (t == Long.MIN_VALUE) {\n            return (int)f;\n        }\n        return (int)t;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1,2,2,5,3,5};\n        int ans = getThirdMaxNumber(arr);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/third-maximum-number/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "42b1a871-9fa0-4052-8ef4-5ca1d47e96f6",
              "isFolder": false,
              "name": "ThreeSumClosest.java",
              "code": "import java.util.*;\npublic class ThreeSumClosest {\n    public static int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int n = nums.length;\n\n        int first3Sum = nums[0]+nums[1]+nums[2];\n        int last3Sum = nums[n-1]+nums[n-2]+nums[n-3];\n        if (first3Sum >= target) return first3Sum;\n        if (last3Sum <= target) return last3Sum;\n\n        int diff = Integer.MAX_VALUE;\n        int closest = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            int j = i+1;\n            int k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) return sum;\n\n                int abs = Math.abs(target - sum);\n                if (diff > abs) {\n                    closest = sum;\n                    diff = abs;\n                }\n                if (sum > target) k--;\n                else j++;\n            }\n        }\n        return closest;\n    }\n}",
              "link": "https://leetcode.com/problems/3sum-closest/",
              "notes": "",
              "tags": ["Sorting"]
            },
            {
              "id": "7001531b-3b14-4436-8307-e71719a988a4",
              "isFolder": false,
              "name": "MaximumOccuringCharacter.java",
              "code": "public class MaximumOccuringCharacter {\n//    Use a hashmap or counts array to store the count of all the elements\n//    ans iterate over it to get the max count;\n    public static char getMaxOccuringChar(String line)\n    {\n        // Your code here\n        int[] count = new int[26];\n        for (int i = 0; i < line.length(); i++) {\n            count[(int) line.charAt(i) - 'a']++;\n        }\n        int max = count[0];\n        int idx = 0;\n        for (int j = 0; j < count.length; j++) {\n            if (count[j] > max) {\n                idx = j;\n                max = count[j];\n            }\n        }\n        return (char) (idx + 'a');\n    }\n\n    public static void main(String[] args) {\n        String s = \"testsample\";\n        char ans = getMaxOccuringChar(s);\n        System.out.println(ans);\n    }\n}",
              "link": "https://practice.geeksforgeeks.org/problems/maximum-occuring-character-1587115620/1",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "600679ea-a74b-4c57-b13c-40b65f8289c3",
              "isFolder": false,
              "name": "PermutationInString.java",
              "code": "public class PermutationInString {\n    public static boolean checkCount(int[] arr1, int[] arr2) {\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] != arr2[i]) return false;\n        }\n        return true;\n    }\n\n    public static boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n        int[] count1 = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count1[s1.charAt(i) - 97]++;\n        }\n        int[] count2 = new int[26];\n        int windowSize = s1.length();\n        int i = 0;\n        while (i < windowSize) {\n            count2[s2.charAt(i) - 97]++;\n            i++;\n        }\n        if (checkCount(count1, count2)) return true;\n        while (i < s2.length()) {\n            // Add\n            count2[s2.charAt(i) -97]++;\n            // Minus\n            count2[s2.charAt(i-windowSize) -97]--;\n\n            i++;\n            if (checkCount(count1, count2)) return true;\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        String s1 = \"ab\";\n        String s2 = \"eidboaoo\";\n        boolean ans = checkInclusion(s1, s2);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/permutation-in-string/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "ea5214bb-8bba-4048-bd17-8757ea91a68b",
              "isFolder": false,
              "name": "PowerSet.java",
              "code": "import java.util.*;\npublic class PowerSet {\n    public List<List<Integer>> powerSet(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < Math.pow(2, nums.length); i++) {\n            List<Integer> list = new ArrayList<>();\n            int idx = 0;\n            while(idx < nums.length) {\n                if (((i >> idx)&1) == 1) {\n                    list.add(nums[idx]);\n                }\n                idx++;\n            }\n            ans.add(list);\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/subsets/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "62e7a2a7-6977-43d4-af29-a0c22ae5e26a",
              "isFolder": false,
              "name": "RemoveAllAdjacentDuplicates.java",
              "code": "public class RemoveAllAdjacentDuplicates {\n    public static String removeDuplicates(String s) {\n//        Brute force solution\n//        Stack<Character> stack = new Stack<>();\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (!stack.isEmpty() && stack.peek() == ch)\n//                stack.pop();\n//            else\n//                stack.push(ch);\n//        }\n//        while (!stack.isEmpty()) sb.append(stack.pop());\n//        return sb.reverse().toString();\n\n//        Better solution using stack\n        char[] stack = new char[s.length()];\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            char ch = s.charAt(j);\n            if (i > 0 && stack[i-1] == ch)\n                i = Math.max(0, i - 1);\n            else\n                stack[i++] = ch;\n        }\n        return new String(stack, 0, i);\n\n//        Optimised solution: Two pointer approach which requires stringBuilder methods\n    }\n    public static void main(String[] args) {\n        String s = \"abbaca\";\n        String ans = removeDuplicates(s);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "c18f3c80-57e6-4b33-b4c6-896a691b5248",
              "isFolder": false,
              "name": "RemoveAllOccurrencesOfSubstring.java",
              "code": "public class RemoveAllOccurrencesOfSubstring {\n    public static String removeOccurrences(String s, String part) {\n        StringBuilder sb = new StringBuilder(s);\n        while (sb.length()!=0 && sb.indexOf(part)>=0) {\n            int idx = sb.indexOf(part);\n            sb.delete(idx, idx+part.length());\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n        String s = \"daabcbaabcbc\";\n        String part = \"abc\";\n        String ans = removeOccurrences(s, part);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/remove-all-occurrences-of-a-substring/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "cf05a85a-cf76-4b93-8f19-20c1269e564a",
              "isFolder": false,
              "name": "ReplaceSpaces.java",
              "code": "public class ReplaceSpaces {\n    public static StringBuilder replaceSpaces(StringBuilder str) {\n        // Write your code here.\n        // return new StringBuilder(str.toString().replace(\" \", \"@40\"));\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == ' ')\n                sb.append(\"@40\");\n            else\n                sb.append(str.charAt(i));\n        }\n        return sb;\n    }\n\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder(\"Coding Ninjas Is A Coding Platform\");\n        StringBuilder ans = replaceSpaces(str);\n        System.out.println(ans);\n    }\n}",
              "link": "https://www.codingninjas.com/studio/problems/replace-spaces_1172172",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "9983a6d3-1c9f-4665-844c-14c9e76e4133",
              "isFolder": false,
              "name": "ReverseWords1.java",
              "code": "public class ReverseWords1 {\n    public static String reverseWords(String s) {\n//        Brute force solution\n//        String[] sArr = s.split(\" \");\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = sArr.length - 1; i >= 0; i--) {\n//            if (sArr[i].trim().length() != 0) {\n//                sb.append(sArr[i]).append(\" \");\n//            }\n//        }\n//        return sb.toString().trim();\n\n//        Best: 2 pointer approach\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == ' ') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != ' ') i--;\n            if (i == -1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(' ');\n        }\n        return sb.toString().trim();\n    }\n    public static void main(String[] args) {\n        String s = \"a good   example\";\n//        The string can have more than 1 space anywhere in the array\n        String ans = reverseWords(s);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/reverse-words-in-a-string/description/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "220d852e-4c06-426c-a966-4403909a00e3",
              "isFolder": false,
              "name": "ReverseWordsInAString2.java",
              "code": "import java.util.Arrays;\n\npublic class ReverseWordsInAString2 {\n//    Input: s = \"the sky is blue\"\n//    Output: \"blue is sky the\"\n    public static void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n\n    public static char[] reverseWords(char[] arr) {\n//        int start = 0;\n//        int end = arr.length;\n//        reverse(arr, start, end - 1);\n//        for (int i = 0; i < end; i++) {\n//            if (arr[i] == ' ') {\n//                reverse(arr, start, i-1);\n//                start = i+1;\n//            } else if (i == end - 1) {\n//                reverse(arr, start, i);\n//            }\n//        }\n//        return arr;\n        int start = 0;\n        int end = arr.length - 1;\n        reverse(arr, start, end);\n        for (int i = 0; i <= end; i++) {\n            if (arr[i] == ' ') {\n                reverse(arr, start, i - 1);\n                start = i + 1;\n            }\n        }\n        reverse(arr, start, end);\n        return arr;\n    }\n    public static void main(String[] args) {\n        char[] arr = {'t', 'h', 'e', ' ', 's', 'k', 'y', ' ', 'i', 's', ' ', 'b', 'l', 'u', 'e'};\n        char[] ans = reverseWords(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              "link": "https://www.lintcode.com/problem/927/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "f949002d-efeb-4ff5-a5c7-01f6035cfd25",
              "isFolder": false,
              "name": "StringCompression.java",
              "code": "import java.util.Arrays;\n\npublic class StringCompression {\n    public static int compress(char[] chars) {\n//        Best solution O(n)\n        int n = chars.length;\n        int i = 0, j = 0, slow = 0;\n        while (j < n) {\n            while (j < n && chars[i] == chars[j]) j++;\n            int diff = j - i;\n            chars[slow++] = chars[i];\n            if (diff > 1) {\n                int len = (int) (Math.log10(diff) + 1);\n                for (int k = len - 1; k >= 0; k--) {\n                    chars[slow + k] = (char) ((diff%10) + '0');\n                    diff /= 10;\n                }\n                slow += len;\n//                String s = String.valueOf(diff);\n//                for (int k = 0; k < s.length(); k++) {\n//                    chars[slow++] = s.charAt(k);\n//                }\n            }\n            i = j;\n        }\n        System.out.println(Arrays.toString(chars));\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'a', 'b', 'b', 'c', 'c', 'c'};\n        int ans = compress(chars);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/string-compression/",
              "notes": "",
              "tags": ["Strings"]
            },
            {
              "id": "5dfa970f-9b01-475d-a6f0-ae5a04ccd568",
              "isFolder": false,
              "name": "ValidPalindrome.java",
              "code": "//    The given string is polluted with characters other than numbers and alphabets.\n//    Also ignore the case while solving for the answer\n\npublic class ValidPalindrome {\n    public static boolean isPalindrome(String s) {\n//        Brute force: Remove every character that is not valid using replaceAll method\n//        This will take O(n) time to replace and O(n) time to make it lowercase and then\n//        another O(n) to iterate the array\n//        Total TC = O(3n)\n//        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Best approach: Two pointer approach\n//        Total TC = O(2n) => (lowercase and iterating)\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n\n    }\n    public static void main(String[] args) {\n        String s = \"A man, a plan, a canal: Panama\";\n        boolean ans = isPalindrome(s);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/valid-palindrome/",
              "notes": "",
              "tags": ["Strings"]
            }
          ]
        },
        {
          "id": "dfb7a0c9-aac3-41e5-b895-3ecc0634cad4",
          "isFolder": true,
          "name": "Neetcode 150",
          "content": [
            {
              "id": "0750ed97-875e-43dd-850b-ed079c9fa4df",
              "isFolder": false,
              "name": "ContainsDuplicate.java",
              "code": "import java.util.*;\n\nclass ContainsDuplicate {\n    public boolean containsDuplicate(int[] nums) {\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : nums) {\n            if (hs.contains(i)) return true;\n            hs.add(i);\n        }\n        return false;\n    }\n}",
              "link": "https://leetcode.com/problems/contains-duplicate/",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "cfede720-e6e7-4e74-8fe9-b720b9455d20",
              "isFolder": false,
              "name": "GroupAnagrams.java",
              "code": "import java.util.*;\n/*\n* Sorting and storing in hashmap and value list\n* if a duplicate string is found store it in value list.\n* If it does not exist create a new key value pair in hashmap\n*/\n\npublic class GroupAnagrams {\n    public static List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<String, List<String>> hm = new HashMap<>();\n        for (String str : strs) {\n            char[] ch = str.toCharArray();\n            Arrays.sort(ch);\n            String s = new String(ch);\n            if (!hm.containsKey(s)) {\n                hm.put(s, new ArrayList<>());\n            }\n            hm.get(s).add(str);\n        }\n        System.out.println(hm);\n        return new ArrayList<>(hm.values());\n    }\n\n    public static void main(String[] args) {\n//        String[] arr = {\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"};\n        String[] arr = {\"\"};\n        List<List<String>> ans = groupAnagrams(arr);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/group-anagrams",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "1555a28c-dc79-4ebd-bbe8-70a1922bb107",
              "isFolder": false,
              "name": "LongestConsecutiveSequence.java",
              "code": "import java.util.*;\n\npublic class LongestConsecutiveSequence {\n    public static int longestConsecutive(int[] N) {\n//        Brute force solution\n//        if (N.length == 0) return 0;\n//        Arrays.sort(N);\n//        int maxLen = 0, len = 1, last = Integer.MIN_VALUE;\n//        for (int k : N) {\n//            if (k - 1 == last) len++;\n//            else if (k != last)len = 1;\n//            last = k;\n//            maxLen = Math.max(maxLen, len);\n//        }\n//        return maxLen;\n\n//        Best solution\n        HashSet<Integer> hs = new HashSet<>();\n        int maxCount = 0;\n        for (int num: N) hs.add(num);\n        for (int j : N) {\n            if (!hs.contains(j - 1)) {\n                int x = j;\n                int count = 1;\n                while (hs.contains(x+1)) {\n                    count++;\n                    x++;\n                }\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n        return maxCount;\n    }\n    public static void main(String[] args) {\n\n    }\n}",
              "link": "https://leetcode.com/problems/longest-consecutive-sequence",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "1c04e330-fd36-4736-bad3-4213ca29233c",
              "isFolder": false,
              "name": "ProductArrayExceptSelf.java",
              "code": "public class ProductArrayExceptSelf {\n    public int[] productExceptSelf(int[] nums) {\n        int zeroCount = 0;\n        int zeroIdx = -1;\n        int[] ans = new int[nums.length];\n        int product = 1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                zeroCount++;\n                if (zeroCount > 1) return ans;\n                zeroIdx = i;\n                continue;\n            }\n            product *= nums[i];\n        }\n        if (zeroCount == 1) {\n            ans[zeroIdx] = product;\n            return ans;\n        }\n        for (int j = 0; j < nums.length; j++) {\n            ans[j] = product / nums[j];\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/product-of-array-except-self/description",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "cd62b011-bd43-4fa0-aaf5-dd956b3558bf",
              "isFolder": false,
              "name": "TopKFrequentElements.java",
              "code": "import java.util.*;\n\npublic class TopKFrequentElements {\n    public static int[] topKFrequent(int[] nums, int k) {\n        // This is the O(klogN) solution\n        // int[] kArr = new int[k];\n        // HashMap<Integer, Integer> hm = new HashMap<>();\n        // for (int num : nums) {\n        //     hm.put(num, hm.getOrDefault(num, 0) + 1);\n        // }\n        // PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue());\n        // for (Map.Entry<Integer, Integer> it : hm.entrySet()) {\n        //     pq.add(it);\n        //     if (pq.size() > k) pq.poll();\n        // }\n        // while (!pq.isEmpty()) {\n        //     kArr[--k] = pq.poll().getKey();\n        // }\n        // return kArr;\n\n        // Most efficient solution: O(n)\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        List<List<Integer>> countList = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            countList.add(new ArrayList<>());\n        }\n        for(Map.Entry<Integer, Integer> val : hm.entrySet()) {\n            countList.get(val.getValue()-1).add(val.getKey());\n        }\n        int[] ans = new int[k];\n        int ptr = 0;\n        for (int i = countList.size() - 1; i >= 0; i--) {\n            if (countList.get(i).size() != 0) {\n                for (int j: countList.get(i)) {\n                    if (ptr == k) break;\n                    ans[ptr++] = j;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 1, 1, 2, 2, 3};\n        int k = 2;\n        int[] ans = topKFrequent(nums, k);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              "link": "https://leetcode.com/problems/top-k-frequent-elements",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "387d1005-efbd-4662-b686-f5a2b4a35742",
              "isFolder": false,
              "name": "TwoSum.java",
              "code": "import java.util.HashMap;\n\npublic class TwoSum {\n  public int[] twoSum(int[] nums, int target) {\n    HashMap<Integer, Integer> hm = new HashMap<>();\n    for (int j = 0; j < nums.length; j++) {\n      if (hm.containsKey(target - nums[j]))\n        return new int[] { j, hm.get(target - nums[j]) };\n      hm.put(nums[j], j);\n    }\n    return new int[] { -1, -1 };\n  }\n}",
              "link": "https://leetcode.com/problems/two-sum",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "1206f6f6-1926-4b2a-b08e-1be06b9586de",
              "isFolder": false,
              "name": "ValidAnagram.java",
              "code": "public class ValidAnagram {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length())\n      return false;\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n      count[s.charAt(i) - 'a']++;\n      count[t.charAt(i) - 'a']--;\n    }\n    for (int i = 0; i < 26; i++) {\n      if (count[i] != 0)\n        return false;\n    }\n    return true;\n  }\n}",
              "link": "https://leetcode.com/problems/valid-anagram",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "1eef3178-0e12-46ee-afd0-807eba2afa4c",
              "isFolder": false,
              "name": "ValidSudoku.java",
              "code": "import java.util.HashSet;\n\npublic class ValidSudoku {\n    public static boolean checkBlock(int iIdx, int jIdx, char[][] board) {\n        HashSet<Character> hs = new HashSet<>();\n        int rows = iIdx + 3;\n        int cols = jIdx + 3;\n        for (int i = iIdx; i < rows; i++) {\n            for (int j = jIdx; j < cols; j++) {\n                char curr = board[i][j];\n                if (curr != '.') {\n                    if (hs.contains(curr)) return false;\n                    hs.add(curr);\n                }\n            }\n        }\n        return true;\n    }\n    public static boolean isValidSudoku(char[][] board) {\n//        Row column check\n        for (int i = 0; i < board.length; i++) {\n            HashSet<Character> row = new HashSet<>();\n            HashSet<Character> col = new HashSet<>();\n            for (int j = 0; j < board.length; j++) {\n                char r = board[i][j], c = board[j][i];\n                if (r != '.' && row.contains(r)) return false;\n                else row.add(r);\n                if (c != '.' && col.contains(c)) return false;\n                else col.add(c);\n            }\n        }\n//        3x3 box check\n        for (int i = 0; i < 9; i += 3)\n            for (int j = 0; j < 9; j += 3)\n                if (!checkBlock(i, j, board)) return false;\n\n        return true;\n    }\n}",
              "link": "https://leetcode.com/problems/valid-sudoku",
              "notes": "",
              "tags": ["Arrays & Hashing"]
            },
            {
              "id": "24c26f74-1082-475e-8a23-01cce04e6cde",
              "isFolder": false,
              "name": "FindMinInSortedRotatedArray.java",
              "code": "public class FindMinInSortedRotatedArray {\n    public int findMin(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] > arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "04378ecd-e654-4d17-bf40-5c6f0fceec54",
              "isFolder": false,
              "name": "kokoEatingBananas.java",
              "code": "public class kokoEatingBananas {\n    public long totalTimeToEat(int mid, int[] piles) {\n        long hours = 0;\n        for (int i : piles) {\n            hours += (i + mid - 1) / mid;\n        }\n        return hours;\n    }\n\n    public int minEatingSpeed(int[] piles, int h) {\n        int start = 1;\n        int end = 0;\n        for(int i: piles) {\n            end = Math.max(end, i);\n        }\n        int ans = 0;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (totalTimeToEat(mid, piles) <= h) {\n                ans = mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/koko-eating-bananas",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "cd1f4584-a64e-439c-bc67-ed0b7c5fe8e6",
              "isFolder": false,
              "name": "MedianOfTwoSortedArrays.java",
              "code": "public class MedianOfTwoSortedArrays {\n    public double findMedianSortedArrays(int[] M, int[] N) {\n       int m = M.length, n = N.length;\n       if (m > n) return findMedianSortedArrays(N, M);\n       int k = (m + n + 1)/2;\n       int start = 0, end = m;\n       while (start <= end) {\n           int mid1 = start + (end - start)/2;\n           int mid2 = k - mid1;\n           int l1 = mid1 > 0 ? M[mid1 - 1] : Integer.MIN_VALUE;\n           int l2 = mid2 > 0 ? N[mid2 - 1] : Integer.MIN_VALUE;\n           int r1 = mid1 < m ? M[mid1] : Integer.MIN_VALUE;\n           int r2 = mid2 < n ? N[mid2] : Integer.MIN_VALUE;\n           if (l1 <= r2 && l2 <= r1) {\n               double median = Math.max(l1, l2);\n               if ((m+n) %2 == 0) {\n                   median += Math.min(r1, r2);\n                   return median / 2;\n               }\n               return median;\n           }\n           if (l1 > r2) {\n               end = mid1 - 1;\n           } else {\n               start = mid1 + 1;\n           }\n       }\n       return -1;\n    }\n}",
              "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "58a98626-67a7-4786-ba31-5ee7b7ee56a5",
              "isFolder": false,
              "name": "Search2DMatrix.java",
              "code": "public class Search2DMatrix {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        int start = 0;\n        int end = n*m -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (matrix[mid/m][mid%m] == target)\n                return true;\n            if (matrix[mid/m][mid%m] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n}",
              "link": "https://leetcode.com/problems/search-a-2d-matrix",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "9a8d394e-9a16-49da-a9c1-54e47a850304",
              "isFolder": false,
              "name": "SearchInRotatedSortedArray.java",
              "code": "public class SearchInRotatedSortedArray {\n    public int search(int[] arr, int target) {\n        int start = 0; int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (target == arr[mid]) return mid;\n            if (arr[mid] >= arr[start]) {\n                if (target >= arr[start] && target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target <= arr[end] && target > arr[mid])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            }\n        }\n        return -1;\n    }\n}",
              "link": "https://leetcode.com/problems/search-in-rotated-sorted-array",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "07f2b9a8-575c-4fea-9325-771d289042a8",
              "isFolder": false,
              "name": "TimeMap.java",
              "code": "import java.util.*;\n\nclass TimeMap {\n    HashMap<String, List<String[]>> hm;\n    public TimeMap() {\n        hm = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (!hm.containsKey(key))\n            hm.put(key, new ArrayList<>());\n        hm.get(key).add(new String[]{ value, String.valueOf(timestamp) });\n    }\n\n    public String get(String key, int timestamp) {\n        if (!hm.containsKey(key)) return \"\";\n        List<String[]> list = hm.get(key);\n        int pos = findPos(list, timestamp);\n        if (pos == -1) return \"\";\n        return list.get(pos)[0];\n    }\n\n    public static int findPos(List<String[]> list, int target) {\n        int start = 0, end = list.size() - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int val = Integer.parseInt(list.get(mid)[1]);\n            if (val == target) return mid;\n            if (val > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static void main(String[] args) {\n        String[] operations = {\"TimeMap\", \"set\", \"set\", \"get\", \"get\", \"get\", \"get\", \"get\"};\n        String[][] values = {{}, {\"love\", \"high\", \"10\"}, {\"love\", \"low\", \"20\"}, {\"love\", \"5\"}, {\"love\", \"10\"}, {\"love\", \"15\"}, {\"love\", \"20\"}, {\"love\", \"25\"}};\n        TimeMap timeMap = null;\n        List<String> output = new ArrayList<>();\n        for (int i = 0; i < operations.length; i++) {\n            String[] val = values[i];\n            switch (operations[i]) {\n                case \"TimeMap\" -> {\n                    timeMap = new TimeMap();\n                    output.add(null);\n                }\n                case \"set\" -> {\n                    timeMap.set(val[0], val[1], Integer.parseInt(val[2]));\n                    output.add(null);\n                }\n                case \"get\" -> {\n                    output.add(timeMap.get(val[0], Integer.parseInt(val[1])));\n                }\n            }\n        }\n        System.out.println(output);\n    }\n}\n\n/**\n * Your TimeMap object will be instantiated and called as such:\n * TimeMap obj = new TimeMap();\n * obj.set(key,value,timestamp);\n * String param_2 = obj.get(key,timestamp);\n */",
              "link": "https://leetcode.com/problems/time-based-key-value-store",
              "notes": "",
              "tags": ["Binary Search"]
            },
            {
              "id": "bce9c188-1628-442c-9170-90f9ec09471d",
              "isFolder": false,
              "name": "ContainerWithMostWater.java",
              "code": "public class ContainerWithMostWater {\n    public static int maxArea(int[] heights) {\n        int i = 0;\n        int j = heights.length - 1;\n        int area = 0;\n        int max = 0;\n        while (i < j) {\n            if (heights[i] <= heights[j]) i++;\n            else if (heights[i] > heights[j]) j--;\n\n            area = (j - i) * Math.min(heights[i], heights[j]);\n            max = Math.max(max, area);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n        int ans = maxArea(heights);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/container-with-most-water/",
              "notes": "",
              "tags": ["Two Pointers"]
            },
            {
              "id": "e46b5bb3-bfa3-48d9-aae2-b42d6f675d82",
              "isFolder": false,
              "name": "ThreeSum.java",
              "code": "import java.util.*;\npublic class ThreeSum {\n    public List<List<Integer>> threeSum(int[] N) {\n        Arrays.sort(N);\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = N.length;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && N[i] == N[i-1]) continue;\n            int j = i+1;\n            int k = n-1;\n            while (j < k) {\n                int sum = N[i] + N[j] + N[k];\n                if (sum > 0) k--;\n                else if (sum < 0) j++;\n                else {\n                    ans.add(Arrays.asList(N[i], N[j], N[k]));\n                    j++;\n                    k--;\n                    while (j < k && N[j] == N[j-1]) j++;\n                    while (j < k && N[k] == N[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/3sum",
              "notes": "",
              "tags": ["Two Pointers"]
            },
            {
              "id": "cc629dae-c609-42b3-b664-9d2a10720b70",
              "isFolder": false,
              "name": "TrappingRainWater.java",
              "code": "// import java.util.Arrays;\npublic class TrappingRainWater {\n    public static int trap(int[] height) {\n        int n = height.length;\n//        int[] maxLeft = new int[n];\n//        int[] maxRight = new int[n];\n//        int leftMax = 0, rightMax = 0;\n//        for (int i = 0; i < n; i++) {\n//            maxLeft[i] = leftMax;\n//            leftMax = Math.max(leftMax, height[i]);\n//            maxRight[n - i - 1] = rightMax;\n//            rightMax = Math.max(rightMax, height[n - i - 1]);\n//        }\n//        int count = 0;\n//        for (int j = 0; j < n; j++) {\n//            count += Math.max(Math.min(maxLeft[j], maxRight[j]) - height[j], 0);\n//        }\n//        return count;\n        int start = 0, end = n - 1;\n        int maxL = height[start], maxR = height[end];\n        int c = 0;\n        while (start < end) {\n            if (height[start] <= height[end]) {\n                start++;\n                maxL = Math.max(maxL, height[start]);\n                c += Math.max(maxL - height[start], 0);\n\n            } else {\n                end--;\n                maxR = Math.max(maxR, height[end]);\n                c += Math.max(maxR - height[end], 0);\n            }\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n        int ans = trap(arr);\n        System.out.println(ans);\n    }\n}",
              "link": "https://leetcode.com/problems/trapping-rain-water/",
              "notes": "",
              "tags": ["Two Pointers"]
            },
            {
              "id": "4f96c75c-9dce-4e7e-b5c2-d6891721ec88",
              "isFolder": false,
              "name": "TwoSumSortedArray.java",
              "code": "public class TwoSumSortedArray {\n    public static int[] twoSum(int[] N, int target) {\n//        Brute force: Linear search the pair using 2 for loops (nested) O(N^2)\n\n//        Better solution: Use 2 pointer from left and right to get sum\n\n//        Optimised solution: Binary search\n        int start = 0;\n        int end = N.length - 1;\n        int[] ans = {-1, -1};\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int sum = N[start] + N[end];\n            if (sum == target){\n                ans[0] = start + 1;\n                ans[1] = end + 1;\n                return ans;\n            }\n            if (sum > target)\n                end = N[start] + N[mid] > target ? mid - 1 : end - 1;\n            else\n                start = N[end] + N[mid] < target ? mid + 1 : start + 1;\n        }\n        return ans;\n    }\n}",
              "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
              "notes": "",
              "tags": ["Two Pointers"]
            },
            {
              "id": "a9d190c2-dfbf-410c-8498-3986d9ea057e",
              "isFolder": false,
              "name": "ValidPalindrome.java",
              "code": "public class ValidPalindrome {\n    public boolean isPalindrome(String s) {\n//        Brute force solution\n//        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Optimised solution\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n    }\n}",
              "link": "https://leetcode.com/problems/valid-palindrome/",
              "notes": "",
              "tags": ["Two Pointers"]
            }
          ]
        }
      ]
    }
  ]
}
