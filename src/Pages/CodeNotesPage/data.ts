const data = {
  id: '58d77e6e-8a5e-49b7-af10-2fdcbe4f5b41',
  isFolder: true,
  name: 'DSA',
  content: [
    {
      id: 'f7872923-0e1d-49b7-b09f-e717a7c67700',
      isFolder: true,
      name: 'DSAPrepQuestions',
      content: [
        {
          id: 'd767effa-92eb-4f1d-b1b0-44d39742795b',
          isFolder: true,
          name: 'Combined',
          content: [
            {
              id: '0b7a5b3e-2c66-4c7f-960c-bb0657014adf',
              isFolder: false,
              name: 'AddToArrayFormOfInteger.java',
              code: 'import java.util.*;\n\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            num[i] += k;\n            k = num[i] / 10;\n            ans.add(0, num[i] % 10);\n        }\n        while (k != 0) {\n            ans.add(0, k % 10);\n            k /= 10;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/add-to-array-form-of-integer',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'e13b9128-a39f-4dda-931d-0af8d8fa5a3c',
              isFolder: false,
              name: 'CellWithOddValuesInMatrix.java',
              code: 'public class CellWithOddValuesInMatrix {\n    public int oddCells(int m, int n, int[][] I) {\n        // M = rows, N = cols\n        boolean[] row = new boolean[m];\n        boolean[] col = new boolean[n];\n        int r=0, c=0;\n        for (int i = 0; i < I.length; i++) {\n            row[I[i][0]] ^= true;\n            col[I[i][1]] ^= true;\n        }\n        for (int j = 0; j < n; j++)\n            if (col[j]) c++;\n\n        for (int j = 0; j < m; j++)\n            if (row[j]) r++;\n\n        // r(n-c) + c(m-r)\n        // rn + cm - rc - rc\n        return r*n + c*m - 2*r*c;\n    }\n}',
              link: 'https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '4ee40b7d-f604-40df-b553-bbc6b7696b8e',
              isFolder: false,
              name: 'GoodArray.java',
              code: 'public class GoodArray {\n    public boolean isGoodArray(int[] N) {\n        int ans = N[0];\n        for (int i = 1; i < N.length; i++)\n            ans = GCD(N[i], ans);\n        return ans == 1;\n    }\n    public int GCD(int a, int b) {\n        if (a%b == 0) return b;\n        return GCD(b, a%b);\n    }\n}',
              link: 'https://leetcode.com/problems/check-if-it-is-a-good-array/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '48da4bdd-9e3a-4319-95da-58db5a5f805c',
              isFolder: false,
              name: 'IsStringASubSequence.java',
              code: 'public class IsStringASubSequence {\n    public static boolean check(String s1, String s2) {\n        int i = 0, j = 0;\n        return checkRecursively(s1, s2, i, j);\n\n        // int i = 0, j = 0;\n        // while (i < A.length() && j < B.length()) {\n        //     if (A.charAt(i) == B.charAt(j)) i++;\n        //     j++;\n        // }\n        // return i >= A.length();\n    }\n    public static boolean checkRecursively(String s1, String s2, int i, int j) {\n        if (i >= s1.length()) return true;\n        if (j >= s2.length()) return false;\n        if (s1.charAt(i) == s2.charAt(j)) {\n            return checkRecursively(s1, s2, i+1, j+1);\n        }\n        return checkRecursively(s1, s2, i, j+1);\n    }\n    public static void main(String[] args) {\n        String s1 = "ABCD";\n        String s2 = "ADB";\n        System.out.println(check(s1, s2));\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/check-for-subsequence4930/1',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '614b1709-1efc-43f4-b8f8-c3df0f733e11',
              isFolder: false,
              name: 'JumpGame.java',
              code: 'public class JumpGame {\n    public boolean canJump(int[] nums) {\n        int n = nums.length - 1;\n        int goal = n;\n        for (int i = n; i >= 0; i--) {\n            if (i + nums[i] >= goal)\n                goal = i;\n        }\n        return goal == 0;\n    }\n}',
              link: 'https://leetcode.com/problems/jump-game/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'adc169e0-e674-4cf4-b77c-48cb45c48a04',
              isFolder: false,
              name: 'LeftMostRepeatingCharacter.java',
              code: "public class LeftMostRepeatingCharacter {\n    public static int indexLeftMostRepeatedCharacter (String str) {\n//        Brute force approach: O(N^2)\n//        Use 2 nested loops to check every character's occurrence it found break loop and return index\n//        for (int i = 0; i < str.length(); i++) {\n//            char ch = str.charAt(i);\n//            for (int j = i+1; j < str.length(); j++) {\n//                if (str.charAt(j) == ch) return i;\n//            }\n//        }\n//        return -1;\n\n//        Better Solution: O(2N)\n//        Uses 1 integer array to store count of all characters in 1 iteration, then in next iteration is count is > 1 that's the index else -1\n//        int[] bucket = new int[26];\n//        for (int i = 0; i < str.length(); i++) {\n//            bucket[str.charAt(i) - 'a']++;\n//        }\n//        for (int j = 0; j < str.length(); j++) {\n//            if (bucket[str.charAt(j) - 'a'] > 1) return j;\n//        }\n//        return -1;\n\n//        Best Solution: O(N)\n//        Use the bucket concept along with a min index value variable that will hold the min possible value of index as I traverse the array\n        int[] bucket = new int[26];\n        int minIdx = Integer.MAX_VALUE;\n        for (int i = str.length() - 1; i >= 0; i--) {\n            int idx = str.charAt(i) - 'a';\n            bucket[idx]++;\n            if (bucket[idx] > 1) {\n                minIdx = i;\n            }\n        }\n        if (minIdx == Integer.MAX_VALUE) return -1;\n        return minIdx;\n    }\n    public static void main(String[] args) {\n//        Only considering lowercase alphabets\n        String s = \"geeksforgeeks\";\n        int ans = indexLeftMostRepeatedCharacter(s);\n        System.out.println(ans);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '50aeaa87-f249-4797-bad1-d8fd3a84f35c',
              isFolder: false,
              name: 'LongestOddEvenSubarray.java',
              code: "public class LongestOddEvenSubarray {\n    public static int longestOddEvenCount (int[] arr) {\n//        Brute force\n//        int count = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int c = 1;\n//            for (int j = i+1; j < arr.length; j++) {\n//                if (arr[j]%2 == 0 && arr[j-1]%2!= 0 || arr[j]%2 != 0 && arr[j-1]%2== 0) {\n//                    c++;\n//                } else {\n//                    break;\n//                }\n//            }\n//            count = Math.max(c, count);\n//        }\n//        return count;\n\n//        Optimised: Kadane's algorithm\n        int count = 1;\n        int max = 1;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i]%2 == 0 && arr[i-1]%2!= 0 || arr[i]%2 != 0 && arr[i-1]%2== 0) {\n                count++;\n                max = Math.max(count, max);\n            } else {\n                count = 1;\n            }\n        }\n        return max;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 10, 20, 6, 3, 8};\n        int count = longestOddEvenCount(arr);\n        System.out.println(count);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '920b122e-5092-4955-81e9-d5a9c20212cf',
              isFolder: false,
              name: 'MaxCircularSubarraySum.java',
              code: "public class MaxCircularSubarraySum {\n    public static int normalSubarrayMaxSum(int[] arr) {\n        int sum = arr[0];\n        int maxSum = arr[0];\n        int n = arr.length;\n        for (int i = 1; i < n; i++) {\n            sum += arr[i];\n            maxSum = Math.max(sum, maxSum);\n            if (sum < 0) sum = 0;\n        }\n        return maxSum;\n    }\n\n    public static int maxCircularSubarraySum(int[] arr) {\n//        Brute force approach\n//        int n = arr.length;\n//        int sum = arr[0];\n//        for (int i = 0; i < n; i++) {\n//            int curr_sum = arr[i];\n//            int curr_max = arr[i];\n//            for (int j = 1; j < n; j++) {\n//                curr_sum += arr[(i+j)%n];\n//                curr_max = Math.max(curr_sum, curr_max);\n//            }\n//            sum = Math.max(sum, curr_max);\n//        }\n//        return sum;\n\n//        Optimised approach\n        int normalSum = normalSubarrayMaxSum(arr);\n        if (normalSum < 0) return normalSum;\n        int circularSum = arr[0];\n        int sum = arr[0];\n        int wholeSum = arr[0];\n//        We can also invert the array and get normal max sum using same function instead of modifying kadane's algorithm\n//        In that case we add it with wholeSum\n        for (int i = 1; i < arr.length; i++) {\n            wholeSum += arr[i];\n            sum += arr[i];\n            circularSum = Math.min(circularSum, sum);\n            if (sum > 0) sum = 0;\n        }\n        return Math.max(normalSum, wholeSum - circularSum);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-10, -5, -5, -1, -2, -4};\n        int ans = maxCircularSubarraySum(arr);\n        System.out.println(ans);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'f316681b-8055-45fc-8ad5-76ac6d579c4a',
              isFolder: false,
              name: 'NumberOfGoodPairs.java',
              code: 'import java.util.*;\n\npublic class NumberOfGoodPairs {\n    public static int numIdenticalPairs(int[] nums) {\n        // O(n) solution\n        int numberOfGoodPairs = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i: nums) {\n            if (hm.containsKey(i)) {\n                numberOfGoodPairs += hm.get(i);\n            }\n            hm.put(i, hm.getOrDefault(i, 0) + 1);\n        }\n        return numberOfGoodPairs;\n\n        // O(n^2) solution\n        // int numberOfGoodPairs = 0;\n        // for (int i=0; i < nums.length -1; i++) {\n        //     for (int j=i+1; j < nums.length; j++) {\n        //         if (nums[i] == nums[j]) {\n        //             numberOfGoodPairs++;\n        //         }\n        //     }\n        // }\n        // return numberOfGoodPairs;\n    }\n}',
              link: 'https://leetcode.com/problems/number-of-good-pairs/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '76bcf6d8-c217-4941-bdcd-043b7e02d7e0',
              isFolder: false,
              name: 'NumbersSmallerThanCurrentNumber.java',
              code: 'public class NumbersSmallerThanCurrentNumber {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] counts = new int[102];\n        for (int num : nums)\n            counts[num]++;\n        for (int j = 1; j < counts.length; j++)\n            counts[j] += counts[j - 1];\n        int[] ans = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0)\n                ans[i] = 0;\n            else\n                ans[i] = counts[nums[i] - 1];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'ccfc4667-ab40-4f7c-a619-04eaf81f34b9',
              isFolder: false,
              name: 'SpiralMatrix3.java',
              code: 'public class SpiralMatrix3 {\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\n        int[] directions = {0, 1, 0, -1, 0};\n        int[][] ans = new int[rows*cols][2];\n        ans[0] = new int[] {rStart, cStart};\n        int len = 0, d = 0, ptr = 1;\n        while (ptr < ans.length) {\n            if (d == 0 || d == 2) len++;\n            for (int i = 0; i < len; i++) {\n                rStart += directions[d];\n                cStart += directions[d+1];\n                if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {\n                    ans[ptr++] = new int[] {rStart, cStart};\n                }\n            }\n            d = ++d%4;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/spiral-matrix-iii/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '9a1fc171-cecf-45a6-857e-fc6d8765d2a8',
              isFolder: false,
              name: 'WavePrint.java',
              code: 'import java.util.Arrays;\n\npublic class WavePrint {\n    public static int[] wavePrint(int arr[][], int nRows, int mCols) {\n        // Write your code here.\n        int[] ans = new int[nRows*mCols];\n        int ptr = 0;\n        for (int i = 0; i < mCols; i++) {\n            if ((i&1) == 0) {\n                // TB\n                for (int j = 0; j < nRows; j++) {\n                    ans[ptr++] = arr[j][i];\n                }\n            } else {\n                // BT\n                for (int j = nRows - 1; j >= 0; j--) {\n                    ans[ptr++] = arr[j][i];\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12}\n        };\n        int[] ans = wavePrint(mat, mat.length, mat[0].length);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/print-like-a-wave_893268',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'c7fdc6bb-aa34-4681-b805-ce76b643cf30',
              isFolder: false,
              name: 'ArrangingCoins.java',
              code: 'public class ArrangingCoins {\n    public static int arrangeCoins(int n) {\n//        Brute force solution\n//        if (n <= 1) return n;\n//        int i;\n//        for (i = 0; i < n; i++) {\n//            long ans = ((long) i *(i+1))/2;\n//            if (ans > n) break;\n//        }\n//        return i-1;\n\n//        Better solution\n//        long start = 0, end = n;\n//        while (start <= end) {\n//            long mid = start + (end - start)/2;\n//            long val = (mid * (mid+1))/2;\n//            if (val == n) return (int) mid;\n//            if (val > n) {\n//                end = mid - 1;\n//            } else {\n//                start = mid + 1;\n//            }\n//        }\n//        return (int) end;\n\n//        Optimised solution\n//         Equation: k(k+1)/2 = n\n//         k^2 + k = 2*n\n//         k^2 + k + 1/4 = 2*n + 1/4\n//         (k + 1/2)^2 = 2n + 1/4\n//         k = sqrt(2n + 1/4) - 1/2\n        return (int) (Math.sqrt(2L*n + 0.25) - 0.5);\n    }\n\n    public static void main(String[] args) {\n        int ans = arrangeCoins(1804289383);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/arranging-coins/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '38b5aee4-e1bc-4948-bad9-7ad2c6663e12',
              isFolder: false,
              name: 'FindRightInterval.java',
              code: 'import java.util.*;\npublic class FindRightInterval {\n    public static int[] findRightInterval(int[][] intervals) {\n        int[][] copy = new int[intervals.length][2];\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            copy[i] = intervals[i];\n            hm.put(intervals[i][0], i);\n        }\n        Arrays.sort(copy, Comparator.comparingInt(a -> a[0]));\n        int[] ans = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            int pos = search(copy, intervals[i][1]);\n            ans[i] = pos == -1 ? pos : hm.get(copy[pos][0]);\n        }\n        return ans;\n    }\n    public static int search(int[][] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid][0] == target) return mid;\n            if (arr[mid][0] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        if (start == arr.length) return -1;\n        return start;\n    }\n}',
              link: 'https://leetcode.com/problems/find-right-interval/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '414ab69f-0cb4-4397-887b-a1d03cd8d4a8',
              isFolder: false,
              name: 'FrequencyOfMostFrequentElement.java',
              code: 'import java.util.*;\n\npublic class FrequencyOfMostFrequentElement {\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums);\n        int l = 0, r = 0;\n        long maxLen = 1, total = 0;\n        while (r < nums.length) {\n            total += nums[r];\n            while ((long) nums[r] * (r - l + 1) > total + k) {\n                total -= nums[l++];\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n            r++;\n        }\n        return (int) maxLen;\n    }\n}',
              link: 'https://leetcode.com/problems/frequency-of-the-most-frequent-element/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '04f604c0-55a1-45e1-8938-0d155018b65b',
              isFolder: false,
              name: 'MaxValueAtGivenIndexInBoundedArray.java',
              code: 'public class MaxValueAtGivenIndexInBoundedArray {\n    public long getFormulaSum(int count, long mid) {\n        long c = Math.min(count, mid-1);\n        return c*mid - c*(c+1)/2 + Math.max(count - (mid-1), 0); // Adds extra 1s if any\n    }\n    public int maxValue(int n, int index, int maxSum) {\n        long start = 1;\n        long end = maxSum;\n        long result = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long totalSum = getFormulaSum(index, mid);\n            totalSum += mid;\n            totalSum += getFormulaSum(n-index-1, mid);\n            if (totalSum <= maxSum) {\n                result = mid;\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return (int)result;\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'dba8d4c7-c3d5-401b-898a-c552f17590bf',
              isFolder: false,
              name: 'MinAbsoluteSumDifference.java',
              code: 'import java.util.*;\npublic class MinAbsoluteSumDifference {\n    public int minAbsoluteSumDiff(int[] N, int[] M) {\n        int[] abs = new int[N.length];\n        long maxSum = 0;\n        for (int i = 0; i < N.length; i++) {\n            abs[i] = Math.abs(N[i] - M[i]);\n            maxSum += abs[i];\n        }\n        Arrays.sort(N);\n        int max = 0;\n        for (int j = 0; j < N.length; j++) {\n            int minValue = Math.abs(M[j] - bSearch(N, M[j]));\n            int diff = abs[j] - minValue;\n            max = Math.max(max, diff);\n        }\n        return (int)((maxSum - max) % 1000000007);\n    }\n    public static int bSearch(int[] N, int target){\n        int start = 0, end = N.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (N[mid] == target) return N[mid];\n            if (N[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        if (start == N.length) start--;\n        if (end == -1) end++;\n        int diff1 = Math.abs(target - N[start]);\n        int diff2 = Math.abs(target - N[end]);\n        if (diff1 > diff2) return N[end];\n        return N[start];\n    }\n}',
              link: 'https://leetcode.com/problems/minimum-absolute-sum-difference/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'b60da18f-d101-4984-90dd-c622dd52532f',
              isFolder: false,
              name: 'ReachANumber.java',
              code: 'public class ReachANumber {\n    public static long formula(long n) {\n        return (n*(n+1))>>1;\n    }\n\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        long start = 1, end = target;\n        int steps = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long distance = formula(mid);\n            if (distance >= target) {\n                steps = (int) mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        long dist = formula(steps) - target;\n        if ((dist&1) != 0) {\n            return steps + ((steps&1) == 0 ? 1 : 2);\n        }\n        return steps;\n    }\n}',
              link: 'https://leetcode.com/problems/reach-a-number/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '7ca37931-1b44-478f-9a12-ef0fbc8d90ae',
              isFolder: false,
              name: 'CousinsInBinaryTree.java',
              code: 'import java.util.*;\npublic class CousinsInBinaryTree {\n    static class Pair {\n        int val, parent, lvl;\n        Pair (int v, int p, int lvl) {\n            this.val = v;\n            this.parent = p;\n            this.lvl = lvl;\n        }\n    }\n    public boolean isCousins(TreeNode root, int x, int y) {\n        if (root.val == x || root.val == y) return false;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        int lvl = 0, idx = 0;\n        Pair[] ans = new Pair[2];\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                if (node.left != null) {\n                    q.add(node.left);\n                    if (node.left.val == x || node.left.val == y) {\n                        ans[idx++] = new Pair(node.left.val, node.val, lvl+1);\n                    }\n                }\n                if (node.right != null) {\n                    q.add(node.right);\n                    if (node.right.val == x || node.right.val == y) {\n                        ans[idx++] = new Pair(node.right.val, node.val, lvl+1);\n                    }\n                }\n            }\n            if (idx == 2) break;\n            lvl++;\n        }\n        return ans[0].parent != ans[1].parent && ans[0].lvl == ans[1].lvl;\n    }\n}',
              link: 'https://leetcode.com/problems/cousins-in-binary-tree/',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '7e1d8366-1f98-49cf-8375-365bdefc011a',
              isFolder: false,
              name: 'DiagonalTraversalBT.java',
              code: 'import java.util.*;\npublic class DiagonalTraversalBT {\n    public ArrayList<Integer> diagonal(TreeNode root) {\n        //add your code here.\n        ArrayList<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            TreeNode curr = q.poll();\n            while (curr != null) {\n                ans.add(curr.val);\n                if (curr.left != null) {\n                    q.add(curr.left);\n                }\n                curr = curr.right;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/diagonal-traversal-of-binary-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '14402c0c-41f3-499a-9716-50590f424cb3',
              isFolder: false,
              name: 'KSumPaths.java',
              code: 'import java.util.*;\npublic class KSumPaths {\n    void solve(int sum, TreeNode root, int k, HashMap<Integer, Integer> hm, int[] count) {\n        if (root == null) return;\n        sum += root.val;\n        if (hm.containsKey(sum - k)) {\n            count[0] += hm.get(sum - k);\n        }\n        hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n        solve(sum, root.left, k, hm, count);\n        solve(sum, root.right, k, hm, count);\n        hm.put(sum, hm.get(sum) - 1);\n    }\n    public int sumK(TreeNode root,int k) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        int[] count = new int[1];\n        solve(0, root, k, hm, count);\n        return count[0];\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/k-sum-paths/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '7eae9c62-3101-4d6e-ab27-ecc8ac641104',
              isFolder: false,
              name: 'KthAncestorInBinaryTree.java',
              code: 'import java.util.*;\npublic class KthAncestorInBinaryTree {\n    public boolean solve(TreeNode root, int node, List<Integer> temp) {\n        if (root == null) return false;\n        temp.add(root.val);\n        if (root.val == node || solve(root.left, node, temp) || solve(root.right, node, temp)) return true;\n        temp.remove(temp.size() - 1);\n        return false;\n    }\n    public int kthAncestor(TreeNode root, int k, int node) {\n        List<Integer> temp = new ArrayList<>();\n        if (!solve(root, node, temp) || k > temp.size() - 1 || root.val == node)\n            return -1;\n        return temp.get(temp.size() - k - 1);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/kth-ancestor-in-a-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: 'bd926d5d-5e92-4606-b78b-e102bdf791fa',
              isFolder: false,
              name: 'LongestPathRootToLeafSum.java',
              code: 'public class LongestPathRootToLeafSum {\n    public static void solve(TreeNode root, int[] ans, int sum, int length) {\n        if (root == null) {\n            if (length > ans[1]) {\n                ans[1] = length;\n                ans[0] = sum;\n            } else if (length == ans[1]) {\n                ans[0] = Math.max(sum, ans[0]);\n            }\n            return;\n        }\n        solve(root.left, ans, sum + root.val, length + 1);\n        solve(root.right, ans, sum + root.val, length + 1);\n    }\n    public int sumOfLongRootToLeafPath(TreeNode root) {\n        //code here\n        // { maxSum, maxLength }\n        int[] ans = new int[2];\n        solve(root, ans, 0, 0);\n        return ans[0];\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/sum-of-the-longest-bloodline-of-a-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: 'a723fdd3-f08e-4522-b62f-1321a25741c2',
              isFolder: false,
              name: 'MaximumSumOfNonAdjacentNodes.java',
              code: 'public class MaximumSumOfNonAdjacentNodes {\n    static class Pair {\n        int f, s;\n\n        Pair(int f, int s) {\n            this.f = f;\n            this.s = s;\n        }\n    }\n\n    //Function to return the maximum sum of non-adjacent nodes.\n    static Pair solve(TreeNode root) {\n        if (root == null) {\n            return new Pair(0, 0);\n        }\n        Pair l = solve(root.left);\n        Pair r = solve(root.right);\n        int first = root.val + l.s + r.s;\n        int second = Math.max(l.f, l.s) + Math.max(r.f, r.s);\n        return new Pair(first, second);\n    }\n\n    static int getMaxSum(TreeNode root) {\n        // add your code here\n        // Pair(include, exclude)\n        Pair p = solve(root);\n        return Math.max(p.f, p.s);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/maximum-sum-of-non-adjacent-nodes/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '6f853bd2-f940-4923-86c7-39f76927d2d6',
              isFolder: false,
              name: 'PopulatingNextRightPointersInEachNode.java',
              code: 'import java.util.*;\n\npublic class PopulatingNextRightPointersInEachNode {\n    // Definition for a Node.\n    public static class Node {\n        public int val;\n        public Node left;\n        public Node right;\n        public Node next;\n\n        public Node() {}\n\n        public Node(int _val) {\n            val = _val;\n        }\n\n        public Node(int _val, Node _left, Node _right, Node _next) {\n            val = _val;\n            left = _left;\n            right = _right;\n            next = _next;\n        }\n    };\n    public Node connect(Node root) {\n        if (root == null) return null;\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Node node = q.poll();\n                if (!q.isEmpty() && i != size - 1) {\n                    node.next = q.peek();\n                }\n                if (node.left != null) q.add(node.left);\n                if (node.right != null) q.add(node.right);\n            }\n        }\n        return root;\n    }\n}',
              link: 'https://leetcode.com/problems/populating-next-right-pointers-in-each-node/',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '7e42cf34-bcf0-4afe-ac50-2aaef919645c',
              isFolder: false,
              name: 'SumAtKLevel.java',
              code: 'import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class SumAtKLevel {\n    public static int sumAtKLevel(TreeNode root, int k) {\n        Queue<TreeNode> q = new LinkedList<>();\n        int sum = 0;\n        int lvl = 0;\n        q.add(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode temp = q.poll();\n                if (temp != null) {\n                    if (lvl == k) {\n                        sum += temp.val;\n                    }\n                    if (temp.left != null) q.add(temp.left);\n                    if (temp.right != null) q.add(temp.right);\n                }\n            }\n            lvl++;\n        }\n        return sum;\n    }\n\n//    public static void main(String[] args) {\n////        Tree building\n//        BinarySearchTree tree = new BinarySearchTree();\n//        int[] input = {7, 3, 5, 11, 17, 1, 8};\n//        for (int j : input) tree.insert(j);\n//        int k = 0;\n//        int ans = sumAtKLevel(tree.buildTree(), k);\n//        System.out.println(ans);\n//    }\n}',
              link: null,
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '37cd85cd-d96a-47a2-8fae-e7dbac99037b',
              isFolder: false,
              name: 'SumTree.java',
              code: 'public class SumTree {\n    int solve(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return root.val;\n        int l = solve(root.left);\n        int r = solve(root.right);\n        if (l == - 1 || r == - 1 || root.val != (l + r)) return -1;\n        return l + r + root.val;\n    }\n    boolean isSumTree(TreeNode root) {\n        return solve(root) != -1;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/sum-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: 'dc095e64-c912-433f-8574-7ff8df7b1aaa',
              isFolder: false,
              name: 'KClosestNumbers.java',
              code: 'import java.util.*;\n\npublic class KClosestNumbers {\n    static class Pair {\n        int val;\n        int key;\n        Pair(int v, int k) {\n            this.val = v;\n            this.key = k;\n        }\n    }\n\n    public static List<Integer> findClosestElements(int[] arr, int k, int x) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.key == a.key ? b.val - a.val : b.key - a.key);\n        for (int num : arr) {\n            pq.add(new Pair(num, Math.abs(x - num)));\n            if (pq.size() > k) pq.poll();\n        }\n        List<Integer> ans = new ArrayList<>();\n        while (!pq.isEmpty()) ans.add(pq.poll().val);\n        Collections.sort(ans);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int k = 4, x = 3;\n        List<Integer> ans = findClosestElements(arr, k, x);\n        System.out.println("Final: " + ans);\n    }\n}',
              link: 'https://leetcode.com/problems/find-k-closest-elements/',
              notes: '',
              tags: ['Heaps'],
            },
            {
              id: 'fc5f685d-9b78-452e-8f80-366e7af56734',
              isFolder: false,
              name: 'KClosestPointsToOrigin.java',
              code: 'import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class KClosestPointsToOrigin {\n    static class Pair {\n        int key;\n        int x, y;\n\n        Pair(int coor_x, int coor_y, int k) {\n            this.key = k;\n            this.x = coor_x;\n            this.y = coor_y;\n        }\n    }\n\n    public static int[][] kClosest(int[][] points, int k) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.key - a.key);\n        for (int[] point : points) {\n            int x = point[0];\n            int y = point[1];\n            pq.add(new Pair(x, y, x * x + y * y));\n            if (pq.size() > k) pq.poll();\n        }\n        int[][] ans = new int[pq.size()][2];\n        int idx = 0;\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            ans[idx++] = new int[]{p.x, p.y};\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] points = {{3, 3}, {5, -1}, {-2, 4}};\n        int k = 2;\n        int[][] ans = kClosest(points, k);\n        for (int[] arr : ans) {\n            System.out.println(Arrays.toString(arr));\n        }\n    }\n}',
              link: null,
              notes: '',
              tags: ['Heaps'],
            },
            {
              id: 'dd59b647-3ee6-4d73-8919-49b4c9e9fe23',
              isFolder: false,
              name: 'SquareRootWithPrecision.java',
              code: 'public class SquareRootWithPrecision {\n    public static int sqrt(int n) {\n        int start = 0, end = n;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            int root = mid * mid;\n            if (root == n) return mid;\n            if (root > n)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int getClosestSqrt(double n, int val, int num) {\n        int start = 0, end = 9;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            double x = n + mid / (double) val;\n            double root = x * x;\n            if (root < num)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return end;\n    }\n\n    public static double getSquareRootWithPrecision(int n, int p) {\n        double num = sqrt(n);\n        int increment = 10;\n        for (int i = 0; i < p; i++) {\n            int x = getClosestSqrt(num, increment, n); // log10\n            num += (double) x / increment;\n            increment *= 10;\n        }\n        return num;\n    }\n\n    public static void main(String[] args) {\n        int n = 40;\n        int p = 3;\n        double ans = getSquareRootWithPrecision(n, p);\n        System.out.printf("%.{%d}f", p, ans);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/find-square-root-number-upto-given-precision-using-binary-search/',
              notes: '',
              tags: ['Maths'],
            },
            {
              id: 'f087b8f7-69a0-429b-9214-5bca0789a88a',
              isFolder: false,
              name: 'XorOfRange.java',
              code: 'public class XorOfRange {\n    public static void main(String[] args) {\n        int n = 9;\n        int ans1 = computeXor(n);\n        int ans2 = computeXorEfficient(n);\n        System.out.println(ans1 + "  " + ans2);\n    }\n\n    static int computeXor(int n) {\n        if (n == 0) return 0;\n        int uni = 0;\n        for (int i = 1; i <= n; i++) {\n            uni = uni ^ i;\n        }\n        return uni;\n    }\n\n    static int computeXorEfficient(int n) {\n        int rem = n % 4;\n        switch (rem) {\n            case 0 -> {\n                return n;\n            }\n            case 1 -> {\n                return 1;\n            }\n            case 2 -> {\n                return n + 1;\n            }\n        }\n        return 0;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/find-xor-of-numbers-from-the-range-l-r/',
              notes: '',
              tags: ['Maths'],
            },
            {
              id: 'c08d1ed4-1f5f-4c48-ae5f-1cceb62dcd98',
              isFolder: false,
              name: 'CircularTour.java',
              code: 'public class CircularTour {\n    int tour(int[] petrol, int[] distance) {\n        // Your code here\n        int start = 0, b = 0, d = 0;\n        for (int i = 0; i < petrol.length; i++) {\n            b += petrol[i] - distance[i];\n            if (b < 0) {\n                d += b;\n                start = i + 1;\n                b = 0;\n            }\n        }\n        return b + d > 0 ? start : -1;\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/circular-tour-1587115620/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '29789e76-ef2d-4d3c-9143-6a51d3bb1074',
              isFolder: false,
              name: 'FirstNonRepeatingCharacterInAStream.java',
              code: "import java.util.*;\npublic class FirstNonRepeatingCharacterInAStream {\n    public String FirstNonRepeating(String A) {\n        // code here\n        StringBuilder sb = new StringBuilder();\n        Queue<Character> q = new LinkedList<>();\n        int[] bucket = new int[26];\n        for (int i = 0; i < A.length(); i++) {\n            char ch = A.charAt(i);\n            q.offer(ch);\n            bucket[ch - 'a']++;\n            while (!q.isEmpty() && bucket[q.peek() - 'a'] > 1) q.poll();\n            sb.append(q.isEmpty() ? '#' : q.peek());\n        }\n        return sb.toString();\n    }\n}",
              link: 'https://practice.geeksforgeeks.org/problems/first-non-repeating-character-in-a-stream1216/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '647b1787-3959-4701-a240-4f351c0dc5ed',
              isFolder: false,
              name: 'NegativeNumberInWindowOfSizeK.java',
              code: 'import java.util.*;\npublic class NegativeNumberInWindowOfSizeK {\n    public long[] printFirstNegativeInteger(long A[], int N, int k) {\n        Queue<Integer> q = new LinkedList<>();\n        long[] ans = new long[N - k + 1];\n        int i = 0;\n        for (int j = 0; j < N; j++) {\n            if (A[j] < 0) q.offer(j);\n            if (j - i + 1 == k) {\n                if (!q.isEmpty() && q.peek() < i) q.poll();\n                ans[i] = q.isEmpty() ? 0 : A[q.peek()];\n                i++;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/first-negative-integer-in-every-window-of-size-k3345/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: 'b1cd7cd3-87d5-48a9-9b58-db767faa8c58',
              isFolder: false,
              name: 'ReverseFirstKElementsOfQueue.java',
              code: 'import java.util.*;\npublic class ReverseFirstKElementsOfQueue {\n    public Queue<Integer> modifyQueue(Queue<Integer> q, int k) {\n        // add code here.\n        Stack<Integer> st = new Stack<>();\n        // k = k % q.size();\n        for (int i = 0; i < k; i++) st.push(q.poll());\n        while (!st.isEmpty()) q.offer(st.pop());\n        int n = q.size();\n        for (int i = 0; i < n - k; i++) q.offer(q.poll());\n        return q;\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/reverse-first-k-elements-of-queue/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: 'fbfc8f78-d5c0-4252-8d46-62b67110ab73',
              isFolder: false,
              name: 'ReverseQueue.java',
              code: 'import java.util.*;\n\npublic class ReverseQueue {\n    //Function to reverse the queue. (Did it with recursion as well but stackoverflow)\n    public Queue<Integer> rev(Queue<Integer> q){\n        //add code here.\n        Stack<Integer> st = new Stack<>();\n        while (!q.isEmpty()) st.push(q.poll());\n        while (!st.isEmpty()) q.offer(st.pop());\n        return q;\n    }\n\n    public static void main(String[] args) {\n        Queue<Integer> q = new LinkedList<>();\n\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/queue-reversal/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '74a0211f-6a4c-4bcf-8d3d-8ff7b59b5d83',
              isFolder: false,
              name: 'SlidingWindowMaximum.java',
              code: 'import java.util.*;\n\npublic class SlidingWindowMaximum {\n    public static int[] maxInEachWindow(int[] arr, int k) {\n        int n = arr.length;\n        int[] ans = new int[n - k + 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        int i = 0;\n        for (int j = 0; j < n; j++) {\n            if (!dq.isEmpty() && i > dq.peekFirst()) dq.pollFirst();\n            while (!dq.isEmpty() && arr[j] > arr[dq.peekLast()]) dq.pollLast();\n            dq.offerLast(j);\n            if (j - i + 1 == k) {\n                ans[i++] = arr[dq.peekFirst()];\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 8, 5, 12, 15, 7, 6};\n        int k = 3;\n        int[] ans = maxInEachWindow(arr, k);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '96e07e82-44ea-46d4-a6e9-02f4502ab60d',
              isFolder: false,
              name: 'SumMinMaxElementsSubarraysSizeK.java',
              code: 'import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class SumMinMaxElementsSubarraysSizeK {\n    public static int SumOfKsubArray(int[] arr, int k) {\n        int n = arr.length;\n        int ans = 0;\n        Deque<Integer> dq1 = new ArrayDeque<>();\n        Deque<Integer> dq2 = new ArrayDeque<>();\n        int i = 0;\n        for (int j = 0; j < n; j++) {\n            if (!dq1.isEmpty() && i > dq1.peekFirst()) dq1.pollFirst();\n            if (!dq2.isEmpty() && i > dq2.peekFirst()) dq2.pollFirst();\n            while (!dq1.isEmpty() && arr[j] < arr[dq1.peekLast()]) dq1.pollLast();\n            while (!dq2.isEmpty() && arr[j] > arr[dq2.peekLast()]) dq2.pollLast();\n            dq1.offerLast(j);\n            dq2.offerLast(j);\n            if (j - i + 1 == k) {\n                ans += arr[dq1.peekFirst()];\n                ans += arr[dq2.peekFirst()];\n                i++;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 5, -1, 7, -3, -1, -2};\n        int k = 3;\n        int ans = SumOfKsubArray(arr, k);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Queue'],
            },
            {
              id: 'e739bf06-51ea-4403-9a32-aef59fab5558',
              isFolder: false,
              name: 'Fibo.java',
              code: 'public class Fibo {\n    public static long fibo(int n, long[] temp) {\n        if (n <= 1) return n;\n        if (temp[n] != 0) return temp[n];\n        temp[n] = fibo(n-1, temp) + fibo(n-2, temp);\n        return temp[n];\n    }\n    // Optimised\n    public static long getFibo2(int n) {\n        long[] arr = new long[n + 1];\n        arr[1] = 1;\n        return fibo(n, arr);\n    }\n\n    // slow\n    public static long getFibo(int n) {\n        if (n <= 1) return n;\n        return getFibo(n-1) + getFibo(n-2);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '0e56bf05-9cd3-4830-b58c-462c5a6c6753',
              isFolder: false,
              name: 'LetterCombinationsOfPhoneNumber.java',
              code: 'import java.util.*;\npublic class LetterCombinationsOfPhoneNumber {\n    public List<String> letterCombinations(String digs) {\n        List<String> ans = new ArrayList<>();\n        if (digs.length() == 0) return ans;\n        StringBuilder sb = new StringBuilder();\n        String[] mappings = {"", "", "abc", "def", "ghi", "jkl","mno","pqrs","tuv","wxyz"};\n        solve(mappings, digs, ans, sb, 0);\n        return ans;\n    }\n    public static void solve(String[] mappings, String digs, List<String> ans, StringBuilder sb, int idx) {\n        // Base case\n        if (idx >= digs.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        // Get index\n        int index = digs.charAt(idx) - \'0\';\n        String val = mappings[index];\n        // Get all letters from mapping[index]\n        for (int i = 0; i < val.length(); i++) {\n            sb.append(val.charAt(i));\n            solve(mappings, digs, ans, sb, idx + 1);\n            sb.replace(sb.length() - 1, sb.length(), "");\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '214f1ddc-68c0-4781-8411-4fb16f080003',
              isFolder: false,
              name: 'MatrixFindPaths.java',
              code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MatrixFindPaths {\n    //    Given a n x m matrix, you are only allowed to move right and down direction\n//    find the of paths to reach the corner right of the matrix\n    public static void findPaths(int m, int n, int i, int j, List<String> paths, String path) {\n        if (i >= m || j >= n) return;\n        if (i == m - 1 && j == n - 1) {\n            paths.add(path);\n            return;\n        }\n        findPaths(m, n, i, j+1, paths, path+"R");\n        findPaths(m, n, i+1, j, paths, path + "D");\n    }\n\n    public static void main(String[] args) {\n        List<String> ans = new ArrayList<>();\n        findPaths(3, 2, 0, 0, ans, "");\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '210bdcfa-c365-4988-9ab6-1d5132d35401',
              isFolder: false,
              name: 'NKnightsProblem.java',
              code: "import java.util.Arrays;\n\npublic class NKnightsProblem {\n    static boolean isPossible(char[][] board, int row, int col) {\n//        Coordinates\n        int[][] coordinates = {\n                {col - 2, row - 1},\n                {col - 1, row - 2},\n                {col + 1, row - 2},\n                {col + 2, row - 1},\n                {col + 2, row + 1},\n                {col + 1, row + 2},\n                {col - 1, row + 2},\n                {col - 2, row + 1},\n        };\n        for (int[] coordinate : coordinates) {\n            int r = coordinate[1], c = coordinate[0];\n            if (r >= 0 && c >= 0 && r < board.length && c < board.length)\n                if (board[r][c] == 'K') return false;\n        }\n        return true;\n    }\n\n    static void solve(char[][] board, int col) {\n        if (col == board.length) {\n            for (char[] chars : board)\n                System.out.println(Arrays.toString(chars));\n            System.out.println();\n            return;\n        }\n        for (int row = 0; row < board.length; row++) {\n            if (isPossible(board, row, col)) {\n                board[row][col] = 'K';\n                solve(board, col + 1);\n                board[row][col] = '0';\n            }\n        }\n\n    }\n\n    public static void nKnights(int n, char[][] board) {\n        solve(board, 0);\n    }\n\n    public static void main(String[] args) {\n        int n = 1;\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], '0');\n        }\n        nKnights(n, board);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '21106419-48ba-42d6-8fcd-8de61afbcb26',
              isFolder: false,
              name: 'Permutations.java',
              code: 'import java.util.*;\npublic class Permutations {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int idx) {\n        // Base case\n        if (idx >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n\n        for (int i = idx; i < nums.length; i++) {\n            op.add(nums[i]);\n            swap(nums, idx, i);\n            solve(nums, ans, op, idx + 1);\n            swap(nums, idx, i);\n            op.remove(op.size() - 1);\n        }\n    }\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}',
              link: 'https://leetcode.com/problems/permutations/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'aa26330f-0eda-40ec-9cfd-6261dda83b34',
              isFolder: false,
              name: 'PermutationsOfString.java',
              code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsOfString {\n    public static void swap(StringBuilder s, int i, int j) {\n        char temp = s.charAt(i);\n        s.setCharAt(i, s.charAt(j));\n        s.setCharAt(j, temp);\n    }\n    public static void getPermutations(StringBuilder s, List<String> ans, int idx) {\n        if (idx == s.length()) {\n            ans.add(s.toString());\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            swap(s, idx, i);\n            getPermutations(s, ans, idx + 1);\n            swap(s, idx, i);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<String> ans = new ArrayList<>();\n        StringBuilder s = new StringBuilder("ABC");\n        getPermutations(s, ans, 0);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'c29113ae-d871-4da2-8c00-6e25a5b82919',
              isFolder: false,
              name: 'RopeCuttingProblem.java',
              code: 'public class RopeCuttingProblem {\n    public static int maxCuts(int n, int a, int b, int c, int count) {\n//        Base case\n        if (n == 0) return count;\n        if (n < 0) return -1;\n        int aCut = maxCuts(n - a, a, b, c, count + 1);\n        int bCut = maxCuts(n - b, a, b, c, count + 1);\n        int cCut = maxCuts(n - c, a, b, c, count + 1);\n        return Math.max(aCut, Math.max(bCut, cCut));\n    }\n\n    public static void main(String[] args) {\n        int ans = maxCuts(9,2,2,2, 0);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'cc1672a5-10f0-4156-a0b3-1b5af927b8f2',
              isFolder: false,
              name: 'SubsequencesOfString.java',
              code: 'import java.util.*;\n// This is the same question as power set but the solution is using recursion\npublic class SubsequencesOfString {\n    public static void getSubsequences(String str, ArrayList<String> ans, StringBuilder sb, int index) {\n        if (index >= str.length()) {\n            if (sb.length() != 0) {\n                ans.add(sb.toString());\n            }\n            return;\n        }\n//        Exclude\n        getSubsequences(str, ans, sb, index+1);\n//        Include\n        sb.append(str.charAt(index));\n        getSubsequences(str, ans, sb, index+1);\n        sb.replace(sb.length() - 1, sb.length(),"");\n    }\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getSubsequences(str, ans, sb, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences("abc");\n        System.out.println(ans);\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/subsequences-of-string_985087',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'a52ecda4-2151-4853-9394-cb58351362ca',
              isFolder: false,
              name: 'SubsetDuplicate.java',
              code: 'import java.util.*;\n\npublic class SubsetDuplicate {\n\n    public static void solve(int[] arr, List<List<Integer>> ans) {\n        ans.add(new ArrayList<>());\n        for (int i = 0; i < arr.length; i++) {\n            int n = ans.size();\n            int start = 0;\n            if (i > 0 && arr[i] == arr[i-1]) {\n                start = n/2;\n            }\n            for (int j = start; j < n; j++) {\n                List<Integer> list = new ArrayList<>(ans.get(j));\n                list.add(arr[i]);\n                ans.add(list);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2};\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, ans);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '46aef7cd-42dd-422a-9297-5ddfb6b6d2ee',
              isFolder: false,
              name: 'Subsets.java',
              code: 'import java.util.*;\n\npublic class Subsets {\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int index) {\n        if (index >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n//        Exclude\n        solve(nums, ans, op, index+1);\n//        Include\n        op.add(nums[index]);\n        solve(nums, ans, op, index+1);\n        op.remove(op.size() - 1);\n    }\n    public static List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1,2,3};\n        List<List<Integer>> ans =  subsets(nums);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '5a97aa52-4848-4136-af02-538356989931',
              isFolder: false,
              name: 'TowerOfHanoi.java',
              code: 'import java.util.*;\n\npublic class TowerOfHanoi {\n    public static void towerOfHanoi(int n, String src, String helper, String dest) {\n        if (n == 1) {\n            System.out.println("Transferring " + n + " from: " + src + " to: " + dest);\n            return;\n        }\n        towerOfHanoi(n-1, src,  dest, helper);\n        System.out.println("Transferring " + n + " from: " + src + " to: " + dest);\n        towerOfHanoi(n-1, helper, src, dest);\n    }\n\n    public static void solve(int n, int src, int helper, int dest, ArrayList<ArrayList<Integer>> ans) {\n        if (n == 1) {\n            ans.add(new ArrayList<>(Arrays.asList(src, dest)));\n            return;\n        }\n        solve(n - 1, src, helper, dest, ans);\n        ans.add(new ArrayList<>(Arrays.asList(src, dest)));\n        solve(n - 1, helper, src, dest, ans);\n    }\n    public static void main(String[] args) {\n        towerOfHanoi(3, "S", "h", "D");\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '2d578b75-9781-4d6f-986a-5f0b858b98bd',
              isFolder: false,
              name: 'CountOccuranceOfAnagrams.java',
              code: 'import java.util.HashMap;\n\npublic class CountOccuranceOfAnagrams {\n    public static int search(String pat, String txt) {\n        // code here\n        HashMap<Character, Integer> map = new HashMap<>();\n        int count = 0;\n        for (int i = 0; i < txt.length(); i++) {\n            char ch = txt.charAt(i);\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n        }\n        int uniqueCount = map.size();\n        int i = 0, j = 0, k = txt.length();\n        while (j < pat.length()) {\n            char ch = pat.charAt(j);\n            if (map.containsKey(ch)) {\n                int c = map.get(ch);\n                map.put(ch, c - 1);\n                if (c == 1) uniqueCount--;\n            }\n            if (j - i + 1 < k) j++;\n            else if (j - i + 1 == k) {\n                if (uniqueCount == 0) count++;\n                char ch2 = pat.charAt(i);\n                if (map.containsKey(ch2)) {\n                    int c2 = map.get(ch2);\n                    map.put(ch2, c2 + 1);\n                    if (c2 == 0) uniqueCount++;\n                }\n                i++;\n                j++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String pat = "aabaabaa";\n        String txt = "aaba";\n        System.out.println(search(pat, txt));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: '12a9e91b-a8b2-4d26-b0a7-2c72890e3d91',
              isFolder: false,
              name: 'AssignCookies.java',
              code: 'import java.util.Arrays;\n\npublic class AssignCookies {\n    public static int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int gLast = g.length - 1;\n        int sLast = s.length - 1;\n        int count = 0;\n        while (gLast >= 0 && sLast >= 0) {\n            if (g[gLast] <= s[sLast]) {\n                gLast--;\n                sLast--;\n                count++;\n            } else {\n                gLast--;\n            }\n        }\n        return count;\n    }\n}',
              link: 'https://leetcode.com/problems/assign-cookies/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '7289d1cb-e7df-4598-8b65-724ab6a230af',
              isFolder: false,
              name: 'CanMakeAPFromSequence.java',
              code: 'public class CanMakeAPFromSequence {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    public static boolean canMakeArithmeticProgression(int[] arr) {\n//        Brute force\n//         Arrays.sort(arr);\n//         int diff = arr[1] - arr[0];\n//         for (int i = 1; i < arr.length; i++) {\n//             if (arr[i] - arr[i-1] != diff) return false;\n//         }\n//         return true;\n\n//        Optimal solution\n        int min = Integer.MAX_VALUE, max =Integer.MIN_VALUE;\n        for (int num: arr){\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int n = arr.length;\n//        If difference is not perfectly divisible then return false\n        if ((max - min) % (n - 1) != 0) return false;\n//        To get the difference between any 2 element in a AP\n        int diff = (max - min) / (n - 1);\n        int i = 0;\n        while (i < n) {\n            if (arr[i] == min + i*diff) i++;\n            else if ((arr[i] - min)%diff != 0) return false;\n            else {\n                int j = (arr[i] - min)/diff;\n                if (arr[i] == arr[j]) return false;\n                swap(arr, i, j);\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13, 12, -12, 9, 9, 16, 7, -10, -20, 0, 18, -1, -20, -10, -8, 15, 15, 16, 2, 15};\n        System.out.println(canMakeArithmeticProgression(arr));\n    }\n}',
              link: 'https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '494b781c-82bb-4fae-ae0c-d1f3477d40fb',
              isFolder: false,
              name: 'InsertionSortList.java',
              code: 'public class InsertionSortList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) {\n            this.val = val;\n        }\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public static ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null)  return head;\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = head;\n        ListNode curr = head.next;\n        while (curr != null) {\n            if (curr.val >= prev.val) {\n                prev = curr;\n                curr = curr.next;\n                continue;\n            }\n            ListNode temp = dummy;\n            while (curr.val > temp.next.val) {\n                temp = temp.next;\n            }\n            prev.next = curr.next;\n            curr.next = temp.next;\n            temp.next = curr;\n            curr = prev.next;\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = insertionSortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + " => ");\n            temp = temp.next;\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/insertion-sort-list',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '999fe3f1-1551-47e6-b8f8-2eeb3cada605',
              isFolder: false,
              name: 'LargestNumber.java',
              code: 'import java.util.*;\npublic class LargestNumber {\n    public String largestNumber(int[] nums) {\n        Comparator<String> comp = (i, j) -> (j+i).compareTo(i+j);\n        List<String> list = new ArrayList<>();\n        for (int num : nums) {\n            list.add(String.valueOf(num));\n        }\n        list.sort(comp);\n        StringBuilder sb = new StringBuilder();\n        for (String l : list) {\n            sb.append(l);\n        }\n        return String.valueOf(Integer.parseInt(String.valueOf(sb)));\n    }\n\n}',
              link: 'https://leetcode.com/problems/largest-number/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '719ba616-a55a-42db-837b-99610568d429',
              isFolder: false,
              name: 'MaxProductOfTwoElementsInAnArray.java',
              code: 'public class MaxProductOfTwoElementsInAnArray {\n    public int maxProduct(int[] nums) {\n        int f = 0, s = 0;\n        for (int num : nums) {\n            if (num > f) {\n                s = f;\n                f = num;\n            } else if (num > s) {\n                s = num;\n            }\n        }\n        return (f-1)*(s-1);\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'c919e893-c2df-4a68-855a-5c21a431ebbb',
              isFolder: false,
              name: 'RankTransformOfAnArray.java',
              code: 'import java.util.*;\n\npublic class RankTransformOfAnArray {\n    public int[] arrayRankTransform(int[] arr) {\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        int[] h = arr.clone();\n        Arrays.sort(h);\n        int rank = 1;\n        for (int i = 0; i < h.length; i++) {\n            if (!hm.containsKey(h[i])) {\n                hm.put(h[i], rank++);\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            h[i] = hm.get(arr[i]);\n        }\n        return h;\n    }\n}',
              link: 'https://leetcode.com/problems/rank-transform-of-an-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '499e635e-a444-44ea-b44f-51b3394150d7',
              isFolder: false,
              name: 'RelativeSortArray.java',
              code: 'import java.util.Arrays;\n\npublic class RelativeSortArray {\n    public static int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] count = new int[1001];\n        int totalCount = arr1.length;\n        for (int i : arr1) {\n            count[i]++;\n        }\n        int j = 0;\n        for (int k : arr2) {\n            while (count[k] != 0) {\n                arr1[j++] = k;\n                count[k]--;\n                totalCount--;\n            }\n        }\n        if (totalCount != 0) {\n            for (int i = 0; i < 1001; i++) {\n                while (count[i] != 0) {\n                    arr1[j++] = i;\n                    count[i]--;\n                }\n            }\n        }\n        return arr1;\n    }\n    public static void main(String[] args) {\n//        Input:\n        int[] arr1 = {2,3,1,3,2,4,6,7,9,2,19};\n        int[] arr2 = {2,1,4,3,9,6};\n        int[] ans = relativeSortArray(arr1, arr2);\n        System.out.println(Arrays.toString(ans));\n//        Output: [2,2,2,1,4,3,3,9,6,7,19]\n    }\n}',
              link: 'https://leetcode.com/problems/relative-sort-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'a7aca89b-ad27-4966-8c80-9a5ee4def494',
              isFolder: false,
              name: 'SortArrayByIncreasingFrequency.java',
              code: 'import java.util.*;\npublic class SortArrayByIncreasingFrequency {\n    public static int[] frequencySort(int[] nums) {\n        // Count the frequency of each number\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        // Sort the unique numbers by frequency and then by value\n        List<Integer> numList = new ArrayList<>(hm.keySet());\n        numList.sort((a, b) -> {\n            int freqCompare = Integer.compare(hm.get(a), hm.get(b));\n            return (freqCompare != 0) ? freqCompare : Integer.compare(b, a);\n        });\n        // Populate the sorted result array -> O(n) operation\n        int index = 0;\n        for (int num : numList) {\n            int freq = hm.get(num);\n            for (int i = 0; i < freq; i++) {\n                nums[index++] = num;\n            }\n        }\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-1,1,-6,4,5,-6,1,4,1};\n        int[] ans = frequencySort(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/sort-array-by-increasing-frequency/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '3cb86f8e-c25c-4db9-a11a-389c6213d066',
              isFolder: false,
              name: 'SortIntegersByNumberOf1Bits.java',
              code: 'import java.util.*;\n\npublic class SortIntegersByNumberOf1Bits {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int compare(int a, int b) {\n        int aBits = Integer.bitCount(a);\n        int bBits = Integer.bitCount(b);\n        if (aBits != bBits) return aBits - bBits;\n        return a - b;\n    }\n\n    public static void mergeSort(int[] arr, int low, int high) {\n        if (low == high) return;\n        int mid = low + (high - low)/2;\n        mergeSort(arr, low, mid);\n        mergeSort(arr, mid+1, high);\n        merge(arr, low, mid, high);\n    }\n\n    public static void merge(int[] arr, int low, int mid, int high) {\n        int[] temp = new int[high - low + 1];\n        int i = 0, left = low, right = mid+1;\n        while (left <= mid && right <= high) {\n            if (compare(arr[left], arr[right]) > 0)\n                temp[i++] = arr[right++];\n            else\n                temp[i++] = arr[left++];\n        }\n        while (left <= mid) temp[i++] = arr[left++];\n        while (right <= high) temp[i++] = arr[right++];\n\n        for (int j = 0; j < temp.length; j++)\n            arr[j+low] = temp[j];\n    }\n\n    public static int[] sortByBits(int[] arr) {\n//        Brute force solution\n//        int n = arr.length - 1;\n//        for (int i = 0; i < n; i++) {\n//            boolean swapped = false;\n//            for (int j = 0; j < n - i; j++) {\n//                if (compare(arr[j], arr[j + 1]) > 0) {\n//                    swap(arr, j, j + 1);\n//                    swapped = true;\n//                }\n//            }\n//            if (!swapped) break;\n//        }\n//        return arr;\n\n//        Better solution\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] += Integer.bitCount(arr[i]) * 10001;\n//        }\n//        Arrays.sort(arr);\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] = arr[i] % 10001;\n//        }\n//        return arr;\n\n//        Optimised solution\n        mergeSort(arr, 0, arr.length - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n//        int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n//        int[] arr = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\n        int[] arr = {2, 3, 5, 7, 11, 13, 17, 19};\n        int[] ans = sortByBits(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '7da9da6b-68ea-43cc-bcb8-de48ba0596d3',
              isFolder: false,
              name: 'SortList.java',
              code: 'class SortList {\n    static class ListNode {\n            int val;\n            ListNode next;\n            ListNode() {}\n            ListNode(int val) {\n                this.val = val;\n            }\n            ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode list2Head = slow.next;\n        slow.next = null;\n        head = mergeSort(head);\n        list2Head = mergeSort(list2Head);\n        return merge(head, list2Head);\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode();\n        ListNode head = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        }\n        if (right != null) {\n            temp.next = right;\n        }\n        return head.next;\n    }\n    public static ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = sortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + " => ");\n            temp = temp.next;\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/sort-list/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '1505c79e-87d1-4173-9be0-6421b74b3c3b',
              isFolder: false,
              name: 'SplArrayWithXElementsGTEToX.java',
              code: 'public class SplArrayWithXElementsGTEToX {\n    public int specialArray(int[] nums) {\n        int start = 1, end = nums.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i: nums) {\n                if (i >= mid) count++;\n            }\n            if (count == mid) return mid;\n            if (count > mid)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '0deb326e-e230-4992-8947-e5a79d6b953d',
              isFolder: false,
              name: 'SquaresOfASortedArray.java',
              code: 'public class SquaresOfASortedArray {\n    public int[] sortedSquares(int[] nums) {\n//        Brute force\n//        int[] ans = new int[nums.length];\n//        for (int i=0; i < nums.length; i++) {\n//            ans[i] = nums[i]*nums[i];\n//        }\n//        Arrays.sort(ans);\n//        return ans;\n//        Best solution\n        int n = nums.length - 1;\n        int[] ans = new int[n+1];\n        int start = 0, end = n;\n        while(start <= end) {\n            if (Math.abs(nums[start]) >= Math.abs(nums[end])) {\n                ans[n--] = nums[start]*nums[start];\n                start++;\n            } else {\n                ans[n--] = nums[end]*nums[end];\n                end--;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n\n    }\n}',
              link: 'https://leetcode.com/problems/squares-of-a-sorted-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'fecc7b11-1541-4bf2-bd03-6ef33e50d07b',
              isFolder: false,
              name: 'ThirdMaximumNumber.java',
              code: "// Approach: Ranking technique with conditions to handle the same values as first and second;\n// Use Long instead of int as min and max value is Integer's min and max value\n\npublic class ThirdMaximumNumber {\n    public static int getThirdMaxNumber(int[] arr) {\n        long f = Long.MIN_VALUE;\n        long s = Long.MIN_VALUE;\n        long t = Long.MIN_VALUE;\n        for (int num : arr) {\n            if (num > f) {\n                t = s;\n                s = f;\n                f = num;\n            } else if (num > s && num != f) {\n                t = s;\n                s = num;\n            } else if (num > t && num != s && num != f) {\n                t = num;\n            }\n        }\n        if (t == Long.MIN_VALUE) {\n            return (int)f;\n        }\n        return (int)t;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1,2,2,5,3,5};\n        int ans = getThirdMaxNumber(arr);\n        System.out.println(ans);\n    }\n}",
              link: 'https://leetcode.com/problems/third-maximum-number/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '5937b75b-3500-45cb-b0e4-dc2177cda17f',
              isFolder: false,
              name: 'ThreeSumClosest.java',
              code: 'import java.util.*;\npublic class ThreeSumClosest {\n    public static int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int n = nums.length;\n\n        int first3Sum = nums[0]+nums[1]+nums[2];\n        int last3Sum = nums[n-1]+nums[n-2]+nums[n-3];\n        if (first3Sum >= target) return first3Sum;\n        if (last3Sum <= target) return last3Sum;\n\n        int diff = Integer.MAX_VALUE;\n        int closest = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            int j = i+1;\n            int k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) return sum;\n\n                int abs = Math.abs(target - sum);\n                if (diff > abs) {\n                    closest = sum;\n                    diff = abs;\n                }\n                if (sum > target) k--;\n                else j++;\n            }\n        }\n        return closest;\n    }\n}',
              link: 'https://leetcode.com/problems/3sum-closest/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '98b329f0-5fe2-418b-b072-2f06104bd775',
              isFolder: false,
              name: 'MaximumOccuringCharacter.java',
              code: "public class MaximumOccuringCharacter {\n//    Use a hashmap or counts array to store the count of all the elements\n//    ans iterate over it to get the max count;\n    public static char getMaxOccuringChar(String line)\n    {\n        // Your code here\n        int[] count = new int[26];\n        for (int i = 0; i < line.length(); i++) {\n            count[(int) line.charAt(i) - 'a']++;\n        }\n        int max = count[0];\n        int idx = 0;\n        for (int j = 0; j < count.length; j++) {\n            if (count[j] > max) {\n                idx = j;\n                max = count[j];\n            }\n        }\n        return (char) (idx + 'a');\n    }\n\n    public static void main(String[] args) {\n        String s = \"testsample\";\n        char ans = getMaxOccuringChar(s);\n        System.out.println(ans);\n    }\n}",
              link: 'https://practice.geeksforgeeks.org/problems/maximum-occuring-character-1587115620/1',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '86e0aee4-96ae-464b-a3d9-238d0768b0f3',
              isFolder: false,
              name: 'PermutationInString.java',
              code: 'public class PermutationInString {\n    public static boolean checkCount(int[] arr1, int[] arr2) {\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] != arr2[i]) return false;\n        }\n        return true;\n    }\n\n    public static boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n        int[] count1 = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count1[s1.charAt(i) - 97]++;\n        }\n        int[] count2 = new int[26];\n        int windowSize = s1.length();\n        int i = 0;\n        while (i < windowSize) {\n            count2[s2.charAt(i) - 97]++;\n            i++;\n        }\n        if (checkCount(count1, count2)) return true;\n        while (i < s2.length()) {\n            // Add\n            count2[s2.charAt(i) -97]++;\n            // Minus\n            count2[s2.charAt(i-windowSize) -97]--;\n\n            i++;\n            if (checkCount(count1, count2)) return true;\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        String s1 = "ab";\n        String s2 = "eidboaoo";\n        boolean ans = checkInclusion(s1, s2);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/permutation-in-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'd64f5db7-c74e-46de-9a6b-4895b4d24a73',
              isFolder: false,
              name: 'PowerSet.java',
              code: 'import java.util.*;\npublic class PowerSet {\n    public List<List<Integer>> powerSet(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < Math.pow(2, nums.length); i++) {\n            List<Integer> list = new ArrayList<>();\n            int idx = 0;\n            while(idx < nums.length) {\n                if (((i >> idx)&1) == 1) {\n                    list.add(nums[idx]);\n                }\n                idx++;\n            }\n            ans.add(list);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'd1b24aa7-9a4a-47bf-8781-79593d966007',
              isFolder: false,
              name: 'RemoveAllAdjacentDuplicates.java',
              code: 'public class RemoveAllAdjacentDuplicates {\n    public static String removeDuplicates(String s) {\n//        Brute force solution\n//        Stack<Character> stack = new Stack<>();\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (!stack.isEmpty() && stack.peek() == ch)\n//                stack.pop();\n//            else\n//                stack.push(ch);\n//        }\n//        while (!stack.isEmpty()) sb.append(stack.pop());\n//        return sb.reverse().toString();\n\n//        Better solution using stack\n        char[] stack = new char[s.length()];\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            char ch = s.charAt(j);\n            if (i > 0 && stack[i-1] == ch)\n                i = Math.max(0, i - 1);\n            else\n                stack[i++] = ch;\n        }\n        return new String(stack, 0, i);\n    }\n    public static void main(String[] args) {\n        String s = "abbaca";\n        String ans = removeDuplicates(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'b62290f5-51e5-4fe2-aa38-e1a681e499a4',
              isFolder: false,
              name: 'RemoveAllOccurrencesOfSubstring.java',
              code: 'public class RemoveAllOccurrencesOfSubstring {\n    public static String removeOccurrences(String s, String part) {\n        StringBuilder sb = new StringBuilder(s);\n        while (sb.length()!=0 && sb.indexOf(part)>=0) {\n            int idx = sb.indexOf(part);\n            sb.delete(idx, idx+part.length());\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n        String s = "daabcbaabcbc";\n        String part = "abc";\n        String ans = removeOccurrences(s, part);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/remove-all-occurrences-of-a-substring/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '62c6a9bc-c879-429a-9994-102327cf5fc1',
              isFolder: false,
              name: 'ReplaceSpaces.java',
              code: 'public class ReplaceSpaces {\n    public static StringBuilder replaceSpaces(StringBuilder str) {\n        // Write your code here.\n        // return new StringBuilder(str.toString().replace(" ", "@40"));\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == \' \')\n                sb.append("@40");\n            else\n                sb.append(str.charAt(i));\n        }\n        return sb;\n    }\n\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder("Coding Ninjas Is A Coding Platform");\n        StringBuilder ans = replaceSpaces(str);\n        System.out.println(ans);\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/replace-spaces_1172172',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '2466e8b0-4df8-4323-bc02-ac323881f020',
              isFolder: false,
              name: 'ReverseWords1.java',
              code: 'public class ReverseWords1 {\n    public static String reverseWords(String s) {\n//        Brute force solution\n//        String[] sArr = s.split(" ");\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = sArr.length - 1; i >= 0; i--) {\n//            if (sArr[i].trim().length() != 0) {\n//                sb.append(sArr[i]).append(" ");\n//            }\n//        }\n//        return sb.toString().trim();\n\n//        Best: 2 pointer approach\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == \' \') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != \' \') i--;\n            if (i == -1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(\' \');\n        }\n        return sb.toString().trim();\n    }\n    public static void main(String[] args) {\n        String s = "a good   example";\n//        The string can have more than 1 space anywhere in the array\n        String ans = reverseWords(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'c9396f2d-de9c-4fe7-a8b3-cbce7dcd164a',
              isFolder: false,
              name: 'ReverseWordsInAString2.java',
              code: "import java.util.Arrays;\n\npublic class ReverseWordsInAString2 {\n//    Input: s = \"the sky is blue\"\n//    Output: \"blue is sky the\"\n    public static void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n\n    public static char[] reverseWords(char[] arr) {\n//        int start = 0;\n//        int end = arr.length;\n//        reverse(arr, start, end - 1);\n//        for (int i = 0; i < end; i++) {\n//            if (arr[i] == ' ') {\n//                reverse(arr, start, i-1);\n//                start = i+1;\n//            } else if (i == end - 1) {\n//                reverse(arr, start, i);\n//            }\n//        }\n//        return arr;\n        int start = 0;\n        int end = arr.length - 1;\n        reverse(arr, start, end);\n        for (int i = 0; i <= end; i++) {\n            if (arr[i] == ' ') {\n                reverse(arr, start, i - 1);\n                start = i + 1;\n            }\n        }\n        reverse(arr, start, end);\n        return arr;\n    }\n    public static void main(String[] args) {\n        char[] arr = {'t', 'h', 'e', ' ', 's', 'k', 'y', ' ', 'i', 's', ' ', 'b', 'l', 'u', 'e'};\n        char[] ans = reverseWords(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              link: 'https://www.lintcode.com/problem/927/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '30a50b39-38f7-49d1-b6bc-dc129fe90052',
              isFolder: false,
              name: 'StringCompression.java',
              code: "public class StringCompression {\n    public static int compress(char[] chars) {\n        // Best solution O(n)\n        int n = chars.length;\n        if (n == 1)\n            return 1;\n        int i = 0, j = 0, slow = 0;\n        while (j < n) {\n            while (j < n && chars[i] == chars[j])\n                j++;\n            chars[slow++] = chars[i];\n            if (j - i > 1) {\n                String diff = j - i + \"\";\n                for (int k = 0; k < diff.length(); k++) {\n                    chars[slow++] = diff.charAt(k);\n                }\n            }\n            i = j;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        char[] chars = { 'a', 'a', 'b', 'b', 'c', 'c', 'c' };\n        int ans = compress(chars);\n        System.out.println(ans);\n    }\n}",
              link: 'https://leetcode.com/problems/string-compression/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'a2409f74-7aa1-478b-867f-2dd251977274',
              isFolder: false,
              name: 'ValidPalindrome.java',
              code: '//    The given string is polluted with characters other than numbers and alphabets.\n//    Also ignore the case while solving for the answer\n\npublic class ValidPalindrome {\n    public static boolean isPalindrome(String s) {\n//        Brute force: Remove every character that is not valid using replaceAll method\n//        This will take O(n) time to replace and O(n) time to make it lowercase and then\n//        another O(n) to iterate the array\n//        Total TC = O(3n)\n//        s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Best approach: Two pointer approach\n//        Total TC = O(2n) => (lowercase and iterating)\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n\n    }\n    public static void main(String[] args) {\n        String s = "A man, a plan, a canal: Panama";\n        boolean ans = isPalindrome(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/valid-palindrome/',
              notes: '',
              tags: ['Strings'],
            },
          ],
        },
        {
          id: 'd3bfd466-eb61-404e-82f1-710c0795661f',
          isFolder: true,
          name: 'Neetcode 150',
          content: [
            {
              id: '8ff3f677-fedd-4de0-be40-1103cec3c645',
              isFolder: false,
              name: 'ClimbingStairs.java',
              code: 'class ClimbingStairs {\n    public int solve(int n, int[] arr) {\n        if (n == 0 || n == 1)\n            return 1;\n        if (arr[n] != 0)\n            return arr[n];\n        arr[n] = solve(n - 1, arr) + solve(n - 2, arr);\n        return arr[n];\n    }\n\n    public int climbStairs(int n) {\n        // Memoization\n        int[] dp = new int[n + 1];\n        return solve(n, dp);\n\n        // Top down\n        // int[] dp = new int[n+1];\n        // dp[0] = dp[1] = 1;\n        // for (int i = 2; i <= n; i++) {\n        // dp[i] = dp[i-1] + dp[i-2];\n        // }\n        // return dp[n];\n\n        // Space optimized\n        // int prev1 = 1, prev2 = 1;\n        // for (int i = 2; i <= n; i++) {\n        // int temp = prev1 + prev2;\n        // prev2 = prev1;\n        // prev1 = temp;\n        // }\n        // return prev1;\n    }\n}',
              link: 'https://leetcode.com/problems/climbing-stairs/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: 'bb7e4f5d-65b3-4002-a96c-7b4cfaa9f0a4',
              isFolder: false,
              name: 'CoinChange.java',
              code: 'class CoinChange {\n    public int solve(int[] coins, int amount, int idx, int[][] dp) {\n        if (amount == 0) return 0;\n        if (idx == 0) {\n            if (amount % coins[idx] == 0) return amount / coins[idx];\n            return 10001;\n        }\n        if (dp[idx][amount] != -1) return dp[idx][amount];\n        int notPick = solve(coins, amount, idx - 1, dp), pick = 10001;\n        if (coins[idx] <= amount) {\n            pick = 1 + solve(coins, amount - coins[idx], idx, dp);\n        }\n        return dp[idx][amount] = Math.min(pick, notPick);\n    }\n\n    public int coinChange(int[] coins, int amount) {\n        // int n = coins.length;\n        // int[][] dp = new int[n][amount + 1];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // int ans = solve(coins, amount, n - 1, dp);\n        // return ans > 10000 ? -1 : ans;\n        int n = coins.length;\n        int[][] dp = new int[n][amount + 1];\n        for (int i = 0; i <= amount; i++) {\n            dp[0][i] = (i % coins[0]) == 0 ? i / coins[0] : 10001;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j <= amount; j++) {\n                int notPick = dp[i - 1][j], pick = 10001;\n                if (coins[i] <= j) {\n                    pick = 1 + dp[i][j - coins[i]];\n                }\n                dp[i][j] = Math.min(pick, notPick);\n            }\n        }\n        return dp[n - 1][amount] > 10000 ? -1 : dp[n - 1][amount];\n    }\n}',
              link: 'https://leetcode.com/problems/coin-change/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: 'de4fe907-d6a4-4899-aa56-5b5537938474',
              isFolder: false,
              name: 'DecodeWays.java',
              code: "import java.util.*;\n\nclass DecodeWays {\n    public int solve(String s, int i, int[] dp) {\n        if (i > s.length()) return 0;\n        if (i == s.length()) return 1;\n        if (dp[i] != -1) return dp[i];\n        char ch = s.charAt(i);\n        if (ch == '0') return 0;\n        int ans = solve(s, i+1, dp);\n        if (i+1 < s.length() && (ch == '1' || (ch == '2' && s.charAt(i+1) <= '6'))) {\n            ans += solve(s, i+2, dp);\n        }\n        return dp[i] = ans;\n    }\n    public int numDecodings(String s) {\n        int n = s.length();\n        int[] dp = new int[n];\n        Arrays.fill(dp, -1);\n        return solve(s, 0, dp);\n    }\n}",
              link: 'https://leetcode.com/problems/decode-ways/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: '10c6c616-7110-443e-9d45-61e19a94bd96',
              isFolder: false,
              name: 'HouseRobber.java',
              code: 'class HouseRobber {\n    public int solve(int[] nums, int idx, int[] dp) {\n        if (idx >= nums.length)\n            return 0;\n        if (idx == nums.length - 1)\n            return nums[idx];\n        if (dp[idx] != -1)\n            return dp[idx];\n        int pick = nums[idx] + solve(nums, idx + 2, dp);\n        int notPick = solve(nums, idx + 1, dp);\n        return dp[idx] = Math.max(pick, notPick);\n    }\n\n    public int rob(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        // Arrays.fill(dp, -1);\n        // return solve(nums, 0, dp);\n        dp[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            int pick = nums[i];\n            if (i < n - 2) {\n                pick += dp[i + 2];\n            }\n            int notPick = dp[i + 1];\n            dp[i] = Math.max(pick, notPick);\n        }\n        return dp[0];\n    }\n}',
              link: 'https://leetcode.com/problems/house-robber/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: 'b7f97d24-7d28-4585-9c51-890e0add6ea8',
              isFolder: false,
              name: 'HouseRobber2.java',
              code: 'import java.util.*;\n\nclass HouseRobber2 {\n    public int solve(int[] nums, int idx, int[] dp) {\n        if (idx >= nums.length)\n            return 0;\n        if (dp[idx] != -1)\n            return dp[idx];\n        int pick = nums[idx] + solve(nums, idx + 2, dp);\n        int notPick = solve(nums, idx + 1, dp);\n        return dp[idx] = Math.max(pick, notPick);\n    }\n\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1)\n            return nums[0];\n        int[] dp = new int[n];\n        Arrays.fill(dp, -1);\n        int save = nums[n - 1];\n        nums[n - 1] = -10000;\n        int max1 = solve(nums, 0, dp);\n        Arrays.fill(dp, -1);\n        nums[n - 1] = save;\n        nums[0] = -10000;\n        int max2 = solve(nums, 0, dp);\n        return Math.max(max1, max2);\n    }\n}',
              link: 'https://leetcode.com/problems/house-robber-ii/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: 'bb89b59f-0ea3-4791-b8a2-8c45c21b168f',
              isFolder: false,
              name: 'LongestIncreasingSubsequence.java',
              code: 'import java.util.*;\n\nclass LongestIncreasingSubsequence {\n    public static int bs(List<Integer> arr, int target) {\n\t\tint start = 0, end = arr.size() - 1;\n\t\tint ans = 0;\n\t\twhile (start <= end) {\n\t\t\tint mid = start + (end - start) / 2;\n\t\t\tif (target <= arr.get(mid)) {\n\t\t\t\tans = mid;\n\t\t\t\tend = mid - 1;\n\t\t\t} else {\n\t\t\t\tstart = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static int longestIncreasingSubsequence(int nums[]) {\n\t\t// Your code goes here\n\t\tint n = nums.length;\n\t\tList<Integer> arr = new ArrayList<>();\n\t\tarr.add(nums[0]);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (arr.get(arr.size() - 1) < nums[i]) {\n\t\t\t\tarr.add(nums[i]);\n\t\t\t} else {\n\t\t\t\tint idx = bs(arr, nums[i]);\n\t\t\t\tarr.set(idx, nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn arr.size();\n\t}\n    public int solve(int[] nums, int idx, int lastIdx, int[][] dp) {\n        if (idx == nums.length) return 0;\n        if (dp[idx][lastIdx+1] != -1) return dp[idx][lastIdx+1];\n        int notPick = solve(nums, idx + 1, lastIdx, dp), pick = 0;\n        if (lastIdx == -1 || nums[idx] > nums[lastIdx]) {\n            pick = 1 + solve(nums, idx + 1, idx, dp);\n        }\n        return dp[idx][lastIdx+1] = Math.max(pick, notPick);\n    }\n\n    public int lengthOfLIS(int[] nums) {\n        // int n = nums.length;\n        // int[][] dp = new int[n+1][n+1];\n\n        // Memoization\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(nums, 0, -1, dp);\n\n        // Tabulation\n        // for (int idx = n-1; idx >= 0; idx--) {\n        //     for (int lastIdx = idx-1; lastIdx >= -1; lastIdx--) {\n        //         int notPick = dp[idx+1][lastIdx+1], pick = 0;\n        //         if (lastIdx == -1 || nums[idx] > nums[lastIdx]) {\n        //             pick = 1 + dp[idx+1][idx+1];\n        //         }\n        //         dp[idx][lastIdx+1] = Math.max(pick, notPick);\n        //     }\n        // }\n        // return dp[0][0];\n\n        // int[] dp = new int[n];\n        // Arrays.fill(dp, 1);\n        // int max = 1;\n        // for (int i = 0; i < n; i++) {\n        //     for (int prev = 0; prev < i; prev++) {\n        //         if (nums[prev] < nums[i]) {\n        //             dp[i] = Math.max(dp[prev]+1, dp[i]);\n        //         }\n        //     }\n        //     max = Math.max(max, dp[i]);\n        // }\n        // return max;\n        return longestIncreasingSubsequence(nums);\n    }\n}',
              link: 'https://leetcode.com/problems/longest-increasing-subsequence/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: '676435bc-a01f-42a8-82ec-1622ee2dff90',
              isFolder: false,
              name: 'LongestPalindromicSubstring.java',
              code: 'class LongestPalindromicSubstring {\n    public int maxPalindromeLen(String s, int start, int end) {\n        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {\n            start--;\n            end++;\n        }\n        return end - start - 1;\n    }\n    public String longestPalindrome(String s) {\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = maxPalindromeLen(s, i, i);\n            int len2 = maxPalindromeLen(s, i, i+1);\n            int len = Math.max(len1, len2);\n            if (end - start + 1 < len) {\n                start = i - (len-1) / 2;\n                end = i + len/2;\n            }\n        }\n        return s.substring(start, end+1);\n    }\n}',
              link: 'https://leetcode.com/problems/longest-palindromic-substring/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: '2c531973-c9b2-4d19-8511-f1cc046f5798',
              isFolder: false,
              name: 'MaximumProductSubarray.java',
              code: 'class MaximumProductSubarray {\n    public int maxProduct(int[] nums) {\n        int maxProd = nums[0];\n        int lProd = 1;\n        int rProd = 1;\n        for (int i = 0; i < nums.length; i++) {\n            lProd *= nums[i];\n            rProd *= nums[nums.length - 1 - i];\n            maxProd = Math.max(maxProd, Math.max(lProd, rProd));\n            if (rProd == 0) {\n                rProd = 1;\n            }\n            if (lProd == 0) {\n                lProd = 1;\n            }\n        }\n        return maxProd;\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-product-subarray/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: '438d51a3-6488-4543-bee9-884718b489b5',
              isFolder: false,
              name: 'MinCostClimbingStairs.java',
              code: 'import java.util.*;\n\nclass MinCostClimbingStairs {\n    public int solve(int[] cost, int n, int[] dp) {\n        if (n == 0 || n == 1) {\n            return 0;\n        }\n        if (dp[n] != -1)\n            return dp[n];\n        int a = solve(cost, n - 1, dp) + cost[n - 1];\n        int b = solve(cost, n - 2, dp) + cost[n - 2];\n        return dp[n] = Math.min(a, b);\n    }\n\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        return solve(cost, n, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/min-cost-climbing-stairs/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: '0fa29af9-e688-46cd-9c51-53169aa34c30',
              isFolder: false,
              name: 'PalindromicSubstrings.java',
              code: 'class PalindromicSubstrings {\n    public int countPalindromes(String s, int start, int end) {\n        int count = 0;\n        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {\n            count++;\n            start--;\n            end++;\n        }\n        return count;\n    }\n    public int countSubstrings(String s) {\n        int ans = 0;\n        for (int i = 0; i < s.length(); i++) {\n            ans += countPalindromes(s, i, i);\n            ans += countPalindromes(s, i, i+1);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/palindromic-substrings/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: 'f78b0c7a-3ca7-44e9-a4f9-a53ea6cc31c2',
              isFolder: false,
              name: 'PartitionEqualSubsetSum.java',
              code: 'import java.util.*;\n\nclass PartitionEqualSubsetSum {\n    public static boolean solve(int arr[], int n, int k, int i, int[][] dp) {\n        if (k == 0)\n            return true;\n        if (i == n || k < 0)\n            return false;\n        if (dp[i][k] != -1)\n            return dp[i][k] == 1;\n        boolean pick = false, notpick = solve(arr, n, k, i + 1, dp);\n        if (arr[i] <= k) {\n            pick = solve(arr, n, k - arr[i], i + 1, dp);\n        }\n        dp[i][k] = (pick || notpick) ? 1 : 0;\n        return pick || notpick;\n    }\n\n    public boolean canPartition(int[] nums) {\n        int n = nums.length, sum = 0;\n        if (n <= 1)\n            return false;\n        for (int i : nums) {\n            sum += i;\n        }\n        if ((sum & 1) == 1)\n            return false;\n        sum = sum / 2;\n        int[][] dp = new int[n][sum + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(nums, n, sum, 0, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/partition-equal-subset-sum/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: '9de8a6c6-d985-4c0c-84c7-d0efd1d575e5',
              isFolder: false,
              name: 'WordBreak.java',
              code: 'import java.util.*;\n\nclass WordBreak {\n    static boolean check(String s, String b) {\n        return s.length() >= b.length() && s.startsWith(b);\n    }\n\n    static boolean solve(String s, List<String> words, int idx, int[] dp) {\n        if (idx == s.length()) return true;\n        if (dp[idx] != 0) return dp[idx] > 0;\n        boolean ans = false;\n        for (String word : words) {\n            if (!check(s.substring(idx), word)) continue;\n            ans = solve(s, words, idx + word.length(), dp);\n            if (ans) return true;\n        }\n        dp[idx] = ans ? 1 : -1;\n        return false;\n    }\n    public boolean wordBreak(String s, List<String> words) {\n        int[] dp = new int[s.length() + 1];\n        return solve(s, words, 0, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/word-break/',
              notes: '',
              tags: ['1D DP'],
            },
            {
              id: 'bfc30097-580d-41c7-a0d9-c92396729096',
              isFolder: false,
              name: 'BestTimetoBuyAndSellStockWithCooldown.java',
              code: 'import java.util.*;\n\nclass BestTimetoBuyAndSellStockWithCooldown {\n    public int solve(int[] prices, int i, int last, int[][] dp) {\n        if (i >= prices.length) return 0;\n        if (dp[i][last] != -1) return dp[i][last];\n        int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        if (last == 0) {\n            buy = -prices[i] + solve(prices, i+1, 1, dp);\n            notBuy = solve(prices, i+1, 0, dp);\n        } else {\n            sell = prices[i] + solve(prices, i+2, 0, dp);\n            notSell = solve(prices, i+1, 1, dp);\n        }\n        return dp[i][last] = Math.max(buy + sell, notBuy + notSell);\n    }\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n+1][2];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(prices, 0, 0, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '2931df3f-8414-4944-ab23-3fe6b253be26',
              isFolder: false,
              name: 'BurstBalloons.java',
              code: 'import java.util.*;\n\nclass BurstBalloons {\n    public int solve(int[] nums, int l, int r, int[][] dp) {\n        if (l > r)\n            return 0;\n        if (dp[l][r] != -1)\n            return dp[l][r];\n        int maxi = 0;\n        for (int k = l; k <= r; k++) {\n            int coins = nums[l-1] * nums[k] * nums[r+1];\n            coins += solve(nums, l, k-1, dp) + solve(nums, k+1, r, dp);\n            maxi = Math.max(maxi, coins);\n        }\n        return dp[l][r] = maxi;\n    }\n\n    public int maxCoins(int[] nums) {\n        int c = nums.length;\n        int[] moreNums = new int[c + 2];\n\n        moreNums[0] = moreNums[c + 1] = 1;\n        for (int i = 0; i < c; i++) {\n            moreNums[i+1] = nums[i];\n        }\n        int[][] dp = new int[c+1][c+1];\n        for (int i = 0; i < dp.length; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(moreNums, 1, c, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/burst-balloons/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: 'e24b48b7-e334-4d36-9689-30f3df3f04d5',
              isFolder: false,
              name: 'CoinChange2.java',
              code: 'import java.util.*;\n\nclass CoinChange2 {\n    public int solve(int[] coins, int amount, int idx, int[][] dp) {\n        if (idx == 0) {\n            if (amount % coins[idx] == 0) return 1;\n            return 0;\n        }\n        if (dp[idx][amount] != -1) return dp[idx][amount];\n        int notPick = solve(coins, amount, idx - 1, dp);\n        int pick = 0;\n        if (coins[idx] <= amount) {\n            pick = solve(coins, amount - coins[idx], idx, dp);\n        }\n        return dp[idx][amount] = pick + notPick;\n    }\n    public int change(int amount, int[] coins) {\n        int n = coins.length;\n        int[][] dp = new int[n][amount + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(coins, amount, n - 1, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/coin-change-ii/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '49dd859e-af25-4a01-bbbf-4bf32298a468',
              isFolder: false,
              name: 'DistinctSubsequences.java',
              code: 'import java.util.*;\n\nclass DistinctSubsequences {\n    public int solve(String s, String t, int i, int j, int[][] dp) {\n        if (j == t.length()) return 1;\n        if (i == s.length()) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        int count = solve(s, t, i+1, j, dp);\n        if (s.charAt(i) == t.charAt(j)) {\n            count += solve(s, t, i+1, j+1, dp);\n        }\n        return dp[i][j] = count;\n    }\n\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[s.length()][t.length()];\n        for (int i = 0; i < s.length(); i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(s, t, 0, 0, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/distinct-subsequences/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '04c7a373-b6df-4b58-9e34-08d728ec2f69',
              isFolder: false,
              name: 'EditDistance.java',
              code: 'import java.util.*;\n\nclass EditDistance {\n    public int solve(String w1, String w2, int n, int m, int[][] dp) {\n        if (n < 0) return m+1;\n        if (m < 0) return n+1;\n        if (dp[n][m] != -1) return dp[n][m];\n        if (w1.charAt(n) == w2.charAt(m)) {\n            return dp[n][m] = solve(w1, w2, n - 1, m - 1, dp);\n        } else {\n            int insert = solve(w1, w2, n, m - 1, dp);\n            int replace = solve(w1, w2, n - 1, m - 1, dp);\n            int delete = solve(w1, w2, n - 1, m, dp);\n            return dp[n][m] = 1 + Math.min(Math.min(insert, delete), replace);\n        }\n    }\n    public int minDistance(String word1, String word2) {\n        int n = word1.length(), m = word2.length();\n        int[][] dp = new int[n][m];\n        for (int i = 0; i< n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(word1, word2, n-1, m-1, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/edit-distance/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '9e286e22-55da-4a74-856d-bb2c247388ae',
              isFolder: false,
              name: 'InterleavingString.java',
              code: 'import java.util.*;\n\nclass InterleavingString {\n    public boolean solve(String s1, String s2, String s3, int i, int j, int[][] dp) {\n        if (i+j == s3.length()) return true;\n        if (dp[i][j] != -1) return dp[i][j] == 1;\n        char a = s3.charAt(i+j);\n        boolean ans = false;\n        if (i < s1.length() && s1.charAt(i) == a) {\n            ans = ans || solve(s1, s2, s3, i+1, j, dp);\n        }\n        if (j < s2.length() && s2.charAt(j) == a) {\n            ans = ans || solve(s1, s2, s3, i, j+1, dp);\n        }\n        dp[i][j] = ans ? 1 : 0;\n        return ans;\n    }\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int n = s3.length();\n        if (s1.length() + s2.length() != n) return false;\n        int[][] dp = new int[201][201];\n        for (int i = 0; i < 201; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(s1, s2, s3, 0, 0, dp);\n    }\n}',
              link: 'https://leetcode.com/problems/interleaving-string/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: 'b2ece921-4072-4ec2-aaa4-b9f6176103c7',
              isFolder: false,
              name: 'LongestCommonSubsequence.java',
              code: 'class LongestCommonSubsequence {\n    public int solve(String text1, String text2, int i1, int i2, int[][] dp) {\n        if (i1 < 0 || i2 < 0) return 0;\n        if (dp[i1][i2] != -1) return dp[i1][i2];\n        if (text1.charAt(i1) == text2.charAt(i2)) {\n            return dp[i1][i2] = 1 + solve(text1, text2, i1-1, i2-1, dp);\n        }\n        return dp[i1][i2] = Math.max(solve(text1, text2, i1-1, i2, dp), solve(text1, text2, i1, i2-1, dp));\n    }\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n = text1.length();\n        int m = text2.length();\n        int[][] dp = new int[n+1][m+1];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(text1, text2, n-1, m-1, dp);\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (text1.charAt(i-1) == text2.charAt(j-1)) {\n                    dp[i][j] = 1 + dp[i-1][j-1];\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[n][m];\n    }\n}',
              link: 'https://leetcode.com/problems/longest-common-subsequence/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '060594f5-579e-4ce6-b18c-6a9f267c2b6f',
              isFolder: false,
              name: 'LongestIncreasingPathInaMatrix.java',
              code: 'import java.util.*;\n\nclass LongestIncreasingPathInaMatrix {\n    public boolean isInbounds(int i, int j, int m, int n) {\n        return Math.min(i,j) >= 0 && i < m && j < n;\n    }\n    public int dfs(int[][] matrix, int[][] paths, int i, int j, int prev) {\n        if (!isInbounds(i,j,matrix.length, matrix[0].length) || matrix[i][j] <= prev ) {\n            return 0;\n        }\n        if (paths[i][j] != -1) return paths[i][j];\n        int a = 1 + dfs(matrix, paths, i+1, j, matrix[i][j]);\n        int b = 1 + dfs(matrix, paths, i, j+1, matrix[i][j]);\n        int c = 1 + dfs(matrix, paths, i-1, j, matrix[i][j]);\n        int d = 1 + dfs(matrix, paths, i, j-1, matrix[i][j]);\n        int maxi = Math.max(Math.max(a,b), Math.max(c,d));\n        return paths[i][j] = maxi;\n    }\n    public int longestIncreasingPath(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] paths = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(paths[i], -1);\n        }\n        int max = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                max = Math.max(max, dfs(matrix, paths, i, j, -1));\n            }\n        }\n        return max;\n    }\n}',
              link: 'https://leetcode.com/problems/longest-increasing-path-in-a-matrix/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '278bf863-cecc-4e4b-b27f-ac69a08b6642',
              isFolder: false,
              name: 'RegularExpressionMatching.java',
              code: "import java.util.*;\n\nclass RegularExpressionMatching {\n    public boolean solve(char[] s, char[] p, int i, int j, HashMap<String, Boolean> dp) {\n        if (i == s.length && j == p.length) return true;\n        if (j >= p.length) return false;\n        String key = i + \"_\" + j;\n        if (dp.containsKey(key)) return dp.get(key);\n        boolean ans = false;\n        boolean match = i < s.length && (s[i] == p[j] || p[j] == '.');\n        if (j + 1 < p.length && p[j+1] == '*') {\n            ans = solve(s, p, i, j+2, dp) || (match && solve(s, p, i+1, j, dp));\n        } else if (match) {\n            ans = solve(s, p, i+1, j+1, dp);\n        }\n        dp.put(key, ans);\n        return ans;\n    }\n    public boolean isMatch(String s, String p) {\n        HashMap<String, Boolean> dp = new HashMap<>();\n        char[] S = s.toCharArray();\n        char[] P = p.toCharArray();\n        return solve(S, P, 0, 0, dp);\n    }\n}",
              link: 'https://leetcode.com/problems/regular-expression-matching/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: 'd59cb84b-1598-4df2-ae6d-3a7d52639fc6',
              isFolder: false,
              name: 'TargetSum.java',
              code: 'import java.util.*;\n\nclass TargetSum {\n\tpublic static int solve(int[] arr, int i, int sum, int[][] dp) {\n\t\tif (i == 0) {\n\t\t\tif (sum == 0 && arr[i] == 0) return 2;\n\t\t\tif (sum == 0 || sum == arr[i]) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp[i][sum] != -1) return dp[i][sum];\n\t\tint np = solve(arr, i-1, sum, dp);\n\t\tint p = arr[i] <= sum ? solve(arr, i - 1, sum - arr[i], dp) : 0;\n\t\treturn dp[i][sum] = p + np;\n\t}\n\n\tpublic static int countPartitions(int n, int d, int[] arr) {\n\t\t// Write your code here.\n\t\tint total = 0;\n\t\tfor (int i : arr) {\n\t\t\ttotal += i;\n\t\t}\n\t\tif (total + d < 0 || (total+d) % 2 != 0) return 0;\n\t\tint[][] dp = new int[n][((total + d)/2) + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\treturn solve(arr, n-1, (total+d)/2, dp);\n\t}\n\n    // public int solve(int[] nums, int idx, int target, HashMap<String, Integer> hm) {\n    //     if (idx < 0) {\n    //         if (target == 0) return 1;\n    //         return 0;\n    //     }\n    //     String key = idx + "," + target;\n    //     if (hm.containsKey(key)) return hm.get(key);\n    //     int np = solve(nums, idx - 1, target - nums[idx], hm);\n    //     int p = solve(nums, idx - 1, target + nums[idx], hm);\n    //     hm.put(key, np + p);\n    //     return np + p;\n    // }\n\n    public int findTargetSumWays(int[] nums, int target) {\n        int n = nums.length;\n        // HashMap<String, Integer> hm = new HashMap<>();\n        // return solve(nums, n-1, target, hm);\n        return countPartitions(n, target, nums);\n    }\n}',
              link: 'https://leetcode.com/problems/target-sum/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '426649a3-77ff-4c42-84e5-8da3bae4a4b8',
              isFolder: false,
              name: 'UniquePaths.java',
              code: 'class UniquePaths {\n    public int paths(int m, int n, int[][] dp) {\n        if (m < 0 || n < 0) return 0;\n        if (m == 0 && n == 0) return 1;\n        if (dp[m][n] != -1) return dp[m][n];\n        return dp[m][n] = paths(m-1, n, dp) + paths(m, n-1, dp);\n    }\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        // for (int i = 0; i < m; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return paths(m-1,n-1,dp);\n        dp[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    int a = i > 0 ? dp[i-1][j] : 0;\n                    int b = j > 0 ? dp[i][j-1] : 0;\n                    dp[i][j] = a + b;\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}',
              link: 'https://leetcode.com/problems/unique-paths/',
              notes: '',
              tags: ['2D DP'],
            },
            {
              id: '65ea7280-0dd8-48a5-aa0f-69cdd7f3be6e',
              isFolder: false,
              name: 'AlienDictionary.java',
              code: "import java.util.*;\n\nclass AlienDictionary {\n    public static void bfs(List<List<Integer>> adj, char[] strs, int[] indegree) {\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                strs[count++] = (char) (node + 'a');\n                List<Integer> list = adj.get(node);\n                for (int ele : list) {\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n    }\n    public static void topologicalSort(List<List<Integer>> adj, int v, char[] strs) {\n        // Write your code here!\n        int[] indegree = new int[v];\n        for (int i = 0; i < v; i++) {\n            List<Integer> list = adj.get(i);\n            for (Integer node : list) {\n                indegree[node]++;\n            }\n        }\n//        List<Integer> ans = new ArrayList<>();\n        bfs(adj, strs, indegree);\n    }\n    public static String getAlienLanguage(String []dictionary, int k) {\n        // Write your code here.\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < dictionary.length - 1; i++) {\n            String str1 = dictionary[i];\n            String str2 = dictionary[i + 1];\n            int len = Math.min(str1.length(), str2.length());\n            for (int j = 0; j < len; j++) {\n                char s1 = str1.charAt(j);\n                char s2 = str2.charAt(j);\n                if (s1 != s2) {\n                    adj.get(s1 - 'a').add(s2 - 'a');\n                    break;\n                }\n            }\n        }\n        char[] strs = new char[k];\n        topologicalSort(adj, k, strs);\n        return new String(strs);\n    }\n}",
              link: 'https://www.naukri.com/code360/problems/alien-dictionary_630423',
              notes: '',
              tags: ['Advanced Graphs'],
            },
            {
              id: '990ca3f1-d836-40c3-9b19-8f332801e935',
              isFolder: false,
              name: 'CheapestFlightsWithinKStops.java',
              code: 'import java.util.*;\n\nclass CheapestFlightsWithinKStops {\n    static class Pair {\n        int node, cost;\n        Pair(int n, int c) {\n            this.node = n;\n            this.cost = c;\n        }\n    }\n    static class Triplet {\n        int stops, node, cost;\n        Triplet (int s, int n, int c) {\n            this.stops = s;\n            this.node = n;\n            this.cost = c;\n        }\n    }\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        List<List<Pair>> adj = new ArrayList<>();\n        int[] distance = new int[n];\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n            distance[i] = Integer.MAX_VALUE;\n        }\n        for (int i = 0; i < flights.length; i++) {\n            int x = flights[i][0];\n            int y = flights[i][1];\n            int z = flights[i][2];\n            adj.get(x).add(new Pair(y,z));\n        }\n        distance[src] = 0;\n        PriorityQueue<Triplet> pq = new PriorityQueue<>((a,b) -> a.stops - b.stops);\n        pq.add(new Triplet(0,src,0));\n        while (!pq.isEmpty()) {\n            Triplet t = pq.poll();\n            List<Pair> list = adj.get(t.node);\n            if (t.stops > k) continue;\n            for (Pair p : list) {\n                int cost = p.cost + t.cost;\n                if (cost < distance[p.node]) {\n                    distance[p.node] = cost;\n                    pq.add(new Triplet(t.stops+1, p.node, cost));\n                }\n            }\n        }\n        return distance[dst] == Integer.MAX_VALUE ? -1 : distance[dst];\n    }\n}',
              link: 'https://leetcode.com/problems/cheapest-flights-within-k-stops/',
              notes: '',
              tags: ['Advanced Graphs'],
            },
            {
              id: 'ca255a56-9102-4dbf-b6fd-8895aaefa302',
              isFolder: false,
              name: 'MinCosttoConnectAllPoints.java',
              code: 'import java.util.*;\n\nclass MinCosttoConnectAllPoints {\n    static class Pair {\n        int dist, node;\n        Pair (int d, int n) {\n            this.dist = d;\n            this.node = n;\n        }\n    }\n    public int getDist(int x1, int x2, int y1, int y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length;\n        List<List<Pair>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                List<Pair> list1 = adj.get(i);\n                List<Pair> list2 = adj.get(j);\n                int dist = getDist(points[i][0], points[j][0], points[i][1], points[j][1]);\n                list1.add(new Pair(dist, j));\n                list2.add(new Pair(dist, i));\n            }\n        }\n\n        HashSet<Integer> hs = new HashSet<>();\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.dist - b.dist);\n        pq.add(new Pair(0, 0));\n        int dist = 0;\n        while (!pq.isEmpty()) {\n            int size = pq.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = pq.poll();\n                if (hs.contains(p.node)) continue;\n                hs.add(p.node);\n                dist += p.dist;\n                List<Pair> ls = adj.get(p.node);\n                for (Pair a : ls) {\n                    if (!hs.contains(a.node)) {\n                        pq.add(a);\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n}',
              link: 'https://leetcode.com/problems/min-cost-to-connect-all-points/',
              notes: '',
              tags: ['Advanced Graphs'],
            },
            {
              id: '1cfffdaf-399a-4cf2-951e-9174fb945355',
              isFolder: false,
              name: 'NetworkDelayTime.java',
              code: 'import java.util.*;\n\nclass NetworkDelayTime {\n    static class Pair {\n        int node, cost;\n        Pair(int n, int c) {\n            this.node = n;\n            this.cost = c;\n        }\n    }\n    public int networkDelayTime(int[][] times, int n, int k) {\n        List<List<Pair>> adj = new ArrayList<>();\n        int[] dist = new int[n];\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n            dist[i] = Integer.MAX_VALUE;\n        }\n        for (int i = 0; i < times.length; i++) {\n            int x = times[i][0] - 1;\n            int y = times[i][1] - 1;\n            int z = times[i][2];\n            adj.get(x).add(new Pair(y,z));\n        }\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.cost - b.cost);\n        pq.add(new Pair(k-1, 0));\n        dist[k-1] = 0;\n        int sum = 0;\n        while (!pq.isEmpty()) {\n            Pair node = pq.poll();\n            List<Pair> list = adj.get(node.node);\n            for (Pair p : list) {\n                int cost = p.cost + node.cost;\n                if (cost < dist[p.node]) {\n                    dist[p.node] = cost;\n                    pq.add(new Pair(p.node, cost));\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dist[i] == Integer.MAX_VALUE) return -1;\n            sum = Math.max(sum, dist[i]);\n        }\n        return sum;\n    }\n}',
              link: 'https://leetcode.com/problems/network-delay-time/',
              notes: '',
              tags: ['Advanced Graphs'],
            },
            {
              id: '5a493525-870b-43eb-abc1-f96d9ea15884',
              isFolder: false,
              name: 'ReconstructItinerary.java',
              code: 'import java.util.*;\n\nclass ReconstructItinerary {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        HashMap<String, PriorityQueue<String>> adj = new HashMap<>();\n        for(List<String> ticket : tickets) {\n            String from = ticket.get(0);\n            String to = ticket.get(1);\n            PriorityQueue<String> list = adj.getOrDefault(from, new PriorityQueue<>());\n            list.add(to);\n            adj.put(from, list);\n        }\n        List<String> ans = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n        stack.push("JFK");\n        while (!stack.isEmpty()) {\n            String nextDestination = stack.peek();\n            if (!adj.getOrDefault(nextDestination, new PriorityQueue<>()).isEmpty()) {\n                stack.push(adj.get(nextDestination).poll());\n            } else {\n                ans.addFirst(stack.pop());\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/reconstruct-itinerary/',
              notes: '',
              tags: ['Advanced Graphs'],
            },
            {
              id: 'aaba6156-8f2e-4bd8-a1c4-97fcbdc0a5cd',
              isFolder: false,
              name: 'SwimInRisingWater.java',
              code: 'import java.util.*;\n\nclass SwimInRisingWater {\n    static class Pair {\n        int row, col, wt;\n        Pair(int r, int c, int w) {\n            this.row = r;\n            this.col = c;\n            this.wt = w;\n        }\n    }\n\n    public boolean isInBounds(int r, int c, int n) {\n        return r >= 0 && c >= 0 && r < n && c < n;\n    }\n    public int swimInWater(int[][] grid) {\n        // Ans = shortest path ka max value\n        int n = grid.length;\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.wt - b.wt);\n        pq.add(new Pair(0,0,grid[0][0]));\n        boolean[][] visited = new boolean[n][n];\n        int max = 0;\n        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            visited[p.row][p.col] = true;\n            max = Math.max(max, p.wt);\n            if (p.row == n-1 && p.col == n-1) return max;\n            for (int d = 0; d < 4; d++) {\n                int r = p.row + dirs[d][0], c = p.col + dirs[d][1];\n                if (isInBounds(r,c,n) && !visited[r][c]) {\n                    pq.add(new Pair(r,c,grid[r][c]));\n                    visited[r][c] = true;\n                }\n            }\n        }\n        return max;\n    }\n}',
              link: 'https://leetcode.com/problems/swim-in-rising-water/',
              notes: '',
              tags: ['Advanced Graphs'],
            },
            {
              id: '0e42f01e-76eb-4df4-864b-f98c2110bdfb',
              isFolder: false,
              name: 'ContainsDuplicate.java',
              code: 'import java.util.*;\n\nclass ContainsDuplicate {\n    public boolean containsDuplicate(int[] nums) {\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : nums) {\n            if (hs.contains(i)) return true;\n            hs.add(i);\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/contains-duplicate/',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'd7d1fc81-44fb-49b0-a509-60c225921ecb',
              isFolder: false,
              name: 'EncodeAndDecodeStrings.java',
              code: "import java.util.*;\n\npublic class EncodeAndDecodeStrings {\n    public String encode(List<String> strs) {\n        StringBuilder sb = new StringBuilder();\n        for (String str: strs) {\n            sb.append(str).append('|');\n        }\n        return sb.toString();\n    }\n\n    public List<String> decode(String str) {\n        List<String> list = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            if (ch == '|') {\n                list.add(sb.toString());\n                sb.setLength(0);\n            } else {\n                sb.append(ch);\n            }\n        }\n        return list;\n    }\n}",
              link: 'https://neetcode.io/problems/string-encode-and-decode',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '13bb6bf0-e16a-4a9b-a271-f43e84c0a2df',
              isFolder: false,
              name: 'GroupAnagrams.java',
              code: 'import java.util.*;\n/*\n* Sorting and storing in hashmap and value list\n* if a duplicate string is found store it in value list.\n* If it does not exist create a new key value pair in hashmap\n*/\n\npublic class GroupAnagrams {\n    public static List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<String, List<String>> hm = new HashMap<>();\n        for (String str : strs) {\n            char[] ch = str.toCharArray();\n            Arrays.sort(ch);\n            String s = new String(ch);\n            if (!hm.containsKey(s)) {\n                hm.put(s, new ArrayList<>());\n            }\n            hm.get(s).add(str);\n        }\n        System.out.println(hm);\n        return new ArrayList<>(hm.values());\n    }\n\n    public static void main(String[] args) {\n//        String[] arr = {"eat","tea","tan","ate","nat","bat"};\n        String[] arr = {""};\n        List<List<String>> ans = groupAnagrams(arr);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/group-anagrams',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '2e32cf94-b66e-4637-81fd-bf4f3a8b81e6',
              isFolder: false,
              name: 'LongestConsecutiveSequence.java',
              code: 'import java.util.*;\n\npublic class LongestConsecutiveSequence {\n    public static int longestConsecutive(int[] N) {\n//        Brute force solution\n//        if (N.length == 0) return 0;\n//        Arrays.sort(N);\n//        int maxLen = 0, len = 1, last = Integer.MIN_VALUE;\n//        for (int k : N) {\n//            if (k - 1 == last) len++;\n//            else if (k != last)len = 1;\n//            last = k;\n//            maxLen = Math.max(maxLen, len);\n//        }\n//        return maxLen;\n\n//        Best solution\n        HashSet<Integer> hs = new HashSet<>();\n        int maxCount = 0;\n        for (int num: N) hs.add(num);\n        for (int j : N) {\n            if (!hs.contains(j - 1)) {\n                int x = j;\n                int count = 1;\n                while (hs.contains(x+1)) {\n                    count++;\n                    x++;\n                }\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n        return maxCount;\n    }\n    public static void main(String[] args) {\n\n    }\n}',
              link: 'https://leetcode.com/problems/longest-consecutive-sequence',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '0dc74842-d3be-456f-abe2-7f98f6965bdc',
              isFolder: false,
              name: 'ProductArrayExceptSelf.java',
              code: 'public class ProductArrayExceptSelf {\n    public int[] productExceptSelf(int[] nums) {\n        int zeroCount = 0;\n        int zeroIdx = -1;\n        int[] ans = new int[nums.length];\n        int product = 1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                zeroCount++;\n                if (zeroCount > 1) return ans;\n                zeroIdx = i;\n                continue;\n            }\n            product *= nums[i];\n        }\n        if (zeroCount == 1) {\n            ans[zeroIdx] = product;\n            return ans;\n        }\n        for (int j = 0; j < nums.length; j++) {\n            ans[j] = product / nums[j];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/product-of-array-except-self/',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'de928a92-2568-4966-9e16-2e23a61d7c0b',
              isFolder: false,
              name: 'TopKFrequentElements.java',
              code: 'import java.util.*;\n\npublic class TopKFrequentElements {\n    public static int[] topKFrequent(int[] nums, int k) {\n        // This is the O(klogN) solution\n        // int[] kArr = new int[k];\n        // HashMap<Integer, Integer> hm = new HashMap<>();\n        // for (int num : nums) {\n        //     hm.put(num, hm.getOrDefault(num, 0) + 1);\n        // }\n        // PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue());\n        // for (Map.Entry<Integer, Integer> it : hm.entrySet()) {\n        //     pq.add(it);\n        //     if (pq.size() > k) pq.poll();\n        // }\n        // while (!pq.isEmpty()) {\n        //     kArr[--k] = pq.poll().getKey();\n        // }\n        // return kArr;\n\n        // Most efficient solution: O(n)\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        List<List<Integer>> countList = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            countList.add(new ArrayList<>());\n        }\n        for(Map.Entry<Integer, Integer> val : hm.entrySet()) {\n            countList.get(val.getValue()-1).add(val.getKey());\n        }\n        int[] ans = new int[k];\n        int ptr = 0;\n        for (int i = countList.size() - 1; i >= 0; i--) {\n            if (!countList.get(i).isEmpty()) {\n                for (int j: countList.get(i)) {\n                    if (ptr == k) break;\n                    ans[ptr++] = j;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 1, 1, 2, 2, 3};\n        int k = 2;\n        int[] ans = topKFrequent(nums, k);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/top-k-frequent-elements',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'a7df13bd-ee68-4d6a-a772-1e32d1c38d54',
              isFolder: false,
              name: 'TwoSum.java',
              code: 'import java.util.HashMap;\n\npublic class TwoSum {\n  public int[] twoSum(int[] nums, int target) {\n    HashMap<Integer, Integer> hm = new HashMap<>();\n    for (int j = 0; j < nums.length; j++) {\n      if (hm.containsKey(target - nums[j]))\n        return new int[] { j, hm.get(target - nums[j]) };\n      hm.put(nums[j], j);\n    }\n    return new int[] { -1, -1 };\n  }\n}',
              link: 'https://leetcode.com/problems/two-sum',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'd72c91b8-99f2-4fb3-9b62-83c5031c8138',
              isFolder: false,
              name: 'ValidAnagram.java',
              code: "public class ValidAnagram {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length())\n      return false;\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n      count[s.charAt(i) - 'a']++;\n      count[t.charAt(i) - 'a']--;\n    }\n    for (int i = 0; i < 26; i++) {\n      if (count[i] != 0)\n        return false;\n    }\n    return true;\n  }\n}",
              link: 'https://leetcode.com/problems/valid-anagram',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'c9e92555-12cf-403f-a9cd-5d869cfaab1a',
              isFolder: false,
              name: 'ValidSudoku.java',
              code: "import java.util.HashSet;\n\npublic class ValidSudoku {\n    public static boolean checkBlock(int iIdx, int jIdx, char[][] board) {\n        HashSet<Character> hs = new HashSet<>();\n        int rows = iIdx + 3;\n        int cols = jIdx + 3;\n        for (int i = iIdx; i < rows; i++) {\n            for (int j = jIdx; j < cols; j++) {\n                char curr = board[i][j];\n                if (curr != '.') {\n                    if (hs.contains(curr)) return false;\n                    hs.add(curr);\n                }\n            }\n        }\n        return true;\n    }\n    public static boolean isValidSudoku(char[][] board) {\n//        Row column check\n        for (int i = 0; i < board.length; i++) {\n            HashSet<Character> row = new HashSet<>();\n            HashSet<Character> col = new HashSet<>();\n            for (int j = 0; j < board.length; j++) {\n                char r = board[i][j], c = board[j][i];\n                if (r != '.' && row.contains(r)) return false;\n                else row.add(r);\n                if (c != '.' && col.contains(c)) return false;\n                else col.add(c);\n            }\n        }\n//        3x3 box check\n        for (int i = 0; i < 9; i += 3)\n            for (int j = 0; j < 9; j += 3)\n                if (!checkBlock(i, j, board)) return false;\n\n        return true;\n    }\n}",
              link: 'https://leetcode.com/problems/valid-sudoku',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '010a1456-696f-4ff6-a4d0-d76a4b58f78c',
              isFolder: false,
              name: 'CombinationSum.java',
              code: 'import java.util.*;\n\nclass CombinationSum {\n    public static void solve(int[] candidates, int target, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        if (idx == candidates.length) {\n            if (target == 0) {\n                ans.add(new ArrayList<>(temp));\n            }\n            return;\n        }\n        if (candidates[idx] <= target) {\n            temp.add(candidates[idx]);\n            solve(candidates, target - candidates[idx], idx, ans, temp);\n            temp.remove(temp.size() - 1);\n        }\n        solve(candidates, target, idx + 1, ans, temp);\n\n    }\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(candidates, target, 0, ans, new ArrayList<>());\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/combination-sum/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: '57f84aef-715c-4315-8fcb-012cfa10b716',
              isFolder: false,
              name: 'CombinationSum2.java',
              code: 'import java.util.*;\n\nclass CombinationSum2 {\n    public static void solve(int[] arr, int k, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        if (k == 0) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i] == arr[i-1]) continue;\n            if (arr[i] > k) return;\n            temp.add(arr[i]);\n            solve(arr, k - arr[i], i + 1, ans, temp);\n            temp.remove(temp.size() - 1);\n        }\n\n    }\n    public List<List<Integer>> combinationSum2(int[] arr, int target) {\n        Arrays.sort(arr);\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, target, 0, ans, new ArrayList<>());\n        return new ArrayList<>(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/combination-sum-ii/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: '3d658805-1b92-4e05-8c77-e5fb82e5e41d',
              isFolder: false,
              name: 'LetterCombinationsofaPhoneNumber.java',
              code: 'import java.util.*;\n\nclass LetterCombinationsofaPhoneNumber {\n    public List<String> letterCombinations(String s) {\n        List<String> ans = new ArrayList<>();\n        if (s.length() == 0) return ans;\n        String[] mappings = {"", "", "abc","def", "ghi", "jkl","mno", "pqrs", "tuv","wxyz"};\n        solve(s, 0, ans, new StringBuilder(), mappings);\n        return ans;\n    }\n    void solve(String s, int idx, List<String> ans, StringBuilder sb, String[] mappings) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        char ch = s.charAt(idx);\n        String map = mappings[ch - \'0\'];\n        for (int i = 0; i < map.length(); i++) {\n            sb.append(map.charAt(i));\n            solve(s, idx + 1, ans, sb, mappings);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: '9ee39e73-5d56-4c88-a91f-0edb14e27f86',
              isFolder: false,
              name: 'NQueens.java',
              code: "import java.util.*;\n\nclass NQueens {\n    static boolean safeToPlace(char[][] board, int col, int row) {\n        int r = row, c = col;\n        // Upper diagonal\n        while (r >= 0 && c >= 0)\n            if (board[r--][c--] == 'Q')\n                return false;\n        // Middle\n        r = row;\n        c = col;\n        while (c >= 0)\n            if (board[r][c--] == 'Q')\n                return false;\n        // Lower diagonal\n        c = col;\n        while (c >= 0 && r < board.length)\n            if (board[r++][c--] == 'Q')\n                return false;\n        return true;\n    }\n\n    static void solve(List<List<String>> ans, int col, char[][] board) {\n        if (col == board.length) {\n            List<String> temp = new ArrayList<>();\n            for (char[] chars : board)\n                temp.add(new String(chars));\n            ans.add(temp);\n            return;\n        }\n        for (int row = 0; row < board.length; row++) {\n            if (safeToPlace(board, col, row)) {\n                board[row][col] = 'Q';\n                solve(ans, col + 1, board);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> ans = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                board[i][j] = '.';\n        solve(ans, 0, board);\n        return ans;\n    }\n}",
              link: 'https://leetcode.com/problems/n-queens/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: '81fa504b-b8da-428b-aecb-8f6b49a8f50d',
              isFolder: false,
              name: 'PalindromePartitioning.java',
              code: 'import java.util.*;\n\nclass PalindromePartitioning {\n    public boolean isPalindrome(String s, int i, int j) {\n        while (i <= j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n    public void solve(String s, List<List<String>> ans, List<String> list, int idx) {\n        if (idx == s.length()) {\n            ans.add(new ArrayList<>(list));\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            if (!isPalindrome(s, idx, i)) continue;\n            list.add(s.substring(idx, i+1));\n            solve(s, ans, list, i+1);\n            list.remove(list.size() - 1);\n        }\n    }\n    public List<List<String>> partition(String s) {\n        List<List<String>> ans = new ArrayList<>();\n        solve(s, ans, new ArrayList<>(), 0);\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/palindrome-partitioning/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: 'a1a9334d-8490-4536-ae69-2b1c3f039bc0',
              isFolder: false,
              name: 'Permutations.java',
              code: 'import java.util.*;\n\nclass Permutations {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static void solve(List<List<Integer>> ans, int idx, int[] arr) {\n        if (idx == arr.length) {\n            List<Integer> temp = new ArrayList<>();\n            for (int i = 0; i < arr.length; i++) {\n                temp.add(arr[i]);\n            }\n            ans.add(temp);\n            return;\n        }\n        for (int i = idx; i < arr.length; i++) {\n            swap(arr, i, idx);\n            solve(ans, idx + 1, arr);\n            swap(arr, i, idx);\n        }\n    }\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(ans, 0, nums);\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/permutations/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: 'e24b6135-6123-462b-968f-b2be49339c41',
              isFolder: false,
              name: 'Subsets.java',
              code: 'import java.util.*;\n\nclass Subsets {\n    // Power set implementation\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        int limit = 1 << nums.length;\n        for (int i = 0; i < limit; i++) {\n            int num = i;\n            List<Integer> temp = new ArrayList<>();\n            int idx = 0;\n            while (num != 0) {\n                if ((num & 1) == 1) {\n                    temp.add(nums[idx]);\n                }\n                idx++;\n                num = num >> 1;\n            }\n            ans.add(temp);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: '1099af17-14fc-45ff-8a2e-52a3d276bc62',
              isFolder: false,
              name: 'Subsets2.java',
              code: 'import java.util.*;\n\nclass Subsets2 {\n    public static void solve(int[] arr, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        ans.add(new ArrayList<>(temp));\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i - 1] == arr[i]) continue;\n            temp.add(arr[i]);\n            solve(arr, i + 1, ans, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(nums, 0, ans, new ArrayList<>());\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/subsets-ii/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: '607b8d35-9309-4c31-a621-c69ae88b6d54',
              isFolder: false,
              name: 'WordSearch.java',
              code: 'import java.util.*;\n\nclass WordSearch {\n    public boolean isInBounds(int i, int j, int n, int m) {\n        return i >= 0 && i < n && j >= 0 && j < m;\n    }\n    public boolean dfs(char[][] B, boolean[][] V, int i, int j, String W, int idx) {\n        if (idx == W.length()) {\n            return true;\n        }\n        if (!isInBounds(i,j,B.length,B[0].length) || (V[i][j] || W.charAt(idx) != B[i][j])) {\n            return false;\n        }\n        V[i][j] = true;\n        if (dfs(B, V, i+1, j, W, idx + 1)\n        || dfs(B, V, i, j+1, W, idx + 1)\n        || dfs(B, V, i-1, j, W, idx + 1)\n        || dfs(B, V, i, j-1, W, idx + 1)) return true;\n        V[i][j] = false;\n        return false;\n    }\n    public boolean exist(char[][] board, String word) {\n        int n = board.length, m = board[0].length;\n        boolean[][] visited = new boolean[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (word.charAt(0) == board[i][j]) {\n                    boolean ans = dfs(board, visited, i, j, word, 0);\n                    if (ans) return true;\n                }\n            }\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/word-search/',
              notes: '',
              tags: ['Backtracking'],
            },
            {
              id: 'b3bad734-3cf5-4e18-a5d4-3c31840c6a15',
              isFolder: false,
              name: 'BinarySearch.java',
              code: 'import java.util.*;\n\npublic class BinarySearch {\n    public int search(int[] nums, int target) {\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] >= target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/binary-search/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '6f2fb7c2-f5a0-4a22-8619-207e0bae1842',
              isFolder: false,
              name: 'FindMinInSortedRotatedArray.java',
              code: 'public class FindMinInSortedRotatedArray {\n    public int findMin(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] > arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'fc86e565-121f-4432-9d02-e805bcc53681',
              isFolder: false,
              name: 'kokoEatingBananas.java',
              code: 'public class kokoEatingBananas {\n    public long totalTimeToEat(int mid, int[] piles) {\n        long hours = 0;\n        for (int i : piles) {\n            hours += (i + mid - 1) / mid;\n        }\n        return hours;\n    }\n\n    public int minEatingSpeed(int[] piles, int h) {\n        int start = 1;\n        int end = 0;\n        for(int i: piles) {\n            end = Math.max(end, i);\n        }\n        int ans = 0;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (totalTimeToEat(mid, piles) <= h) {\n                ans = mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/koko-eating-bananas',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '2eafc243-e97d-4a52-a5b0-15dc2ba1b1b8',
              isFolder: false,
              name: 'MedianOfTwoSortedArrays.java',
              code: 'public class MedianOfTwoSortedArrays {\n    public double findMedianSortedArrays(int[] M, int[] N) {\n       int m = M.length, n = N.length;\n       if (m > n) return findMedianSortedArrays(N, M);\n       int k = (m + n + 1)/2;\n       int start = 0, end = m;\n       while (start <= end) {\n           int mid1 = start + (end - start)/2;\n           int mid2 = k - mid1;\n           int l1 = mid1 > 0 ? M[mid1 - 1] : Integer.MIN_VALUE;\n           int l2 = mid2 > 0 ? N[mid2 - 1] : Integer.MIN_VALUE;\n           int r1 = mid1 < m ? M[mid1] : Integer.MIN_VALUE;\n           int r2 = mid2 < n ? N[mid2] : Integer.MIN_VALUE;\n           if (l1 <= r2 && l2 <= r1) {\n               double median = Math.max(l1, l2);\n               if ((m+n) %2 == 0) {\n                   median += Math.min(r1, r2);\n                   return median / 2;\n               }\n               return median;\n           }\n           if (l1 > r2) {\n               end = mid1 - 1;\n           } else {\n               start = mid1 + 1;\n           }\n       }\n       return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/median-of-two-sorted-arrays',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'd4fcdcb4-6056-41cc-8ed5-a63fb6723f13',
              isFolder: false,
              name: 'Search2DMatrix.java',
              code: 'public class Search2DMatrix {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        int start = 0;\n        int end = n*m -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (matrix[mid/m][mid%m] == target)\n                return true;\n            if (matrix[mid/m][mid%m] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/search-a-2d-matrix',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '0d4cc5ba-b051-4241-b037-6b875ae2e064',
              isFolder: false,
              name: 'SearchInRotatedSortedArray.java',
              code: 'public class SearchInRotatedSortedArray {\n    public int search(int[] arr, int target) {\n        int start = 0; int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (target == arr[mid]) return mid;\n            if (arr[mid] >= arr[start]) {\n                if (target >= arr[start] && target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target <= arr[end] && target > arr[mid])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            }\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/search-in-rotated-sorted-array',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '63a6b559-3e48-4ebd-9028-3a59920d6315',
              isFolder: false,
              name: 'TimeMap.java',
              code: 'import java.util.*;\n\nclass TimeMap {\n    HashMap<String, List<String[]>> hm;\n    public TimeMap() {\n        hm = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (!hm.containsKey(key))\n            hm.put(key, new ArrayList<>());\n        hm.get(key).add(new String[]{ value, String.valueOf(timestamp) });\n    }\n\n    public String get(String key, int timestamp) {\n        if (!hm.containsKey(key)) return "";\n        List<String[]> list = hm.get(key);\n        int pos = findPos(list, timestamp);\n        if (pos == -1) return "";\n        return list.get(pos)[0];\n    }\n\n    public static int findPos(List<String[]> list, int target) {\n        int start = 0, end = list.size() - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int val = Integer.parseInt(list.get(mid)[1]);\n            if (val == target) return mid;\n            if (val > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static void main(String[] args) {\n        String[] operations = {"TimeMap", "set", "set", "get", "get", "get", "get", "get"};\n        String[][] values = {{}, {"love", "high", "10"}, {"love", "low", "20"}, {"love", "5"}, {"love", "10"}, {"love", "15"}, {"love", "20"}, {"love", "25"}};\n        TimeMap timeMap = null;\n        List<String> output = new ArrayList<>();\n        for (int i = 0; i < operations.length; i++) {\n            String[] val = values[i];\n            switch (operations[i]) {\n                case "TimeMap" -> {\n                    timeMap = new TimeMap();\n                    output.add(null);\n                }\n                case "set" -> {\n                    timeMap.set(val[0], val[1], Integer.parseInt(val[2]));\n                    output.add(null);\n                }\n                case "get" -> {\n                    output.add(timeMap.get(val[0], Integer.parseInt(val[1])));\n                }\n            }\n        }\n        System.out.println(output);\n    }\n}\n\n/**\n * Your TimeMap object will be instantiated and called as such:\n * TimeMap obj = new TimeMap();\n * obj.set(key,value,timestamp);\n * String param_2 = obj.get(key,timestamp);\n */',
              link: 'https://leetcode.com/problems/time-based-key-value-store',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '5fb6217a-0b8d-4f95-a1d7-eaf8129c124f',
              isFolder: false,
              name: 'CountingBits.java',
              code: 'class CountingBits {\n    public int hammingWeight(int n) {\n        int bits = 0;\n        while (n != 0) {\n            if ((n&1) == 1) {\n                bits++;\n            }\n            n = n >> 1;\n        }\n        return bits;\n    }\n    public int[] countBits(int n) {\n        int[] ans = new int[n+1];\n        for (int i = 0; i <= n; i++) {\n            ans[i] = hammingWeight(i);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/counting-bits/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '05db7404-84c5-4493-b37d-b9dfe9331da9',
              isFolder: false,
              name: 'MissingNumber.java',
              code: 'class MissingNumber {\n    public int missingNumber(int[] nums) {\n        int sum = 0;\n        int n = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        int diff = (n * (n+1) / 2) - sum;\n        return diff;\n    }\n}',
              link: 'https://leetcode.com/problems/missing-number/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '80067f17-ea95-45d9-96d0-ebbe3812d6f9',
              isFolder: false,
              name: 'Numberof1Bits.java',
              code: 'class Numberof1Bits {\n    public int hammingWeight(int n) {\n        int bits = 0;\n        while (n != 0) {\n            if ((n&1) == 1) {\n                bits++;\n            }\n            n = n >> 1;\n        }\n        return bits;\n    }\n}',
              link: 'https://leetcode.com/problems/number-of-1-bits/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '862fa801-8655-4f4c-b4cd-21fd439dc2d7',
              isFolder: false,
              name: 'ReverseBits.java',
              code: 'class ReverseBits {\n    public int reverseBits(int n) {\n        int ans = 0;\n        for (int i = 0; i < 32; i++) {\n            ans <<= 1;\n            ans |= (n&1);\n            n >>= 1;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-bits/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: 'a3386b3f-ce74-4e10-886c-45bff40e8475',
              isFolder: false,
              name: 'ReverseInteger.java',
              code: 'class ReverseInteger {\n    public int reverse(int n) {\n        boolean isNegative = n < 0;\n        int num = 0;\n        n = Math.abs(n);\n        while (n > 0) {\n            if (Integer.MAX_VALUE / 10 < num) return 0;\n            num = num*10 + n % 10;\n            n = n / 10;\n        }\n        return isNegative ? -num : num;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-integer/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '510be22d-1559-418b-a7ca-059ca6a112b6',
              isFolder: false,
              name: 'SingleNumber.java',
              code: 'class SingleNumber {\n    public int singleNumber(int[] nums) {\n        int xor = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            xor ^= nums[i];\n        }\n        return xor;\n    }\n}',
              link: 'https://leetcode.com/problems/single-number/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '6a22c36f-3efd-467d-be6f-e40ed4c214db',
              isFolder: false,
              name: 'SumofTwoIntegers.java',
              code: 'class SumofTwoIntegers {\n    public int getSum(int a, int b) {\n        while (b != 0) {\n            int temp = (a&b) << 1;\n            a = (a^b);\n            b = temp;\n        }\n        return a;\n    }\n}',
              link: 'https://leetcode.com/problems/sum-of-two-integers/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: 'ef7d9bcd-234f-43f1-8a97-59c03fc44ef8',
              isFolder: false,
              name: 'CloneGraph.java',
              code: 'import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n\nclass CloneGraph {\n    public Node dfs(HashMap<Node, Node> hm, Node node) {\n        if (node == null) return null;\n        if (hm.containsKey(node)) {\n            return hm.get(node);\n        }\n        Node copy = new Node(node.val);\n        hm.put(node, copy);\n        for (Node n : node.neighbors) {\n            copy.neighbors.add(dfs(hm, n));\n        }\n        return copy;\n    }\n    public Node cloneGraph(Node node) {\n        HashMap<Node, Node> hm = new HashMap<>();\n        return dfs(hm, node);\n    }\n}',
              link: 'https://leetcode.com/problems/clone-graph/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: 'a32e3964-9b24-4c92-9533-a32410b93bef',
              isFolder: false,
              name: 'CourseSchedule.java',
              code: 'import java.util.*;\n\nclass CourseSchedule {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < prerequisites.length; i++) {\n            indegree[prerequisites[i][0]]++;\n            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                count++;\n                for (int j = 0; j < adj.get(node).size(); j++) {\n                    int ele = adj.get(node).get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count == numCourses;\n    }\n}',
              link: 'https://leetcode.com/problems/course-schedule/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: 'a1546ad9-c93d-4e0e-8ced-f17ca74b7f3d',
              isFolder: false,
              name: 'CourseSchedule2.java',
              code: 'import java.util.*;\n\nclass CourseSchedule2 {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < prerequisites.length; i++) {\n            indegree[prerequisites[i][0]]++;\n            adj.get(prerequisites[i][1]).add(prerequisites[i][0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int[] ans = new int[numCourses];\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans[count++] = node;\n                for (int j = 0; j < adj.get(node).size(); j++) {\n                    int ele = adj.get(node).get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count == numCourses ? ans : new int[]{};\n    }\n}',
              link: 'https://leetcode.com/problems/course-schedule-ii/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '29f77a23-435d-404c-b48d-15f7810936a8',
              isFolder: false,
              name: 'GraphValidTree.java',
              code: 'import java.util.*;\n\nclass GraphValidTree {\n    public boolean dfs(List<List<Integer>> adj, boolean[] visited, int curr, int parent) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (int ele : list) {\n            if (!visited[ele]) {\n                if (dfs(adj, visited, ele, curr)) return true;\n            } else if (parent != ele) return true;\n        }\n        return false;\n    }\n    public boolean validTree(int n, int[][] edges) {\n        // If you see a cycle then its not a tree\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < edges.length; i++) {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            adj.get(x).add(y);\n            adj.get(y).add(x);\n        }\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                count++;\n                if (count > 1 || dfs(adj, visited, i, -1)) return false;\n            }\n        }\n        return count == 1;\n    }\n}',
              link: 'https://neetcode.io/problems/valid-tree',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: 'abd85e0d-115e-418a-ba72-7bdbe72196ea',
              isFolder: false,
              name: 'MaxAreaOfIsland.java',
              code: 'class MaxAreaOfIsland {\n    public int dfs(int[][] grid, int i, int j, int fill) {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return 0;\n        grid[i][j] = fill;\n        int sum = 1;\n        sum += dfs(grid, i, j+1, fill);\n        sum += dfs(grid, i+1, j, fill);\n        sum += dfs(grid, i, j-1, fill);\n        sum += dfs(grid, i-1, j, fill);\n        return sum;\n    }\n    public int maxAreaOfIsland(int[][] grid) {\n        int fill = 2;\n        int m = grid.length, n = grid[0].length;\n        int maxValue = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    maxValue = Math.max(maxValue, dfs(grid, i, j, fill++));\n                }\n            }\n        }\n\n        // int[] countArr = new int[fill];\n        // int maxValue = 0;\n        // for (int i = 0; i < m; i++) {\n        //     for (int j = 0; j < n; j++) {\n        //         if (grid[i][j] > 1) {\n        //             countArr[grid[i][j]]++;\n        //             if (countArr[grid[i][j]] > maxValue) {\n        //                 maxValue = countArr[grid[i][j]];\n        //             }\n        //         }\n        //     }\n        // }\n\n\n        return maxValue;\n    }\n}',
              link: 'https://leetcode.com/problems/max-area-of-island/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '7323ed63-d871-42bd-b089-b018c73d3a9a',
              isFolder: false,
              name: 'NumberofConnectedComponentsInUndirectedGraph.java',
              code: 'import java.util.*;\n\nclass NumberofConnectedComponentsInUndirectedGraph {\n    public void dfs(List<List<Integer>> adj, boolean[] vis, int curr) {\n        vis[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (Integer i : list) {\n            if (!vis[i]) {\n                dfs(adj, vis, i);\n            }\n        }\n    }\n    public int countComponents(int n, int[][] edges) {\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < edges.length; i++) {\n            adj.get(edges[i][0]).add(edges[i][1]);\n            adj.get(edges[i][1]).add(edges[i][0]);\n        }\n        boolean[] vis = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (!vis[i]) {\n                count++;\n                dfs(adj, vis, i);\n            }\n        }\n        return count;\n    }\n}',
              link: 'https://neetcode.io/problems/count-connected-components',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: 'c7f3177e-6124-4e71-a22f-46aa25ed711c',
              isFolder: false,
              name: 'NumberOfIslands.java',
              code: "class NumberOfIslands {\n    public void dfs(char[][] grid, int i, int j) {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != '1') return;\n        grid[i][j] = '2';\n        dfs(grid, i, j+1);\n        dfs(grid, i+1, j);\n        dfs(grid, i, j-1);\n        dfs(grid, i-1, j);\n    }\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        int m = grid.length, n = grid[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n}",
              link: 'https://leetcode.com/problems/number-of-islands/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: 'f26de11b-69c2-4b5a-834f-38ad41793800',
              isFolder: false,
              name: 'PacificAtlanticWaterFlow.java',
              code: 'import java.util.*;\n\nclass PacificAtlanticWaterFlow {\n    public static boolean isInBound(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public void dfs(int[][] heights, boolean[][] visited, int r,\n    int c, List<List<Integer>> ans, int prevH) {\n        int m = heights.length, n = heights[0].length;\n        if (!isInBound(r,c,m,n) || visited[r][c] || heights[r][c] < prevH) return;\n        visited[r][c] = true;\n        dfs(heights, visited, r+1, c, ans, heights[r][c]);\n        dfs(heights, visited, r, c+1, ans, heights[r][c]);\n        dfs(heights, visited, r-1, c, ans, heights[r][c]);\n        dfs(heights, visited, r, c-1, ans, heights[r][c]);\n    }\n\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        int m = heights.length, n = heights[0].length;\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            dfs(heights, pacific, i, 0, ans, heights[i][0]);\n            dfs(heights, atlantic, i, n-1, ans, heights[i][n-1]);\n        }\n        for (int i = 0; i < n; i++) {\n            dfs(heights, pacific, 0, i, ans, heights[0][i]);\n            dfs(heights, atlantic, m-1, i, ans, heights[m-1][i]);\n        }\n        for (int r = 0; r < m; r++) {\n            for (int c = 0; c < n; c++) {\n                if (pacific[r][c] && atlantic[r][c]) {\n                    ans.add(Arrays.asList(r, c));\n                }\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/pacific-atlantic-water-flow/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '30f27063-773c-4135-8e96-46fabaeb5d4a',
              isFolder: false,
              name: 'RedundantConnection.java',
              code: 'class RedundantConnection {\n    public class DisjointSet {\n        int[] parent;\n        int[] rank;\n        DisjointSet(int n) {\n            this.parent = new int[n];\n            this.rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int find(int num) {\n            if (num == parent[num])\n                return num;\n            parent[num] = find(parent[num]);\n            return parent[num];\n        }\n\n        public void union(int u, int v) {\n            int ultParentU = find(u), ultParentV = find(v);\n            if (ultParentU == ultParentV)\n                return;\n            if (rank[ultParentU] > rank[ultParentV]) {\n                parent[ultParentV] = ultParentU;\n            } else if (rank[ultParentU] < rank[ultParentV]) {\n                parent[ultParentU] = ultParentV;\n            } else {\n                parent[ultParentV] = ultParentU;\n                rank[ultParentU]++;\n            }\n        }\n    }\n\n    public int[] findRedundantConnection(int[][] edges) {\n        int maxNode = 0;\n        for (int[] edge : edges) {\n            maxNode = Math.max(edge[0], Math.max(edge[1], maxNode));\n        }\n        DisjointSet ds = new DisjointSet(maxNode + 1);\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            if (ds.find(x) != ds.find(y)) {\n                ds.union(x,y);\n            } else {\n                return edge;\n            }\n        }\n\n        return new int[]{-1,-1};\n    }\n}',
              link: 'https://leetcode.com/problems/redundant-connection/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '141c1363-33ca-4730-93ac-ff4b591e5fe1',
              isFolder: false,
              name: 'RottingOranges.java',
              code: 'import java.util.*;\n\nclass RottingOranges {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            row = r;\n            col = c;\n        }\n    }\n    public boolean isInBound(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int orangesRotting(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<Pair> q = new LinkedList<>();\n        int fresh = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) q.add(new Pair(i, j));\n                else if (grid[i][j] == 1) fresh++;\n            }\n        }\n        if (fresh == 0) return 0;\n        // if (fresh > 0 && q.isEmpty()) return -1;\n        boolean[][] visited = new boolean[m][n];\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                visited[p.row][p.col] = true;\n                for (int d = 0; d < 4; d++) {\n                    int r = directions[d][0] + p.row;\n                    int c = directions[d][1] + p.col;\n                    if (isInBound(r,c,m,n) && !visited[r][c] && grid[r][c] == 1) {\n                        grid[r][c] = 2;\n                        q.add(new Pair(r, c));\n                        fresh--;\n                    }\n                }\n            }\n            if (!q.isEmpty()) count++;\n        }\n        return fresh == 0 ? count : -1;\n    }\n}',
              link: 'https://leetcode.com/problems/rotting-oranges/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: 'b9d59687-2f3e-458b-9d65-6571c4e4575f',
              isFolder: false,
              name: 'SurroundedRegions.java',
              code: "class SurroundedRegions {\n    void dfs(char[][] board, int i, int j) {\n        if (i < 0\n        || i >= board.length\n        || j < 0\n        || j >= board[0].length\n        || board[i][j] != 'O') return;\n        board[i][j] = 'A';\n        dfs(board, i, j + 1);\n        dfs(board, i + 1, j);\n        dfs(board, i, j - 1);\n        dfs(board, i - 1, j);\n    }\n    public void solve(char[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n        for (int i = 0; i < n; i++) {\n            if (board[0][i] == 'O') dfs(board, 0, i);\n            if (board[m - 1][i] == 'O') dfs(board, m-1, i);\n        }\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') dfs(board, i, 0);\n            if (board[i][n-1] == 'O') dfs(board, i, n - 1);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(board[i][j] == 'O')\n                    board[i][j] = 'X';\n                else if(board[i][j] == 'A')\n                    board[i][j] = 'O';\n            }\n        }\n    }\n}",
              link: 'https://leetcode.com/problems/surrounded-regions/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '4caaf4c3-28ee-40b1-ab19-10813f245b57',
              isFolder: false,
              name: 'WallsAndGates.java',
              code: 'import java.util.*;\n\nclass WallsAndGates {\n    class Pair {\n        int row, col;\n        Pair (int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n    public boolean isInBounds(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public void islandsAndTreasure(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<Pair> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    q.add(new Pair(i, j));\n                }\n            }\n        }\n        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\n        int dist = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                for (int d = 0; d < 4; d++) {\n                    int r = p.row + dirs[d][0];\n                    int c = p.col + dirs[d][1];\n                    if (isInBounds(r,c,m,n) && grid[r][c] == Integer.MAX_VALUE) {\n                        grid[r][c] = dist;\n                        q.add(new Pair(r, c));\n                    }\n                }\n            }\n            dist += 1;\n        }\n    }\n}',
              link: 'https://neetcode.io/problems/islands-and-treasure',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '57a702f0-9cc1-4d57-9a4d-4c902d592c87',
              isFolder: false,
              name: 'WordLadder.java',
              code: "import java.util.*;\n\nclass WordLadder {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> hs = new HashSet<>(wordList);\n        Queue<String> q = new LinkedList<>();\n        q.add(beginWord);\n        hs.remove(beginWord);\n        int count = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                String s = q.poll();\n                if (s.equals(endWord)) return count;\n                for (int l = 0; l < s.length(); l++) {\n                    char old = s.charAt(l);\n                    char[] replaceArray = s.toCharArray();\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\n                        replaceArray[l] = ch;\n                        String str = new String(replaceArray);\n                        if (hs.contains(str)) {\n                            q.add(str);\n                            hs.remove(str);\n                        }\n                    }\n                    replaceArray[l] = old;\n                }\n            }\n            count++;\n        }\n        return 0;\n    }\n}",
              link: 'https://leetcode.com/problems/word-ladder/',
              notes: '',
              tags: ['Graph'],
            },
            {
              id: '257d5646-3f69-4834-baf7-ac0687c18f8d',
              isFolder: false,
              name: 'GasStation.java',
              code: 'class GasStation {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int start = 0, b = 0, d = 0;\n\t    for (int i = 0; i < gas.length; i++) {\n\t        b += gas[i] - cost[i];\n\t        if (b < 0) {\n\t            d += b;\n\t            start = i + 1;\n\t            b = 0;\n\t        }\n\t    }\n\t    return b + d >= 0 ? start : -1;\n    }\n}',
              link: 'https://leetcode.com/problems/gas-station/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: '2543d20f-2f8c-4499-a109-8f4897dba171',
              isFolder: false,
              name: 'HandofStraights.java',
              code: 'import java.util.*;\n\nclass HandofStraights {\n    public boolean isNStraightHand(int[] hand, int groupSize) {\n        if (hand.length < groupSize || hand.length % groupSize != 0) {\n            return false;\n        }\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int j : hand) {\n            hm.put(j, hm.getOrDefault(j, 0) + 1);\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (Map.Entry<Integer, Integer> m : hm.entrySet()) {\n            pq.add(m.getKey());\n        }\n\n        while (!pq.isEmpty()) {\n            int first = pq.peek();\n            for (int i = first; i < first + groupSize; i++) {\n                if (hm.containsKey(i)) {\n                    int count = hm.get(i) - 1;\n                    hm.put(i, count);\n                    if (count == 0) {\n                        if (i != pq.peek()) {\n                            return false;\n                        }\n                        pq.poll();\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}',
              link: 'https://leetcode.com/problems/hand-of-straights/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: 'f64b47fd-d0d1-47c3-bc74-39114122ab04',
              isFolder: false,
              name: 'JumpGame.java',
              code: 'class JumpGame {\n    public boolean canJump(int[] nums) {\n        int goal = nums.length - 1;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            if (goal <= (nums[i] + i)) {\n                goal = i;\n            }\n        }\n        return goal == 0;\n    }\n}',
              link: 'https://leetcode.com/problems/jump-game/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: 'ecf1c713-1956-4029-9503-d95f9bacdfcd',
              isFolder: false,
              name: 'JumpGame2.java',
              code: 'class JumpGame2 {\n    public int jump(int[] nums) {\n        int count = 0;\n        int l = 0, r = 0;\n        while (r < nums.length - 1) {\n            int max = 0;\n            for (int i = l; i <= r; i++) {\n                max = Math.max(max, i + nums[i]);\n            }\n            l = r + 1;\n            r = max;\n            count++;\n        }\n        return count;\n    }\n}',
              link: 'https://leetcode.com/problems/jump-game-ii/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: 'fc534575-c618-404f-bc44-21f28d415eb4',
              isFolder: false,
              name: 'MaximumSubarray.java',
              code: 'class MaximumSubarray {\n    public int maxSubArray(int[] nums) {\n        int sum = 0, maxSum = nums[0];\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            maxSum = Math.max(maxSum, sum);\n            if (sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxSum;\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-subarray/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: '952434b7-bc8d-488a-be70-1c6eab6ad660',
              isFolder: false,
              name: 'MergeTripletstoFormTargetTriplet.java',
              code: 'class MergeTripletstoFormTargetTriplet {\n    public boolean mergeTriplets(int[][] t, int[] goal) {\n        boolean a = false, b = false, c = false;\n        for (int i = 0; i < t.length; i++) {\n            if (t[i][0] == goal[0] && t[i][1] <= goal[1] && t[i][2] <= goal[2]) {\n                a = true;\n            }\n            if (t[i][1] == goal[1] && t[i][0] <= goal[0] && t[i][2] <= goal[2]) {\n                b = true;\n            }\n            if (t[i][2] == goal[2] && t[i][0] <= goal[0] && t[i][1] <= goal[1]) {\n                c = true;\n            }\n            if (a==b && b==c && c==true) return true;\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/merge-triplets-to-form-target-triplet/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: 'edc31a68-1f64-4106-b780-0ef471157873',
              isFolder: false,
              name: 'PartitionLabels.java',
              code: "import java.util.*;\n\nclass PartitionLabels {\n    public List<Integer> partitionLabels(String s) {\n        char[] sChar = s.toCharArray();\n        int n = sChar.length;\n        int[] map = new int[26];\n        for (int i = 0; i < n; i++) {\n            map[sChar[i] - 'a'] = i;\n        }\n        List<Integer> ans = new ArrayList<>();\n        int end = 0, size = 0;\n        for (int i = 0; i < n; i++) {\n            size++;\n            end = Math.max(map[sChar[i] - 'a'], end);\n            if (i == end) {\n                ans.add(size);\n                size = 0;\n            }\n        }\n        return ans;\n    }\n}",
              link: 'https://leetcode.com/problems/partition-labels/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: '91617a2f-3d74-4e26-b76f-e430af680006',
              isFolder: false,
              name: 'ValidParenthesisString.java',
              code: "class ValidParenthesisString {\n    public boolean checkValidString(String s) {\n        int leftMin = 0, leftMax = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') {\n                leftMin++;\n                leftMax++;\n            } else if (ch == ')') {\n                leftMin--;\n                leftMax--;\n            } else {\n                leftMin--;\n                leftMax++;\n            }\n            if (leftMax < 0) return false;\n            if (leftMin < 0) leftMin = 0;\n        }\n        return leftMin == 0;\n    }\n}",
              link: 'https://leetcode.com/problems/valid-parenthesis-string/',
              notes: '',
              tags: ['Greedy'],
            },
            {
              id: '48846055-54da-4b62-b606-f58808803de5',
              isFolder: false,
              name: 'DesignTwitter.java',
              code: 'import java.util.*;\n\nclass DesignTwitter {\n    static class Tweet {\n        int userId;\n        int tweetId;\n        int tweetFrequency;\n        Tweet(int uId, int tId, int f) {\n            this.userId = uId;\n            this.tweetId = tId;\n            this.tweetFrequency = f;\n        }\n    }\n\n    HashMap<Integer, HashSet<Integer>> followMap;\n    int frequency = 0;\n    PriorityQueue<Tweet> pq;\n\n    public DesignTwitter() {\n        followMap = new HashMap<>();\n        pq = new PriorityQueue<>((a, b) -> b.tweetFrequency - a.tweetFrequency);\n    }\n\n    public void postTweet(int userId, int tweetId) {\n        pq.add(new Tweet(userId, tweetId, frequency));\n        frequency++;\n    }\n\n    public List<Integer> getNewsFeed(int userId) {\n        Deque<Tweet> q = new ArrayDeque<>();\n        List<Integer> op = new ArrayList<>();\n        int count = 10;\n        while (count > 0 && pq.size() > 0) {\n            Tweet t = pq.poll();\n            q.add(t);\n            if (\n            userId == t.userId ||\n            (followMap.containsKey(userId) && followMap.get(userId).contains(t.userId))\n            ) {\n                count--;\n                op.add(t.tweetId);\n            }\n        }\n        while (!q.isEmpty()) pq.add(q.poll());\n        return op;\n    }\n\n    public void follow(int followerId, int followeeId) {\n        if (!followMap.containsKey(followerId)) {\n            followMap.put(followerId, new HashSet<>());\n        }\n        followMap.get(followerId).add(followeeId);\n    }\n\n    public void unfollow(int followerId, int followeeId) {\n        if (followMap.containsKey(followerId)) {\n            followMap.get(followerId).remove(followeeId);\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/design-twitter/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '27d739bb-49b1-4cd8-8ce6-5e8d30dc0e4d',
              isFolder: false,
              name: 'KClosestPointstoOrigin.java',
              code: 'import java.util.*;\n\nclass KClosestPointstoOrigin {\n    static class Pair {\n        int key;\n        int x, y;\n\n        Pair(int coor_x, int coor_y, int k) {\n            this.key = k;\n            this.x = coor_x;\n            this.y = coor_y;\n        }\n    }\n\n    public static int[][] kClosest(int[][] points, int k) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.key - a.key);\n        for (int[] point : points) {\n            int x = point[0];\n            int y = point[1];\n            pq.add(new Pair(x, y, x * x + y * y));\n            if (pq.size() > k) pq.poll();\n        }\n        int[][] ans = new int[pq.size()][2];\n        int idx = 0;\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            ans[idx++] = new int[]{p.x, p.y};\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/k-closest-points-to-origin/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '0eaa1d88-be73-4bc1-8552-6f41402959ae',
              isFolder: false,
              name: 'KthLargest.java',
              code: 'import java.util.*;\n\nclass KthLargest {\n    PriorityQueue<Integer> pq;\n    int size;\n    public KthLargest(int k, int[] nums) {\n        pq = new PriorityQueue<>();\n        size = k;\n        for (int num: nums) {\n            pq.add(num);\n            if (pq.size() > k) pq.poll();\n        }\n    }\n\n    public int add(int val) {\n        pq.add(val);\n        if (pq.size() > size) pq.poll();\n        return pq.peek();\n    }\n}',
              link: 'https://leetcode.com/problems/kth-largest-element-in-a-stream/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '74f301df-ecf1-4ba8-ba98-36271bc6e6a9',
              isFolder: false,
              name: 'KthLargestElementInAnArray.java',
              code: 'import java.util.*;\n\nclass KthLargestElementInAnArray {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i = 0; i < nums.length; i++) {\n            pq.add(nums[i]);\n            if (pq.size() > k) pq.poll();\n        }\n        return pq.poll();\n    }\n}',
              link: 'https://leetcode.com/problems/kth-largest-element-in-an-array/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '9499d3ad-6ef5-4ef6-b1b6-105e79a66553',
              isFolder: false,
              name: 'LastStoneWeight.java',
              code: 'import java.util.*;\n\nclass LastStoneWeight {\n    public int lastStoneWeight(int[] stones) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\n        for (int stone:stones) pq.add(stone);\n        while (pq.size() > 1) {\n            int f = pq.poll();\n            int s = pq.poll();\n            if (f != s) pq.add(Math.abs(f - s));\n        }\n        return pq.size() == 1 ? pq.poll() : 0;\n    }\n}',
              link: 'https://leetcode.com/problems/last-stone-weight/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '301df7c2-3688-47c7-8104-3c99ad412ff1',
              isFolder: false,
              name: 'MedianFinder.java',
              code: 'import java.util.*;\n\nclass MedianFinder {\n    PriorityQueue<Integer> small;\n    PriorityQueue<Integer> large;\n    public MedianFinder() {\n        small = new PriorityQueue<>((a,b) -> b - a);\n        large = new PriorityQueue<>();\n    }\n\n    public void addNum(int num) {\n        if (num < findMedian()) small.add(num);\n        else large.add(num);\n        if (large.size() - small.size() > 1) small.add(large.poll());\n        else if (small.size() - large.size() > 1) large.add(small.poll());\n    }\n\n    public double findMedian() {\n        if (small.isEmpty() && large.isEmpty()) return 0;\n        if (large.size() == small.size())\n            return (large.peek() + small.peek())/2.0;\n        if (large.size() > small.size())\n            return large.peek();\n        return small.peek();\n    }\n}',
              link: 'https://leetcode.com/problems/find-median-from-data-stream/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '490b68d5-39d0-49a2-8e17-8b15dd378727',
              isFolder: false,
              name: 'TaskScheduler.java',
              code: 'import java.util.*;\n\nclass TaskScheduler {\n    static class Pair {\n        int val, time;\n        Pair(int v, int t) {\n            this.val = v;\n            this.time = t;\n        }\n    }\n\n    public int leastInterval(char[] tasks, int n) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int task : tasks) {\n            hm.put(task, hm.getOrDefault(task, 0) + 1);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for (Map.Entry<Integer, Integer> m: hm.entrySet()) {\n            pq.add(m.getValue());\n        }\n        Queue<Pair> q = new LinkedList<>();\n        int time = 0;\n        while (!pq.isEmpty() || !q.isEmpty()) {\n            time++;\n            if (!pq.isEmpty()) {\n                int val = pq.poll() - 1;\n                if (val > 0) q.add(new Pair(val, time + n));\n            }\n            if (!q.isEmpty() && q.peek().time <= time) {\n                pq.add(q.poll().val);\n            }\n        }\n        return time;\n    }\n}',
              link: 'https://leetcode.com/problems/task-scheduler/',
              notes: '',
              tags: ['Heap - PriorityQueue'],
            },
            {
              id: '51193bd5-0860-4f87-b226-04f5e1538b91',
              isFolder: false,
              name: 'InsertInterval.java',
              code: 'import java.util.*;\n\nclass InsertInterval {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> list = new ArrayList<>();\n        for (int[] interval: intervals) {\n            if (newInterval == null || interval[1] < newInterval[0]) {\n                list.add(interval);\n            } else if (interval[0] > newInterval[1]) {\n                list.add(newInterval);\n                list.add(interval);\n                newInterval = null;\n            } else {\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\n            }\n        }\n        if (newInterval != null) list.add(newInterval);\n        return list.toArray(new int[list.size()][]);\n    }\n}',
              link: 'https://leetcode.com/problems/insert-interval/',
              notes: '',
              tags: ['Intervals'],
            },
            {
              id: '15c22fe4-0ae2-4149-8b75-a4e3989940e5',
              isFolder: false,
              name: 'MeetingRooms.java',
              code: 'import java.util.*;\nclass MeetingRooms {\n    public boolean canAttendMeetings(List<Interval> intervals) {\n        int n = intervals.size();\n        if (n == 0) return true;\n        Collections.sort(intervals, (a,b) -> a.end - b.end);\n        int end = intervals.get(0).end;\n        for (int i = 1; i < n; i++) {\n            if (end > intervals.get(i).start) return false;\n            else {\n                end = intervals.get(i).end;\n            }\n        }\n        return true;\n    }\n}',
              link: 'https://neetcode.io/problems/meeting-schedule',
              notes: '',
              tags: ['Intervals'],
            },
            {
              id: '6c153c36-003d-43f9-a2d1-a1736e1c5370',
              isFolder: false,
              name: 'MeetingRooms2.java',
              code: 'import java.util.*;\n\nclass MeetingRooms2 {\n    public int minMeetingRooms(List<Interval> intervals) {\n        int n = intervals.size();\n        if (n <= 1) return n;\n        List<Integer> start = new ArrayList<>();\n        List<Integer> end = new ArrayList<>();\n        for (Interval i : intervals) {\n            start.add(i.start);\n            end.add(i.end);\n        }\n        Collections.sort(start);\n        Collections.sort(end);\n        int days = 0;\n        int i = 0, j = 0;\n        int count = 0;\n        while (i < n && j < n) {\n            int s = start.get(i);\n            int e = end.get(j);\n            if (s < e) {\n                count++;\n                i++;\n            } else {\n                count--;\n                j++;\n            }\n            days = Math.max(count, days);\n        }\n        return days;\n    }\n}',
              link: 'https://neetcode.io/problems/meeting-schedule-ii',
              notes: '',
              tags: ['Intervals'],
            },
            {
              id: '1576514c-4fc1-4748-ae02-89d7cfa88de8',
              isFolder: false,
              name: 'MergeIntervals.java',
              code: 'import java.util.*;\n\nclass MergeIntervals {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        int start = intervals[0][0], end = intervals[0][1];\n        List<int[]> list = new ArrayList<>();\n        for (int[] interval : intervals) {\n            if (interval[0] <= end) {\n                end = Math.max(end, interval[1]);\n            } else {\n                list.add(new int[] {start, end});\n                start = interval[0];\n                end = interval[1];\n            }\n        }\n        list.add(new int[] {start, end});\n        return list.toArray(new int[list.size()][]);\n    }\n}',
              link: 'https://leetcode.com/problems/merge-intervals/',
              notes: '',
              tags: ['Intervals'],
            },
            {
              id: 'f7586796-e08a-4013-a640-2afb361c6583',
              isFolder: false,
              name: 'MinimumIntervaltoIncludeEachQuery.java',
              code: 'import java.util.*;\n\nclass MinimumIntervaltoIncludeEachQuery {\n    public int[] minInterval(int[][] intervals, int[] queries) {\n        int n = queries.length;\n        int[] copyQueries = Arrays.copyOf(queries, n);\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        Arrays.sort(queries);\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);\n        int j = 0;\n        for (int query : queries) {\n            while (j < intervals.length && intervals[j][0] <= query) {\n                pq.add(new int[]{intervals[j][1] - intervals[j][0] + 1, intervals[j][1]});\n                j++;\n            }\n            while (!pq.isEmpty() && pq.peek()[1] < query) pq.poll();\n\n            if (!pq.isEmpty()) {\n                hm.put(query, pq.peek()[0]);\n            }\n        }\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++) {\n            ans[i] = hm.getOrDefault(copyQueries[i], -1);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/minimum-interval-to-include-each-query/',
              notes: '',
              tags: ['Intervals'],
            },
            {
              id: '0fab8380-ea69-4d70-8027-518bf6652927',
              isFolder: false,
              name: 'NonOverlappingIntervals.java',
              code: 'import java.util.*;\n\nclass NonOverlappingIntervals {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        int count = 0;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.length; i++) {\n            int[] interval = intervals[i];\n            if (end <= interval[0]) {\n                end = interval[1];\n            } else {\n                count++;\n                end = Math.min(end, interval[1]);\n            }\n        }\n        return count;\n    }\n}',
              link: 'https://leetcode.com/problems/non-overlapping-intervals/',
              notes: '',
              tags: ['Intervals'],
            },
            {
              id: '4829b24f-cdae-4550-b4fb-3bf705bb092c',
              isFolder: false,
              name: 'AddTwoNumbers.java',
              code: 'public class AddTwoNumbers {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode sum = new ListNode(0);\n        ListNode sumHead = sum;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int d1 = l1 != null ? l1.val : 0;\n            int d2 = l2 != null ? l2.val : 0;\n            carry += d1 + d2;\n            sum.next = new ListNode(carry%10);\n            sum = sum.next;\n            carry /= 10;\n            l1 = l1 != null ? l1.next : null;\n            l2 = l2 != null ? l2.next : null;\n        }\n        return sumHead.next;\n    }\n}',
              link: 'https://leetcode.com/problems/add-two-numbers/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '2a8cb9f2-67ed-4028-8018-106d4bb5e9ce',
              isFolder: false,
              name: 'CopyListWithRandomPointer.java',
              code: 'public class CopyListWithRandomPointer {\n    public Node copyRandomList(Node head) {\n        // Optimised solution\n        if (head == null) return null;\n        // Step 1: Create a new linked list in between the nodes of current LL\n        Node curr = head;\n        while (curr != null) {\n            Node newNode = new Node(curr.val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            curr = newNode.next;\n        }\n        // Step 2: Assign random pointers to the deep copy\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n        // Step 3: Separate both the linked list and return Head\n        Node copy = head.next;\n        Node temp = copy;\n        curr = head;\n        while (temp != null) {\n            curr.next = temp.next;\n            curr = curr.next;\n            if (curr == null) break;\n            temp.next = curr.next;\n            temp = temp.next;\n        }\n        return copy;\n    }\n}',
              link: 'https://leetcode.com/problems/copy-list-with-random-pointer/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '56bf84ea-c269-40e4-aade-63f6becd5ce7',
              isFolder: false,
              name: 'FindTheDuplicateNumber.java',
              code: "public class FindTheDuplicateNumber {\n    public int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
              link: 'https://leetcode.com/problems/find-the-duplicate-number/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '0aaaf880-09ee-4baa-96ac-95962876cd52',
              isFolder: false,
              name: 'LinkedListCycle.java',
              code: 'public class LinkedListCycle {\n    public boolean hasCycle(ListNode head) {\n        // Brute force\n        // HashSet<ListNode> hs = new HashSet<>();\n        // ListNode curr = head;\n        // while (curr != null) {\n        //     if (hs.contains(curr)) return true;\n        //     hs.add(curr);\n        //     curr = curr.next;\n        // }\n        // return false;\n\n        // Optimised\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/linked-list-cycle/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'd3a343e9-6699-424f-bafe-44c56b87bb72',
              isFolder: false,
              name: 'LRUCache.java',
              code: 'import java.util.*;\n\nclass LRUCache {\n    static class Node {\n        int key;\n        int value;\n        Node next;\n        Node prev;\n\n        Node(int key, int value) {\n            this.next = null;\n            this.prev = null;\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    Node head = new Node(-1, -1);\n    Node tail = new Node(-1, -1);\n    int capacity;\n    HashMap<Integer, Node> hm = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (this.hm.containsKey(key)) {\n            Node temp = this.hm.get(key);\n            delete(temp);\n            insert(temp);\n            return temp.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (this.hm.containsKey(key)) delete(this.hm.get(key));\n        if (this.hm.size() == this.capacity) delete(this.tail.prev);\n        insert(new Node(key, value));\n    }\n\n    public void delete(Node node) {\n        this.hm.remove(node.key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    public void insert(Node node) {\n        this.hm.put(node.key, node);\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n}',
              link: 'https://leetcode.com/problems/lru-cache/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '5befbdca-729d-46e4-9ac4-96901c6db604',
              isFolder: false,
              name: 'MergeKSortedLists.java',
              code: 'public class MergeKSortedLists {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        temp.next = left != null ? left : right;\n        return tHead.next;\n    }\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += interval*2) {\n                lists[i] = merge(lists[i], lists[i+interval]);\n            }\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
              link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'becb45db-46b3-4151-9e03-7316a78022ea',
              isFolder: false,
              name: 'MergeTwoSortedLists.java',
              code: 'public class MergeTwoSortedLists {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        } else {\n            temp.next = right;\n        }\n        return tHead.next;\n    }\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        return merge(list1, list2);\n    }\n}',
              link: 'https://leetcode.com/problems/merge-two-sorted-lists/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '21dbd8b2-6689-41bb-afae-f9f9313a2f42',
              isFolder: false,
              name: 'RemoveNthNodeFromEndOfList.java',
              code: 'public class RemoveNthNodeFromEndOfList {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Optimised approach\n        ListNode start = new ListNode(0, head);\n        ListNode slow = start;\n        ListNode fast = start;\n        for (int i = 0; i < n; i++) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return start.next;\n    }\n}',
              link: 'https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'ac711a15-2ef8-400c-9e8b-159a0628a866',
              isFolder: false,
              name: 'ReorderList.java',
              code: 'public class ReorderList {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            temp.next = left;\n            left = left.next;\n            temp = temp.next;\n            temp.next = right;\n            right = right.next;\n            temp = temp.next;\n        }\n        temp.next = left != null ? left : right;\n        return tHead.next;\n    }\n\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n        slow = revLL(slow);\n        head = merge(head, slow);\n    }\n}',
              link: 'https://leetcode.com/problems/reorder-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '01bb8e15-43fd-4404-9b3b-022065c41ded',
              isFolder: false,
              name: 'ReverseLinkedList.java',
              code: 'public class ReverseLinkedList {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-linked-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'a7b6a940-0706-416a-ad08-d9a75292f1fe',
              isFolder: false,
              name: 'ReverseNodesInKGroups.java',
              code: 'public class ReverseNodesInKGroups {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = head;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head, start = head, prev = head;\n        ListNode newHead = new ListNode(0, head);\n        ListNode temp = newHead;\n\n        while (curr != null) {\n            for (int i = 1; i <= k; i++) {\n                if (curr.next == null && i < k) return newHead.next;\n                prev = curr;\n                curr = curr.next;\n            }\n            prev.next = null;\n            temp.next = revLL(start);\n            start.next = curr;\n            temp = start;\n            start = curr;\n        }\n        return newHead.next;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-nodes-in-k-group/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'a1753157-2df1-491e-919d-008186654bf0',
              isFolder: false,
              name: 'DetectSquares.java',
              code: 'import java.util.*;\n\nclass DetectSquares {\n    int[][] count;\n    List<int[]> points;\n    public DetectSquares() {\n        count = new int[1001][1001];\n        points = new ArrayList<>();\n    }\n\n    public void add(int[] point) {\n        count[point[0]][point[1]]++;\n        points.add(point);\n    }\n\n    public int count(int[] point) {\n        int x1 = point[0], y1 = point[1];\n        int ans = 0;\n        for (int[] p: points) {\n            int x2 = p[0], y2 = p[1];\n            if (Math.abs(x1 - x2) == 0 || Math.abs(x1 - x2) != Math.abs(y1 - y2)) {\n                continue;\n            }\n            ans += count[x1][y2] * count[x2][y1];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/detect-squares/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: '24f1055a-a40a-4c90-8eb2-ea5356d411eb',
              isFolder: false,
              name: 'HappyNumber.java',
              code: 'class HappyNumber {\n    public static int digitSquareSum(int n) {\n        int sum = 0;\n        while (n != 0) {\n            int rem = n % 10;\n            sum += rem*rem;\n            n = n / 10;\n        }\n        return sum;\n    }\n    public boolean isHappy(int n) {\n        // Brute force approach\n        // HashSet<Integer> hs = new HashSet<>();\n        // int digitSq = n;\n        // while (digitSq != 1) {\n        //     digitSq = digitSquareSum(digitSq);\n        //     if (hs.contains(digitSq)) {\n        //         return false;\n        //     } else {\n        //         hs.add(digitSq);\n        //     }\n        // }\n        // return true;\n\n        int slow = n, fast = n;\n        do {\n            slow = digitSquareSum(slow);\n            fast = digitSquareSum(digitSquareSum(fast));\n        } while (slow != fast);\n        return slow == 1;\n    }\n}',
              link: 'https://leetcode.com/problems/happy-number/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: 'ac855c0f-03d5-4702-a4d6-a0cae4007d94',
              isFolder: false,
              name: 'MultiplyStrings.java',
              code: "class MultiplyStrings {\n    public String multiply(String num1, String num2) {\n        int n = num1.length();\n        int m = num2.length();\n        if (n == 1 && num1.charAt(0) == '0' || m == 1 && num2.charAt(0) == '0') return \"0\";\n        int[] arr = new int[n+m];\n        num1 = new StringBuilder(num1).reverse().toString();\n        num2 = new StringBuilder(num2).reverse().toString();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int digit = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                arr[i + j] += digit;\n                arr[i + j + 1] += arr[i + j] / 10;\n                arr[i + j] = arr[i + j] % 10;\n            }\n        }\n        int start = 0, end = arr.length - 1;\n        while (start < end) {\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n\n        int startIndex = 0;\n        while (startIndex < arr.length) {\n            if (arr[startIndex] != 0) {\n                break;\n            }\n            startIndex++;\n        }\n\n        StringBuilder buildResponse = new StringBuilder();\n        for (int i = startIndex; i < arr.length; i++) {\n            buildResponse.append(arr[i]);\n        }\n\n        return buildResponse.toString();\n    }\n}",
              link: 'https://leetcode.com/problems/multiply-strings/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: 'a0e944af-dc9a-4e7e-a78b-ae54fdf50033',
              isFolder: false,
              name: 'PlusOne.java',
              code: 'class PlusOne {\n    public int[] plusOne(int[] digits) {\n        int len = digits.length;\n        // If last digit is 9\n        // Last digit 9 means make it zero and add 1 to place in left\n        for(int i=len -1; i>=0; i--){\n            if(digits[i]!=9){\n                digits[i]++;\n                return digits;\n            }else{\n                digits[i] = 0;\n            }\n        }\n        // If this part of code is running, it only means one thing\n        // that all the digits were 9, so make new arr of length = len + 1\n        // and set 0th index to 1 [999 + 1 = 1000]\n        int[] ans = new int[len +1];\n        ans[0] = 1;\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/plus-one/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: 'f82c1c48-cb34-4cf0-9b0a-2d1672a37dc2',
              isFolder: false,
              name: 'PowXtoN.java',
              code: 'class PowXtoN {\n    double solve(double x, int n) {\n        if (n == 0) return 1;\n        if (n == 1) return x;\n        double r = solve(x, n/2);\n        return (n % 2 == 0) ? r*r : r*x*r;\n    }\n    public double myPow(double x, int n) {\n        boolean isNegative = n < 0;\n        double pow = solve(x, Math.abs(n));\n        return isNegative ? 1/pow : pow;\n    }\n}',
              link: 'https://leetcode.com/problems/powx-n/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: 'bcfe8f6f-e8a6-47c2-89fa-c0e258e185d5',
              isFolder: false,
              name: 'RotateImage.java',
              code: 'class RotateImage {\n    public void reverse(int[] arr) {\n        int start = 0, end = arr.length - 1;\n        while (start < end) {\n            int temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n\n    public void rotate(int[][] matrix) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = i; j < matrix[i].length; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        for (int i = 0; i < matrix.length; i++) {\n            reverse(matrix[i]);\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/rotate-image/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: '47425778-2089-4f36-94f6-743570df3ec3',
              isFolder: false,
              name: 'SetMatrixZeroes.java',
              code: 'class SetMatrixZeroes {\n    public void setZeroes(int[][] M) {\n        int colZero = 1;\n        for (int i = 0; i < M.length; i++) {\n            if (M[i][0] == 0) {\n                colZero = 0;\n            }\n            for (int j = 1; j < M[i].length; j++) {\n                if (M[i][j] == 0) {\n                    M[i][0] = 0;\n                    M[0][j] = 0;\n                }\n            }\n        }\n        for (int i = M.length - 1; i >= 0; i--) {\n            for (int j = M[i].length - 1; j > 0; j--) {\n                if (M[i][0] == 0 || M[0][j] == 0) {\n                    M[i][j] = 0;\n                }\n            }\n            if (colZero == 0) {\n                M[i][0] = 0;\n            }\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/set-matrix-zeroes/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: '1905bb0c-27f0-4384-9cc2-a95b948577aa',
              isFolder: false,
              name: 'SpiralMatrix.java',
              code: 'import java.util.*;\n\nclass SpiralMatrix {\n    public List<Integer> spiralOrder(int[][] M) {\n        int rowStart = 0;\n        int rowEnd = M.length - 1;\n        int colStart = 0;\n        int colEnd = M[0].length - 1;\n        List<Integer> ans = new ArrayList<>();\n        while (rowStart <= rowEnd && colStart <= colEnd) {\n            // Movement: LR\n            for  (int i = colStart; i <= colEnd; i++) {\n                ans.add(M[rowStart][i]);\n            }\n            rowStart++;\n            // Movement: TB\n            for  (int j = rowStart; j <= rowEnd; j++) {\n                ans.add(M[j][colEnd]);\n            }\n            colEnd--;\n            // Check\n            if (ans.size() == M.length * M[0].length) break;\n            // Movement: RL\n            for  (int k = colEnd; k >= colStart; k--) {\n                ans.add(M[rowEnd][k]);\n            }\n            rowEnd--;\n            // Movement: BT\n            for  (int l = rowEnd; l >= rowStart; l--) {\n                ans.add(M[l][colStart]);\n            }\n            colStart++;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/spiral-matrix/',
              notes: '',
              tags: ['Math & Geometry'],
            },
            {
              id: 'babe9e45-17de-4147-a2a6-58bf6a16cbf5',
              isFolder: false,
              name: 'BestTimeToBuyAndSellStock.java',
              code: 'import java.util.*;\npublic class BestTimeToBuyAndSellStock {\n    public int maxProfit(int[] prices) {\n        int minVal = prices[0], maxDiff = 0;\n        for (int i = 1; i < prices.length; i++) {\n            minVal = Math.min(minVal, prices[i]);\n            maxDiff = Math.max(maxDiff, prices[i] - minVal);\n        }\n        return maxDiff;\n    }\n}',
              link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock/',
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: '33c3ceeb-d1f6-4b1a-866a-56f24b1b0f2c',
              isFolder: false,
              name: 'LongestRepeatingCharacterReplacement.java',
              code: "import java.util.*;\n\npublic class LongestRepeatingCharacterReplacement {\n    public static int getMaxFrequency(int[] arr) {\n        int maxFrequency = 0;\n        for (int i = 0; i < 26; i++)\n            maxFrequency = Math.max(maxFrequency, arr[i]);\n        return maxFrequency;\n    }\n    public int characterReplacement(String s, int k) {\n        int[] bucket = new int[26];\n        int i = 0, j = 0, maxLength = 0;\n        while (j < s.length()) {\n            int idx = s.charAt(j) - 'A';\n            bucket[idx]++;\n            while (j-i+1 - getMaxFrequency(bucket) > k)\n                bucket[s.charAt(i++) - 'A']--;\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}",
              link: 'https://leetcode.com/problems/longest-repeating-character-replacement/',
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: 'd1855410-6a80-4bb5-9fa7-ca26aba9c522',
              isFolder: false,
              name: 'LongestSubstringWithoutRepeatingCharacters.java',
              code: 'import java.util.*;\n\npublic class LongestSubstringWithoutRepeatingCharacters {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character, Integer> hm = new HashMap<>();\n        int i = 0, j = 0, maxLength = 0;\n        while (j < s.length()) {\n            char ch = s.charAt(j);\n            hm.put(ch, hm.getOrDefault(ch, 0) + 1);\n            while (hm.size() < j - i + 1) {\n                char ch2 = s.charAt(i);\n                int c = hm.get(ch2);\n                if (c == 1) hm.remove(ch2);\n                else hm.put(ch2, c - 1);\n                i++;\n            }\n            if (hm.size() == j - i + 1)\n                maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}',
              link: 'https://leetcode.com/problems/longest-substring-without-repeating-characters/',
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: '1634c207-1c82-42af-9956-61cd9990085e',
              isFolder: false,
              name: 'MinimumWindowSubstring.java',
              code: 'import java.util.*;\n\npublic class MinimumWindowSubstring {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < t.length(); i++) {\n            char ch = t.charAt(i);\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n        }\n        int start = 0, subStart = 0, minLength = s.length()+1, match = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char ch1 = s.charAt(end);\n            if (map.containsKey(ch1)) {\n                map.put(ch1, map.get(ch1) - 1);\n                if (map.get(ch1) == 0) match++;\n            }\n            while (match == map.size()) {\n                int size = end - start + 1;\n                if (minLength > size) {\n                    minLength = size;\n                    subStart = start;\n                }\n                char ch2 = s.charAt(start);\n                if (map.containsKey(ch2)) {\n                    map.put(ch2, map.get(ch2) + 1);\n                    if (map.get(ch2) == 1) match--;\n                }\n                start++;\n            }\n        }\n        return minLength > s.length() ? "" : s.substring(subStart, subStart + minLength);\n    }\n}',
              link: 'https://leetcode.com/problems/minimum-window-substring/',
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: 'e108f681-f15a-4112-917d-6833d3f3519c',
              isFolder: false,
              name: 'PermutationInString.java',
              code: "import java.util.*;\n\npublic class PermutationInString {\n    public static boolean chk(int[] bucket) {\n        int count = 0;\n        for (int element : bucket) {\n            count += element;\n            if (element < 0) return false;\n        }\n        return count == 0;\n    }\n    public boolean checkInclusion(String s1, String s2) {\n        int[] bucket = new int[26];\n        for (int x = 0; x < s1.length(); x++) {\n            bucket[s1.charAt(x) - 'a']++;\n        }\n        int i = 0, j = 0, k = s1.length();\n        while (j < s2.length()) {\n            int idx = s2.charAt(j) - 'a';\n            bucket[idx]--;\n            if (j - i + 1 == k) {\n                if (chk(bucket)) return true;\n                int idx2 = s2.charAt(i) - 'a';\n                bucket[idx2]++;\n                i++;\n            }\n            j++;\n        }\n        return false;\n    }\n}",
              link: 'https://leetcode.com/problems/permutation-in-string/',
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: '1a239f3e-077b-45b5-a326-bd144de7b9ea',
              isFolder: false,
              name: 'SlidingWindowMaximum.java',
              code: 'import java.util.*;\n\npublic class SlidingWindowMaximum {\n    public int[] maxSlidingWindow(int[] arr, int k) {\n        int n = arr.length;\n        int[] ans = new int[n - k + 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        int i = 0;\n        for (int j = 0; j < n; j++) {\n            if (!dq.isEmpty() && i > dq.peekFirst()) dq.pollFirst();\n            while (!dq.isEmpty() && arr[j] > arr[dq.peekLast()]) dq.pollLast();\n            dq.offerLast(j);\n            if (j - i + 1 == k) {\n                ans[i++] = arr[dq.peekFirst()];\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/sliding-window-maximum/',
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: '066a5c70-26ed-4a4a-a983-424ac8d08e2d',
              isFolder: false,
              name: 'CarFleet.java',
              code: 'import java.util.*;\npublic class CarFleet {\n    static class Pair {\n        int position;\n        int speed;\n\n        Pair(int p, int s) {\n            this.position = p;\n            this.speed = s;\n        }\n\n        @Override\n        public String toString() {\n            return "Pair{" + "P=" + position + ", S=" + speed + \'}\';\n        }\n    }\n\n    public static int carFleet(int target, int[] position, int[] speed) {\n        Pair[] arr = new Pair[speed.length];\n        for (int i = 0; i < speed.length; i++) {\n            arr[i] = new Pair(position[i], speed[i]);\n        }\n        Arrays.sort(arr, (a, b) -> b.position - a.position);\n        Stack<Double> st = new Stack<>();\n        for (Pair pair : arr) {\n            double curr = (double) (target - pair.position) / pair.speed;\n            if (st.isEmpty() || curr > st.peek()) {\n                st.push(curr);\n            }\n        }\n        return st.size();\n    }\n\n    public static void main(String[] args) {\n        int[] position = {10, 8, 0, 5, 3};\n        int[] speed = {2, 4, 1, 1, 3};\n        System.out.println(carFleet(12, position, speed));\n    }\n}',
              link: 'https://leetcode.com/problems/car-fleet/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '64a996f7-25ab-4d4a-bac2-1cb16d5b4626',
              isFolder: false,
              name: 'DailyTemperatures.java',
              code: 'import java.util.*;\n\npublic class DailyTemperatures {\n    public int[] dailyTemperatures(int[] temp) {\n        Stack<Integer> stack = new Stack<>();\n        int[] ans = new int[temp.length];\n        for (int i = 0; i < temp.length; i++) {\n            while (!stack.isEmpty() && temp[stack.peek()] < temp[i]) {\n                int val = stack.pop();\n                ans[val] = i - val;\n            }\n            stack.push(i);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/daily-temperatures/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '1ba6ca31-1221-4d38-8212-0d4e4928827f',
              isFolder: false,
              name: 'EvaluateReversePolishNotation.java',
              code: 'import java.util.*;\n\npublic class EvaluateReversePolishNotation {\n    public static int operate(String op, int first, int second) {\n        if (op.equals("-")) return second - first;\n        if (op.equals("*")) return second * first;\n        if (op.equals("/")) return second / first;\n        return second + first; // op = +\n    }\n    public int evalRPN(String[] tokens) {\n        // Basically secondPop operation firstPop\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/"))\n                stack.push(operate(token, stack.pop(), stack.pop()));\n            else\n                stack.add(Integer.parseInt(token));\n        }\n        return stack.pop();\n    }\n}',
              link: 'https://leetcode.com/problems/evaluate-reverse-polish-notation/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: 'b0dc8d88-08dc-429f-8f27-e11ccf6783df',
              isFolder: false,
              name: 'GenerateParentheses.java',
              code: 'import java.util.*;\n\npublic class GenerateParentheses {\n    public static void solve(int n, List<String> ans, String s, int closeCount, int openCount) {\n        if (openCount == n && closeCount == n) {\n            ans.add(s);\n            return;\n        }\n        if (openCount < n) solve(n, ans, s + "(", closeCount, openCount + 1);\n        if (closeCount < openCount) solve(n, ans, s + ")", closeCount + 1, openCount);\n    }\n    public List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList<>();\n        solve(n, ans, "", 0, 0);\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/generate-parentheses/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: 'e9c60313-17a7-43fb-a417-f543080e6b09',
              isFolder: false,
              name: 'LargestRectangleInHistogram.java',
              code: 'import java.util.*;\n\npublic class LargestRectangleInHistogram {\n    public static int[] getPSE(int[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n\n    public static int[] getNSE(int[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = n;\n        return ans;\n    }\n\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        int[] nse = getNSE(heights, n), pse = getPSE(heights, n);\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++)\n            maxArea = Math.max(maxArea, (nse[i] - pse[i] - 1) * heights[i]);\n        return maxArea;\n    }\n}',
              link: 'https://leetcode.com/problems/largest-rectangle-in-histogram/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '141a7475-304b-4ba5-bb87-94b9b5e01d73',
              isFolder: false,
              name: 'MinStack.java',
              code: 'import java.util.*;\n\nclass MinStack {\n    Stack<Integer> stack;\n    Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        int minValue = minStack.empty() ? val : Math.min(minStack.peek(), val);\n        minStack.push(minValue);\n    }\n\n    public void pop() {\n        minStack.pop();\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n\n    public static void main(String[] args) {\n//        ["MinStack","push","push","push","top","pop","getMin","pop","getMin","pop","push","top","getMin","push","top","getMin","pop","getMin"]\n//        [[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\n        MinStack st = new MinStack();\n        st.push(2147483646);\n        st.push(2147483646);\n        st.push(2147483647);\n        System.out.println(st.top());\n        st.pop();\n        System.out.println(st.getMin());\n        st.pop();\n        System.out.println(st.getMin());\n        st.pop();\n//        System.out.println(st.top());\n\n    }\n}\n\n/*\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */',
              link: 'https://leetcode.com/problems/min-stack/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '6cf66128-6e7c-4566-8abf-a4d996d583d9',
              isFolder: false,
              name: 'ReversePolishNotation.java',
              code: 'import java.util.*;\n\nclass ReversePolishNotation {\n    public static int operate(String op, int first, int second) {\n        if (op.equals("-")) return second - first;\n        if (op.equals("*")) return second * first;\n        if (op.equals("/")) return second / first;\n        return second + first; // op = +\n    }\n\n    public int evalRPN(String[] tokens) {\n        // Basically secondPop operation firstPop\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/"))\n                stack.push(operate(token, stack.pop(), stack.pop()));\n            else\n                stack.add(Integer.parseInt(token));\n        }\n        return stack.pop();\n    }\n}',
              link: 'https://leetcode.com/problems/evaluate-reverse-polish-notation/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '722c99f8-0c9a-4095-899f-2ea5c8b15dc5',
              isFolder: false,
              name: 'ValidParentheses.java',
              code: "import java.util.*;\npublic class ValidParentheses {\n    public static boolean isValid(String s) {\n//        Best w Stack\n//        int len = s.length();\n//        if ((len&1) == 1) return false;\n//        HashMap<Character, Character> hm = new HashMap<>();\n//        hm.put('(', ')');\n//        hm.put('[', ']');\n//        hm.put('{', '}');\n//        char[] charArr = s.toCharArray();\n//        Stack<Character> stack = new Stack<>();\n//        for (int i = 0; i < len; i++) {\n//            char ch = charArr[i];\n//            if (hm.containsKey(ch)) stack.push(ch);\n//            else {\n//                if(stack.empty()) return false;\n//                char top = stack.pop();\n//                if (hm.get(top) != ch) return false;\n//            }\n//        }\n//        return stack.empty();\n\n//     Best w/o stack\n        int len = s.length();\n        if ((len&1) == 1) return false;\n        char[] stack = new char[len];\n        char[] charArr = s.toCharArray();\n        HashMap<Character, Character> hm = new HashMap<>();\n        hm.put('(', ')');\n        hm.put('[', ']');\n        hm.put('{', '}');\n        int ptr = -1;\n        for (int i = 0; i < len; i++) {\n            char ch = charArr[i];\n            if (hm.containsKey(ch)) {\n                stack[++ptr] = ch;\n            } else {\n                if(ptr == -1) return false;\n                char top = stack[ptr--];\n                if (hm.get(top) != ch) return false;\n            }\n        }\n        return ptr == -1;\n    }\n\n    public static void main(String[] args) {\n        String s = \"()\";\n        System.out.println(isValid(s));\n    }\n}",
              link: 'https://leetcode.com/problems/valid-parentheses/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '324733e5-f002-4a09-82fd-c95d24790afb',
              isFolder: false,
              name: 'BalancedBinaryTree.java',
              code: 'import java.util.*;\n\nclass BalancedBinaryTree {\n\tpublic int solve(TreeNode root) {\n\t\tif (root == null) return 0;\n\t\tint left = solve(root.left);\n\t\tint right = solve(root.right);\n\t\tif (left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;\n\t\treturn Math.max(left, right) + 1;\n\t}\n\tpublic boolean isBalanced(TreeNode root) {\n\t\treturn solve(root) != -1;\n\t}\n}',
              link: 'https://leetcode.com/problems/balanced-binary-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '9cee4a7e-9181-4ac2-9559-09fa1a7bba22',
              isFolder: false,
              name: 'BinaryTreeLevelOrderTraversal.java',
              code: 'import java.util.*;\n\nclass BinaryTreeLevelOrderTraversal {\n\tpublic List<List<Integer>> levelOrder(TreeNode root) {\n\t\tList<List<Integer>> ans = new ArrayList<>();\n\t\tif (root == null) return ans;\n\t\tQueue<TreeNode> q = new LinkedList<>();\n\t\tq.add(root);\n\t\twhile (!q.isEmpty()) {\n\t\t\tList<Integer> lvl = new ArrayList<>();\n\t\t\tint size = q.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tTreeNode node = q.poll();\n\t\t\t\tlvl.add(node.val);\n\t\t\t\tif (node.left != null) q.offer(node.left);\n\t\t\t\tif (node.right != null) q.offer(node.right);\n\t\t\t}\n\t\t\tans.add(lvl);\n\t\t}\n\t\treturn ans;\n\t}\n}',
              link: 'https://leetcode.com/problems/binary-tree-level-order-traversal/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '9569a4b1-14ad-435d-9033-0630d0645d01',
              isFolder: false,
              name: 'BinaryTreeMaximumPathSum.java',
              code: 'import java.util.*;\n\nclass BinaryTreeMaximumPathSum {\n\tpublic static int solve(TreeNode root, int[] maxSum) {\n\t\tif (root == null) return 0;\n\t\tint l = Math.max(0, solve(root.left, maxSum));\n\t\tint r = Math.max(0, solve(root.right, maxSum));\n\t\tmaxSum[0] = Math.max(maxSum[0], l + r + root.val);\n\t\treturn Math.max(l, r) + root.val;\n\t}\n\tpublic int maxPathSum(TreeNode root) {\n\t\tint[] maxSum = new int[1];\n\t\tmaxSum[0] = Integer.MIN_VALUE;\n\t\tsolve(root, maxSum);\n\t\treturn maxSum[0];\n\t}\n}',
              link: 'https://leetcode.com/problems/binary-tree-maximum-path-sum/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: 'aef3f118-68bb-4b01-badf-8cf1c6ee7e3f',
              isFolder: false,
              name: 'BinaryTreeRightSideView.java',
              code: 'import java.util.*;\n\nclass BinaryTreeRightSideView {\n\tvoid solve(TreeNode root, List<Integer> ans, int lvl) {\n\t\tif (root == null) return;\n\t\tif (ans.size() <= lvl) ans.add(root.val);\n\t\tsolve(root.right, ans, lvl + 1);\n\t\tsolve(root.left, ans, lvl + 1);\n\t}\n\tpublic List<Integer> rightSideView(TreeNode root) {\n\t\tList<Integer> ans = new ArrayList<>();\n\t\tsolve(root, ans, 0);\n\t\treturn ans;\n\t}\n}',
              link: 'https://leetcode.com/problems/binary-tree-right-side-view/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: 'f08eb47c-74bd-4e2f-843c-bf8ceff6f8d1',
              isFolder: false,
              name: 'ConstructBinaryTreeFromPreorderAndInorderTraversal.java',
              code: 'import java.util.*;\n\nclass ConstructBinaryTreeFromPreorderAndInorderTraversal {\n\tpublic TreeNode buildTree(int[] preorder, int[] inorder) {\n\t\tif (preorder.length == 0 || inorder.length == 0) return null;\n\t\tTreeNode root = new TreeNode(preorder[0]);\n\t\tint start = 0;\n\t\tfor (int j : inorder) {\n\t\t\tif (j == preorder[0]) break;\n\t\t\tstart++;\n\t\t}\n\t\tint[] left_inorder = Arrays.copyOfRange(inorder, 0, start);\n\t\tint[] left_preorder = Arrays.copyOfRange(preorder, 1, start+1);\n\t\tint[] right_inorder = Arrays.copyOfRange(inorder, start+1, inorder.length);\n\t\tint[] right_preorder = Arrays.copyOfRange(preorder, start+1, preorder.length);\n\t\troot.left = buildTree(left_preorder, left_inorder);\n\t\troot.right = buildTree(right_preorder, right_inorder);\n\t\treturn root;\n\t}\n}',
              link: 'https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '3e9b693c-5626-4cbb-ab41-3aee9ecb0389',
              isFolder: false,
              name: 'CountGoodNodesInBinaryTree.java',
              code: 'import java.util.*;\n\nclass CountGoodNodesInBinaryTree {\n\tpublic int solve(TreeNode root, int maxVal) {\n\t\tif (root == null) return 0;\n\t\tint count = maxVal <= root.val ? 1 : 0;\n\t\tcount += solve(root.left, Math.max(root.val, maxVal));\n\t\tcount += solve(root.right, Math.max(root.val, maxVal));\n\t\treturn count;\n\t}\n\tpublic int goodNodes(TreeNode root) {\n\t\treturn solve(root, -100000);\n\t}\n}',
              link: 'https://leetcode.com/problems/count-good-nodes-in-binary-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: 'd47ffb5b-fb32-465e-a27d-bd87d3ab0a72',
              isFolder: false,
              name: 'DiameterofBinaryTree.java',
              code: 'import java.util.*;\n\nclass DiameterofBinaryTree {\n\tpublic static int solve(TreeNode root, int[] max) {\n\t\tif (root == null) return 0;\n\t\tint l = solve(root.left, max);\n\t\tint r = solve(root.right, max);\n\t\tint temp = 1 + Math.max(l, r);\n\t\tint ans = Math.max(temp, 1+l+r);\n\t\tmax[0] = Math.max(max[0], ans);\n\t\treturn temp;\n\t}\n\tpublic int diameterOfBinaryTree(TreeNode root) {\n\t\tint[] max = { 0 };\n\t\tsolve(root, max);\n\t\treturn max[0]-1;\n\t}\n}',
              link: 'https://leetcode.com/problems/diameter-of-binary-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '7b7b1adb-dc42-446f-99b3-7a0ff685a715',
              isFolder: false,
              name: 'InvertBinaryTree.java',
              code: 'import java.util.*;\n\nclass InvertBinaryTree {\n\tpublic TreeNode invertTree(TreeNode root) {\n\t\tif (root == null) return root;\n\t\tinvertTree(root.left);\n\t\tinvertTree(root.right);\n\t\tTreeNode temp = root.left;\n\t\troot.left = root.right;\n\t\troot.right = temp;\n\t\treturn root;\n\t}\n}',
              link: 'https://leetcode.com/problems/invert-binary-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '0101167e-39f7-4e91-acf8-dd3783a03573',
              isFolder: false,
              name: 'KthSmallestElementInaBst.java',
              code: 'import java.util.*;\n\nclass KthSmallestElementInaBst {\n\tpublic static void solve(TreeNode root, int[] ans, int k) {\n\t\tif (root == null) return;\n\t\tsolve(root.left, ans, k);\n\t\tans[1]++;\n\t\tif (ans[1] == k) {\n\t\t\tans[0] = root.val;\n\t\t\treturn;\n\t\t}\n\t\tsolve(root.right, ans, k);\n\t}\n\tpublic int kthSmallest(TreeNode root, int k) {\n\t\tint[] ans = { -1, 0 };\n\t\tsolve(root, ans, k);\n\t\treturn ans[0];\n\t}\n}',
              link: 'https://leetcode.com/problems/kth-smallest-element-in-a-bst/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: 'e3a2e298-a43b-44b4-bcdc-2a4bb3c360d7',
              isFolder: false,
              name: 'LowestCommonAncestorofaBinarySearchTree.java',
              code: 'import java.util.*;\n\nclass LowestCommonAncestorofaBinarySearchTree {\n\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right ,p,q);\n\t\tif (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left ,p,q);\n\t\treturn root;\n\t}\n}',
              link: 'https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: 'fe49ee72-9ab5-4da4-9bf1-853178601adc',
              isFolder: false,
              name: 'MaximumDepthofBinaryTree.java',
              code: 'import java.util.*;\n\nclass MaximumDepthofBinaryTree {\n\tpublic int maxDepth(TreeNode root) {\n\t\tif (root == null) return 0;\n\t\tint depthL = maxDepth(root.left);\n\t\tint depthR = maxDepth(root.right);\n\t\treturn Math.max(depthL, depthR) + 1;\n\t}\n}',
              link: 'https://leetcode.com/problems/maximum-depth-of-binary-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: 'ec24845c-6d0b-45c2-a114-8e88034c7365',
              isFolder: false,
              name: 'SameTree.java',
              code: 'import java.util.*;\n\nclass SameTree {\n\tpublic boolean isSameTree(TreeNode p, TreeNode q) {\n\t\tif (p == null && q == null) return true;\n\t\tif (p == null || q == null || p.val != q.val) return false;\n\t\treturn isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\t}\n}',
              link: 'https://leetcode.com/problems/same-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '2d8519d4-0056-462c-953d-ee75f537c34c',
              isFolder: false,
              name: 'SerializeAndDeserializeBinaryTree.java',
              code: 'import java.util.*;\n\nclass SerializeAndDeserializeBinaryTree {\n\tpublic static void preorder(TreeNode root, StringBuilder sb) {\n\t\tif (root == null) {\n\t\t\tsb.append("N,");\n\t\t\treturn;\n\t\t}\n\t\tsb.append(root.val).append(",");\n\t\tpreorder(root.left, sb);\n\t\tpreorder(root.right, sb);\n\t}\n\n\t// Encodes a tree to a single string.\n\tpublic static String serialize(TreeNode root) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tpreorder(root, sb);\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t\treturn sb.toString();\n\t}\n\n\tpublic static TreeNode solve(String[] arr, int[] idx) {\n\t\tif (idx[0] == arr.length || arr[idx[0]].compareTo("N") == 0) {\n\t\t\tidx[0]++;\n\t\t\treturn null;\n\t\t}\n\t\tTreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]]));\n\t\tidx[0]++;\n\t\troot.left = solve(arr, idx);\n\t\troot.right = solve(arr, idx);\n\t\treturn root;\n\t}\n\t// Decodes your encoded data to tree.\n\tpublic static TreeNode deserialize(String data) {\n\t\tString[] arr = data.split(",");\n\t\treturn solve(arr, new int[] {0});\n\t}\n}',
              link: 'https://leetcode.com/problems/serialize-and-deserialize-binary-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '5ff87ed6-3f52-4c88-b991-f3d5558bc540',
              isFolder: false,
              name: 'SubtreeofAnotherTree.java',
              code: 'import java.util.*;\n\nclass SubtreeofAnotherTree {\n\tpublic static boolean check(TreeNode p, TreeNode q) {\n\t\tif (p == null && q == null) return true;\n\t\tif (p == null || q == null || p.val != q.val) return false;\n\t\treturn check(p.left, q.left) && check(p.right, q.right);\n\t}\n\n\tpublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\n\t\tif (root == null) return subRoot == null;\n\t\tif (check(root, subRoot)) return true;\n\t\treturn isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n\t}\n}',
              link: 'https://leetcode.com/problems/subtree-of-another-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '54864e96-e20e-40c2-940b-bd21c5a70d9b',
              isFolder: false,
              name: 'ValidateBinarySearchTree.java',
              code: 'import java.util.*;\n\nclass ValidateBinarySearchTree {\n\tboolean solve(TreeNode root, Integer low, Integer high) {\n\t\tif (root == null) return true;\n\t\tif (low != null && root.val <= low) return false;\n\t\tif (high != null && root.val >= high) return false;\n\t\treturn solve(root.left, low, root.val) && solve(root.right, root.val, high);\n\t}\n\tpublic boolean isValidBST(TreeNode root) {\n\t\treturn solve(root, null, null);\n\t}\n}',
              link: 'https://leetcode.com/problems/validate-binary-search-tree/',
              notes: '',
              tags: ['Trees'],
            },
            {
              id: '1d49b5fd-f2ab-40f2-9632-6412bf054ed6',
              isFolder: false,
              name: 'Trie.java',
              code: 'import java.util.*;\nclass Trie {\n    class TrieNode {\n        HashMap<Character, TrieNode> map;\n        boolean isWord;\n        TrieNode() {\n            this.map = new HashMap<>();\n            this.isWord = false;\n        }\n    }\n    TrieNode node;\n    public Trie() {\n        this.node = new TrieNode();\n    }\n\n    public void insert(String word) {\n        int n = word.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                curr.map.put(ch, new TrieNode());\n            }\n            curr = curr.map.get(ch);\n        }\n        curr.isWord = true;\n    }\n\n    public boolean search(String word) {\n        int n = word.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                return false;\n            }\n            curr = curr.map.get(ch);\n        }\n        return curr.isWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        int n = prefix.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = prefix.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                return false;\n            }\n            curr = curr.map.get(ch);\n        }\n        return true;\n    }\n}',
              link: 'https://leetcode.com/problems/implement-trie-prefix-tree/',
              notes: '',
              tags: ['Tries'],
            },
            {
              id: 'a9a30159-aa53-459d-a617-8033f7ca3450',
              isFolder: false,
              name: 'WordDictionary.java',
              code: "import java.util.*;\n\nclass WordDictionary {\n    class TrieNode {\n        HashMap<Character, TrieNode> map;\n        boolean isWord;\n\n        TrieNode() {\n            this.map = new HashMap<>();\n            this.isWord = false;\n        }\n    }\n\n    TrieNode root;\n\n    public WordDictionary() {\n        this.root = new TrieNode();\n    }\n\n    public void addWord(String word) {\n        int n = word.length();\n        TrieNode curr = this.root;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                curr.map.put(ch, new TrieNode());\n            }\n            curr = curr.map.get(ch);\n        }\n        curr.isWord = true;\n    }\n\n    public boolean solve(String word, int start, TrieNode current) {\n        if (current == null) return false;\n        int n = word.length();\n        TrieNode curr = current;\n        for (int i = start; i < n; i++) {\n            char ch = word.charAt(i);\n            if (ch == '.') {\n                for (Map.Entry<Character, TrieNode> m : curr.map.entrySet()) {\n                    if (solve(word, i + 1, m.getValue())) return true;\n                }\n                return false;\n            }\n            return solve(word, i + 1, curr.map.get(ch));\n        }\n        return curr.isWord;\n    }\n\n    public boolean search(String word) {\n        return solve(word, 0, this.root);\n    }\n}",
              link: 'https://leetcode.com/problems/design-add-and-search-words-data-structure/',
              notes: '',
              tags: ['Tries'],
            },
            {
              id: 'f17f7ab4-471d-44b7-a5e2-53b68c93a818',
              isFolder: false,
              name: 'WordSearch2.java',
              code: 'import java.util.*;\n\npublic class WordSearch2 {\n    class TrieNode {\n        HashMap<Character, TrieNode> map;\n        boolean isWord;\n\n        TrieNode() {\n            this.map = new HashMap<>();\n            this.isWord = false;\n        }\n    }\n    class Trie {\n        TrieNode node;\n        public Trie() {\n            this.node = new TrieNode();\n        }\n        public void insert(String word) {\n            int n = word.length();\n            TrieNode curr = this.node;\n            for (int i = 0; i < n; i++) {\n                char ch = word.charAt(i);\n                if (!curr.map.containsKey(ch)) {\n                    curr.map.put(ch, new TrieNode());\n                }\n                curr = curr.map.get(ch);\n            }\n            curr.isWord = true;\n        }\n    }\n    static int[][] dirs = {{0,1}, {1,0}, {-1, 0}, {0, -1}};\n    public boolean isInBound(int i, int j, int n, int m)  {\n        return i >= 0 && j >= 0 && i < n && j < m;\n    }\n    public void dfs(char[][] board, boolean[][] V, TrieNode node, int i, int j, List<String> ans, StringBuilder sb) {\n        if (node == null) return;\n        if (node.isWord) {\n            ans.add(sb.toString());\n            node.isWord = false;\n        }\n        V[i][j] = true;\n        for (int d = 0; d < 4; d++) {\n            int r = i + dirs[d][0];\n            int c = j + dirs[d][1];\n            if (isInBound(r, c, board.length, board[0].length)\n                    && !V[r][c]\n                    && node.map.containsKey(board[r][c])\n            ) {\n                sb.append(board[r][c]);\n                dfs(board, V, node.map.get(board[r][c]), r, c, ans, sb);\n                sb.deleteCharAt(sb.length() - 1);\n            }\n        }\n        V[i][j] = false;\n    }\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> ans = new ArrayList<>();\n        Trie trie = new Trie();\n        for (int i = 0; i < words.length; i++) {\n            trie.insert(words[i]);\n        }\n\n        int n = board.length, m = board[0].length;\n        boolean[][] visited = new boolean[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (trie.node.map.containsKey(board[i][j])) {\n                    TrieNode newNode = trie.node.map.get(board[i][j]);\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(board[i][j]);\n                    dfs(board, visited, newNode, i, j, ans, sb);\n                }\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/word-search-ii/',
              notes: '',
              tags: ['Tries'],
            },
            {
              id: '7d7abf75-da0c-4ee3-a327-8208bc99168d',
              isFolder: false,
              name: 'ContainerWithMostWater.java',
              code: 'public class ContainerWithMostWater {\n    public static int maxArea(int[] heights) {\n        int i = 0;\n        int j = heights.length - 1;\n        int area = 0;\n        int max = 0;\n        while (i < j) {\n            if (heights[i] <= heights[j]) i++;\n            else if (heights[i] > heights[j]) j--;\n\n            area = (j - i) * Math.min(heights[i], heights[j]);\n            max = Math.max(max, area);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n        int ans = maxArea(heights);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/container-with-most-water/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '077890c8-4651-42fc-bfcf-786f554f50bb',
              isFolder: false,
              name: 'ThreeSum.java',
              code: 'import java.util.*;\npublic class ThreeSum {\n    public List<List<Integer>> threeSum(int[] N) {\n        Arrays.sort(N);\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = N.length;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && N[i] == N[i-1]) continue;\n            int j = i+1;\n            int k = n-1;\n            while (j < k) {\n                int sum = N[i] + N[j] + N[k];\n                if (sum > 0) k--;\n                else if (sum < 0) j++;\n                else {\n                    ans.add(Arrays.asList(N[i], N[j], N[k]));\n                    j++;\n                    k--;\n                    while (j < k && N[j] == N[j-1]) j++;\n                    while (j < k && N[k] == N[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/3sum',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '999201ca-229d-4812-a715-a175c02e8ce9',
              isFolder: false,
              name: 'TrappingRainWater.java',
              code: '// import java.util.Arrays;\npublic class TrappingRainWater {\n    public static int trap(int[] height) {\n        int n = height.length;\n//        int[] maxLeft = new int[n];\n//        int[] maxRight = new int[n];\n//        int leftMax = 0, rightMax = 0;\n//        for (int i = 0; i < n; i++) {\n//            maxLeft[i] = leftMax;\n//            leftMax = Math.max(leftMax, height[i]);\n//            maxRight[n - i - 1] = rightMax;\n//            rightMax = Math.max(rightMax, height[n - i - 1]);\n//        }\n//        int count = 0;\n//        for (int j = 0; j < n; j++) {\n//            count += Math.max(Math.min(maxLeft[j], maxRight[j]) - height[j], 0);\n//        }\n//        return count;\n        int start = 0, end = n - 1;\n        int maxL = height[start], maxR = height[end];\n        int c = 0;\n        while (start < end) {\n            if (height[start] <= height[end]) {\n                start++;\n                maxL = Math.max(maxL, height[start]);\n                c += Math.max(maxL - height[start], 0);\n\n            } else {\n                end--;\n                maxR = Math.max(maxR, height[end]);\n                c += Math.max(maxR - height[end], 0);\n            }\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n        int ans = trap(arr);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/trapping-rain-water/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '9af61850-577b-49e4-be18-f744a730f31c',
              isFolder: false,
              name: 'TwoSumSortedArray.java',
              code: 'public class TwoSumSortedArray {\n    public static int[] twoSum(int[] N, int target) {\n//        Brute force: Linear search the pair using 2 for loops (nested) O(N^2)\n\n//        Better solution: Use 2 pointer from left and right to get sum\n\n//        Optimised solution: Binary search\n        int start = 0;\n        int end = N.length - 1;\n        int[] ans = {-1, -1};\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int sum = N[start] + N[end];\n            if (sum == target){\n                ans[0] = start + 1;\n                ans[1] = end + 1;\n                return ans;\n            }\n            if (sum > target)\n                end = N[start] + N[mid] > target ? mid - 1 : end - 1;\n            else\n                start = N[end] + N[mid] < target ? mid + 1 : start + 1;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: 'f13b2af7-f4e0-47d0-9e63-5668bf26953b',
              isFolder: false,
              name: 'ValidPalindrome.java',
              code: 'public class ValidPalindrome {\n    public boolean isPalindrome(String s) {\n//        Brute force solution\n//        s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Optimised solution\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n    }\n}',
              link: 'https://leetcode.com/problems/valid-palindrome/',
              notes: '',
              tags: ['Two Pointers'],
            },
          ],
        },
        {
          id: 'ecf77ca7-7ab9-4824-8d52-cf88e0d98c31',
          isFolder: true,
          name: 'stiver_dsa_sheet',
          content: [
            {
              id: '3c6f53b9-e60b-454b-97e5-c78b7f1a1ec7',
              isFolder: true,
              name: 'Arrays',
              content: [
                {
                  id: 'ffc65a8e-6341-426a-aaf8-1d437ea8b1a0',
                  isFolder: false,
                  name: 'MajorityFrequency.java',
                  code: 'import java.util.*;\n\npublic class MajorityFrequency {\n    public static int majorityElement(int[] v) {\n        // Write your code here\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int maxFrequency = v.length / 2;\n        for (int i = 0 ; i <  v.length; i++) {\n            if (hm.containsKey(v[i])) {\n                hm.put(v[i], hm.get(v[i]) + 1);\n                if (hm.get(v[i]) > maxFrequency) {\n                    return v[i];\n                }\n            } else {\n                hm.put(v[i], 1);\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 2, 1, 3, 1, 1, 3, 1, 1};\n        int ans = majorityElement(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: 'f1444eaa-6e5c-4c82-8aaa-fd4df03b3f02',
                  isFolder: false,
                  name: 'MaximumConsecutiveOnes.java',
                  code: 'public class MaximumConsecutiveOnes {\n    public static int findMaxConsecutiveOnes(int[] N) {\n        int count = 0;\n        int maxCount = 0;\n        for (int i = 0; i < N.length; i++) {\n            if (N[i] == 0) {\n                count = 0;\n            } else {\n                count++;\n            }\n            maxCount = Math.max(count, maxCount);\n        }\n        return maxCount;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 0, 1, 1, 0, 1};\n        int ans = findMaxConsecutiveOnes(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: 'b807de82-ec5b-42ed-80c2-4741182506b1',
                  isFolder: false,
                  name: 'MergeSortedArraysDuplicates.java',
                  code: 'import java.util.*;\n\npublic class MergeSortedArraysDuplicates {\n    public static List< Integer > sortedArray(int []a, int []b) {\n        // Write your code here\n        List<Integer> ans = new ArrayList<>();\n        int i = 0, j = 0;\n        while (i < a.length && j < b.length) {\n            if (a[i] <= b[j]) {\n                if (ans.size() == 0 || ans.get(ans.size() - 1) != a[i])\n                    ans.add(a[i]);\n                i++;\n            } else {\n                if (ans.size() == 0 || ans.get(ans.size() - 1) != b[j])\n                    ans.add(b[j]);\n                j++;\n            }\n        }\n        while (i < a.length) {\n            if (ans.get(ans.size() - 1) != a[i])\n                ans.add(a[i]);\n            i++;\n        }\n        while (j < b.length) {\n            if (ans.get(ans.size() - 1) != b[j])\n                ans.add(b[j]);\n            j++;\n        }\n        return ans;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: 'a1b638bb-9caa-464b-b649-adbe249940ed',
                  isFolder: false,
                  name: 'ZeroOneTwo.java',
                  code: 'import java.util.*;\n\npublic class ZeroOneTwo {\n    public static void sortArray(ArrayList<Integer> arr, int n) {\n        // Write your code here.\n        int start = 0, end = n-1, element = 0;\n        while (element < 2) {\n            if (start >= end) {\n                element++;\n                end = n-1;\n            }\n            if (arr.get(start) == element) start++;\n            else if (arr.get(end) != element) end--;\n            else {\n                arr.set(end, arr.get(start));\n                arr.set(start, element);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        arr.add(2);\n        arr.add(2);\n        arr.add(2);\n        arr.add(2);\n        arr.add(0);\n        arr.add(0);\n        arr.add(1);\n        arr.add(0);\n        sortArray(arr, arr.size());\n        System.out.println(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '13454516-779e-4eb6-8392-5f8210740f04',
                  isFolder: false,
                  name: 'CountInversions.java',
                  code: 'public class CountInversions {\n    public static int merge(int[] A, int low, int mid, int high) {\n        int left = low, right = mid + 1, i = 0;\n        int count = 0;\n        int[] temp = new int[high - low + 1];\n        while (left <= mid && right <= high) {\n            if (A[left] <= A[right]) {\n                temp[i++] = A[left++];\n            } else {\n                count += mid - left + 1;\n                temp[i++] = A[right++];\n            }\n        }\n        while (left <= mid)\n            temp[i++] = A[left++];\n        while (right <= high)\n            temp[i++] = A[right++];\n        for (int j = 0; j < temp.length; j++)\n            A[j + low] = temp[j];\n        return count;\n    }\n\n    public static int mergeSort(int[] A, int low, int high) {\n        if (low == high) return 0;\n        int mid = (low + high) / 2;\n        int count = 0;\n        count += mergeSort(A, low, mid);\n        count += mergeSort(A, mid + 1, high);\n        count += merge(A, low, mid, high);\n        return count;\n    }\n\n    public static int numberOfInversions(int[] A, int n) {\n        // Write your code here.\n        return mergeSort(A, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {5, 4, 3, 2, 1};\n//        int[] arr = {1, 2, 3, 4, 5};\n        int inversions = numberOfInversions(arr, arr.length);\n        System.out.println(inversions);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '2d2275e1-5400-4263-ae0f-a98ebb699528',
                  isFolder: false,
                  name: 'FourSum.java',
                  code: 'import java.util.*;\n\npublic class FourSum {\n    public static void fourSum(int[] A, int target) {\n        int n = A.length;\n//        BETTER APPROACH\n//         HashSet<List<Integer>> unique = new HashSet<>();\n//         for (int i = 0; i < n; i++) {\n//             for (int j = i + 1; j < n; j++) {\n//                 HashSet<Integer> hs = new HashSet<>();\n//                 for (int k = j + 1; k < n; k++) {\n//                     int fourth = target - (A[i] + A[j] + A[k]);\n//                     if (hs.contains(fourth)) {\n//                         List<Integer> temp = Arrays.asList(A[i], A[j], A[k], fourth);\n//                         temp.sort(null);\n//                         unique.add(temp);\n//                     }\n//                     hs.add(A[k]);\n//                 }\n//             }\n//         }\n//         List<List<Integer>> X = new ArrayList<>(unique);\n\n//        BEST APPROACH\n       Arrays.sort(A);\n       List<List<Integer>> ans = new ArrayList<>();\n       for (int i = 0; i < n; i++) {\n           if (i > 0 && A[i] == A[i - 1]) continue;\n           for (int j = i + 1; j < n - 1; j++) {\n               if (j > i+1 && A[j] == A[j - 1]) continue;\n               int k = j + 1;\n               int l = n - 1;\n               while (k < l) {\n                   int sum = A[i];\n                   sum += A[j];\n                   sum += A[k];\n                   sum += A[l];\n                   if (sum > target) l--;\n                   else if (sum < target) k++;\n                   else {\n                       ans.add(Arrays.asList(A[i], A[j], A[k], A[l]));\n                       k++;\n                       l--;\n                       while (k < l && A[k] == A[k - 1]) k++;\n                       while (k < l && A[l] == A[l + 1]) l--;\n                   }\n               }\n           }\n       }\n       System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 0, -1, 0, -2, 2};\n        fourSum(arr, 0);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '2694c12b-5464-4005-8af5-abf3b57015df',
                  isFolder: false,
                  name: 'LargestSubArray0Sum.java',
                  code: 'import java.util.HashMap;\n\npublic class LargestSubArray0Sum {\n    public static int longestSubArrayWith0Sum(int[] arr) {\n        int longest = 0;\n//        Better solution O(N^2)\n//        for (int i = 0; i < arr.length; i++) {\n//            int sum = 0;\n//            for (int j = i; j < arr.length; j++) {\n//                sum += arr[j];\n//                if (sum == 0)\n//                    longest = Math.max(longest, j - i + 1);\n//            }\n//        }\n\n//        Best solution\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n            if (sum == 0)\n                longest = Math.max(longest, i + 1);\n            else if (hm.containsKey(sum))\n                longest = Math.max(longest, i - hm.get(sum));\n            if (!hm.containsKey(sum)) hm.put(sum, i);\n        }\n        return  longest;\n    }\n    public static void main(String[] args) {\n        int[] arr = {9, -3, 3, -1, 6, -5};\n        int ans = longestSubArrayWith0Sum(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '93a50471-3672-4434-8de9-a8d352994c83',
                  isFolder: false,
                  name: 'MajorityElementNBy3.java',
                  code: 'import java.util.*;\n\npublic class MajorityElementNBy3 {\n    public static void printMajorityElements(int[] arr) {\n        List<Integer> ans = new ArrayList<>();\n        int majority = (arr.length / 3) + 1;\n//        Better approach\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        for (int j : arr) {\n//            hm.put(j, hm.getOrDefault(j, 0) + 1);\n//        }\n//        for (Map.Entry<Integer, Integer> x: hm.entrySet()) {\n//            if (x.getValue() > majority) ans.add(x.getKey());\n//            if (ans.size() == 2) break;\n//        }\n\n//        Best approach\n        int c1 = 0, c2 = 0, e1 = -1, e2 = -1;\n        for (int j : arr) {\n            if (c1 == 0 && e2 != j) {\n                c1 = 1;\n                e1 = j;\n            } else if (c2 == 0 && e1 != j) {\n                c2 = 1;\n                e2 = j;\n            } else if (j == e1) c1++;\n            else if (j == e2) c2++;\n            else {\n                c1--;\n                c2--;\n            }\n        }\n//        We got elements\n        c1 = 0;\n        c2 = 0;\n        for (int i: arr) {\n            if (i == e1) c1++;\n            else if (i == e2) c2++;\n        }\n        if (c1 >= majority) ans.add(e1);\n        if (c2 >= majority) ans.add(e2);\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 1, 1, 3, 1, 4, 5, 6};\n        printMajorityElements(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '49a20c61-ebea-48a7-9b86-db7de5522087',
                  isFolder: false,
                  name: 'MaximumProductSubArray.java',
                  code: 'public class MaximumProductSubArray {\n    public static int subarrayWithMaxProduct(int []arr){\n        // Brute force\n//        int maxProd = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int prod = arr[i];\n//            for (int j = i+1; j < arr.length; j++) {\n//                prod *= arr[j];\n//                maxProd = Math.max(maxProd, prod);\n//            }\n//        }\n//        return maxProd;\n        // Best approach\n        int maxProd = arr[0];\n        int prodLeft = 1;\n        int prodRight = 1;\n        for (int i = 0; i < arr.length; i++) {\n            prodLeft *= arr[i];\n            prodRight *= arr[arr.length - i - 1];\n            maxProd = Math.max(maxProd, Math.max(prodLeft, prodRight));\n            if (prodLeft == 0) prodLeft++;\n            if (prodRight == 0) prodRight++;\n        }\n        return maxProd;\n    }\n    public static void main(String[] args) {\n        int[] arr = {-2, 3, -4, 0};\n        int ans = subarrayWithMaxProduct(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '0b46dc9c-4aeb-47e2-91e4-bbc1dd6a7caf',
                  isFolder: false,
                  name: 'MergeOverlappingSubIntervals.java',
                  code: 'import java.util.*;\n\npublic class MergeOverlappingSubIntervals {\n    public static void mergeIntervals(int[][] arr) {\n        Arrays.sort(arr, Comparator.comparingInt(a -> a[0]));\n        int start = arr[0][0], end = arr[0][1];\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 1; i < arr.length; i++) {\n            if (end >= arr[i][0])\n                end = Math.max(end, arr[i][1]);\n            else {\n                ans.add(Arrays.asList(start, end));\n                start = arr[i][0];\n                end = arr[i][1];\n            }\n        }\n        ans.add(Arrays.asList(start, end));\n        System.out.println(ans);\n    }\n    public static void main(String[] args) {\n//        int[][] arr = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n        int[][] arr = {{1, 4}, {4, 5}};\n        mergeIntervals(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '03b7281c-453c-49eb-aab1-87ccbc59b0f5',
                  isFolder: false,
                  name: 'MergeTwoSortedArrays.java',
                  code: 'import java.util.Arrays;\n\npublic class MergeTwoSortedArrays {\n//    Variation 1\n    public static void mergeSortedArrays(int[] a, int[] b, int m, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        while (j >= 0) {\n            if (a[i] >= b[j])\n                a[k--] = a[i--];\n            else\n                a[k--] = b[j--];\n        }\n        System.out.println(Arrays.toString(a));\n    }\n    public static void mergeSortedArrays2(int[] a, int[] b) {\n        int m = a.length, n = b.length;\n//        int[] temp = new int[m+n];\n//        int left = 0, right = 0, index = 0;\n//        while (left < m && right < n) {\n//            if (a[left] <= b[right]) {\n//                temp[index++] = a[left++];\n//            } else {\n//                temp[index++] = b[right++];\n//            }\n//        }\n//        while (left < m) temp[index++] = a[left++];\n//        while (right < n) temp[index++] = b[right++];\n//        for (int i = 0; i < temp.length; i++) {\n//            if (i < m)\n//                a[i] = temp[i];\n//            else\n//                b[i-m] = temp[i];\n//        }\n        int l = m - 1;\n        int r = 0;\n        while (l >=0 && r < n) {\n            if (a[l] <= b[r]) break;\n            int temp = a[l];\n            a[l--] = b[r];\n            b[r++] = temp;\n        }\n        Arrays.sort(a);\n        Arrays.sort(b);\n        System.out.println(Arrays.toString(a));\n        System.out.println(Arrays.toString(b));\n    }\n\n    public static void main(String[] args) {\n//        Type 1:\n//        int[] a = {1, 4, 8, 10, 0, 0, 0};\n//        int[] b = {2, 3, 9};\n//        mergeSortedArrays(a, b, 4,3);\n        int[] a = {1, 4, 8, 10};\n        int[] b = {2, 3, 9};\n        mergeSortedArrays2(a, b);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '13a4f577-c6a2-46b5-bed1-5e998b12a185',
                  isFolder: false,
                  name: 'MissingAndDuplicateNumber.java',
                  code: 'public class MissingAndDuplicateNumber {\n    //    Without changing the input array\n    public static void findMissingRepeatingNumbers(int[] arr) {\n//        Mathematical equation technique\n        int n = arr.length;\n        long S = 0;\n        long S2 = 0;\n        long SN = (long) n * (n + 1) /2;\n        long S2N = n * (n + 1) * (2L * n + 1) /6;\n        for (int i : arr) {\n            S += i;\n            S2 += (long) i *i;\n        }\n        long val1 = S - SN; // (X - Y)\n        long val2 = S2 - S2N; // (X - Y) (X + Y)\n        long x = (val2/val1 + val1)/2;\n        long y = x - val1;\n        System.out.println("x: " + x + " y: " + y);\n\n//        int[] count = new int[arr.length];\n//        for (int i : arr) {\n//            count[i - 1]++;\n//        }\n//        int missing = -1, duplicate = -1;\n//        for (int i = 0; i < count.length; i++) {\n//            if (count[i] == 0)\n//                missing = i+1;\n//            else if (count[i] == 2)\n//                duplicate = i+1;\n//            if (missing != -1 && duplicate != -1) break;\n//        }\n//        System.out.println(Arrays.asList(duplicate, missing));\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 1, 2, 5, 3};\n        findMissingRepeatingNumbers(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '06d89cce-6531-4030-bab5-ef732ee2bfb3',
                  isFolder: false,
                  name: 'PascalsTriangle.java',
                  code: "import java.util.Arrays;\n\npublic class PascalsTriangle {\n    //    static int fact(int x) {\n//        int product = 1;\n//        for (int i = 2; i <= x; i++)\n//            product *= i;\n//        return product;\n//    }\n    static int getNCR(int n, int r) {\n//        int numerator = fact(n);\n//        int denominator = fact(r) * fact(n-r);\n//        return (int) (numerator / denominator);\n        long res = 1;\n        for (int i = 0; i < r; i++) {\n            res *= n - i;\n            res /= i + 1;\n        }\n        return (int) res;\n    }\n\n    //    Type 1:  Given row r and column c. Print the element at position (r, c) in Pascal's triangle.\n    public static int getTriangleValue(int row, int col) {\n        return getNCR(row - 1, col - 1);\n    }\n\n    //    Type 2: Given the row number n. Print the n-th row of Pascal's triangle.\n    public static int[] printRowPascalsTriangle(int n) {\n        int[] arr = new int[n];\n        int ans = 1;\n        arr[0] = ans;\n        for (int i = 1; i < n; i++) {\n            ans *= n - i;\n            ans /= i;\n            arr[i] = ans;\n        }\n//        for (int i = 0; i < n; i++) {\n//            ans[i] = getNCR(n-1, i);\n//        }\n        return arr;\n    }\n\n    //    Type 3: Given the number of rows n. Print the first n rows of Pascal's triangle.\n    public static void printPascalsTriangle(int n) {\n        int[][] ans = new int[n][];\n        for (int i = 1; i <= n; i++) {\n            ans[i-1] = printRowPascalsTriangle(i);\n        }\n        for (int[] a: ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n\n    public static void main(String[] args) {\n        int ans = getTriangleValue(5, 3);\n        System.out.println(ans);\n        int[] row = printRowPascalsTriangle(5);\n        System.out.println(Arrays.toString(row));\n        printPascalsTriangle(9);\n    }\n}",
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'd3258123-2ce3-4ac1-8504-4d38e3841028',
                  isFolder: false,
                  name: 'ReversePairs.java',
                  code: 'public class ReversePairs {\n    public static int countPairs(int[] A, int low, int mid, int high) {\n        int count = 0;\n        int right = mid + 1;\n        for (int i = low; i <= mid; i++) {\n            while (right <= high && A[i] > 2*A[right]) {\n                right++;\n            }\n            count += right - mid - 1;\n        }\n        return count;\n    }\n\n    public static void merge(int[] A, int low, int mid, int high) {\n        int left = low, right = mid + 1, i = 0;\n        int[] temp = new int[high - low + 1];\n        while (left <= mid && right <= high) {\n            if (A[left] <= A[right])\n                temp[i++] = A[left++];\n            else\n                temp[i++] = A[right++];\n        }\n        while (left <= mid)\n            temp[i++] = A[left++];\n        while (right <= high)\n            temp[i++] = A[right++];\n        for (int j = 0; j < temp.length; j++)\n            A[j + low] = temp[j];\n    }\n\n    public static int mergeSort(int[] A, int low, int high) {\n        if (low == high) return 0;\n        int mid = (low + high) / 2;\n        int count = 0;\n        count += mergeSort(A, low, mid);\n        count += mergeSort(A, mid + 1, high);\n        count += countPairs(A, low, mid,  high);\n        merge(A, low, mid, high);\n        return count;\n    }\n\n    public static int reversePairsCount(int[] A, int n) {\n        // Write your code here.\n        return mergeSort(A, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 1, 2, 3, 1};\n        int count = reversePairsCount(arr,  5);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '96af77b5-905f-4162-914a-4e51715da1f9',
                  isFolder: false,
                  name: 'SubArraysWithXORK.java',
                  code: 'import java.util.HashMap;\n\npublic class SubArraysWithXORK {\n    public static int getSubArrayCountWithXORK (int[] arr, int k) {\n//        Best solution\n        int count = 0;\n        int xor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        for (int i = 0; i < arr.length; i++) {\n            xor ^= arr[i];\n            if (hm.containsKey(xor^k)) {\n                count += hm.get(xor^k);\n            }\n            hm.put(xor, hm.getOrDefault(xor, 0)+1);\n        }\n        return count;\n\n//        Better Solution\n//        int count = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int xor = 0;\n//            for (int j = i; j < arr.length; j++) {\n//                xor ^= arr[j];\n//                if (xor == k)\n//                    count++;\n//            }\n//        }\n//        return count;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 6, 7, 8, 9};\n        int count = getSubArrayCountWithXORK(arr, 5);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '82f6a262-d6d2-491a-874a-d11b8854edde',
                  isFolder: false,
                  name: 'ThreeSum.java',
                  code: 'import java.util.*;\n\npublic class ThreeSum {\n    public static List<List<Integer>> threeSum(int[] arr) {\n//        HashSet<List<Integer>> hs = new HashSet<>();\n//        for (int i = 0; i < arr.length; i++) {\n//            HashMap<Integer, Integer> hm = new HashMap<>();\n//            for (int j = i+1; j < arr.length; j++) {\n//                int temp = -1 * (arr[i] + arr[j]);\n//                if (hm.containsKey(temp)) {\n//                    List<Integer> tempArr = new ArrayList<>(Arrays.asList(arr[i], arr[j], temp));\n//                    tempArr.sort(null);\n//                    hs.add(tempArr);\n//                }\n//                hm.put(arr[j], j);\n//            }\n//        }\n//        return new ArrayList<>(hs);\n        int n = arr.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(arr);\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && arr[i] == arr[i-1]) continue;\n            int j = i + 1;\n            int k = n - 1;\n            while (j < k) {\n                int sum = arr[i] + arr[j] + arr[k];\n                if (sum < 0) {\n                    j++;\n                } else if (sum > 0) {\n                    k--;\n                } else {\n                    ans.add(Arrays.asList(arr[i], arr[j], arr[k]));\n                    j++;\n                    k--;\n                    while (j < k && arr[j] == arr[j-1]) j++;\n                    while (j < k && arr[k] == arr[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int[] arr = {-1, 0, 1, 0};\n        List<List<Integer>> ans = threeSum(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '13c99415-a488-40c3-90cb-7ff1236a0e18',
                  isFolder: false,
                  name: 'ArrayMaxSumSubarray.java',
                  code: 'import java.util.Arrays;\n\npublic class ArrayMaxSumSubarray {\n    public static int[] getMaxSubarraySumArray(int[] arr) {\n        int start = -1, end = -1;\n        int sum = 0, maxSum = arr[0];\n        int temp = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum == 0) temp = i;\n            sum += arr[i];\n            if (maxSum < sum) {\n                maxSum = sum;\n                start = temp;\n                end = i;\n            }\n            if (sum < 0) sum = 0;\n        }\n\n        System.out.println(start + " " + end);\n        return Arrays.copyOfRange(arr, start, end+1);\n    }\n\n    public static int getMaxSubarraySumLength(int[] arr) {\n        int start = -1, end = -1, temp = 0;\n        int sum = 0, maxSum = arr[0];\n        for (int i = 0; i < arr.length; i++) {\n            if (sum == 0) temp = i;\n            sum += arr[i];\n            if (maxSum < sum) {\n                maxSum = sum;\n                start = temp;\n                end = i;\n            }\n            if (sum < 0) sum = 0;\n        }\n        return end - start+1;\n    }\n\n    public static int getMaxSubarraySum(int[] arr) {\n        int sum = 0, maxSum = arr[0];\n        for (int j : arr) {\n            sum += j;\n            if (maxSum < sum) maxSum = sum;\n            if (sum < 0) sum = 0;\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n//        TESTING\n//        int[] arr = {-4, 1, -2, 1, 5, -3, 1, 3, -1, -2};\n//        int[] arr = {-4, -1, -2, -1, -5, -3, 1, -3, -1, -2};\n        int[] arr = {-4, 1, 2, 1, -5, 3, 1, 3, 1, -2};\n//        int[] arr = {-4, 5, 7, -6, 10, -15, 3};\n//        int[] arr = {-3, 2, -1, 4, -2};\n//        int[] arr = {-1,2};\n//        int[] arr = {-2,-1};\n        int ans = getMaxSubarraySumLength(arr);\n        int[] ansArray = getMaxSubarraySumArray(arr);\n        int ansSum = getMaxSubarraySum(arr);\n        System.out.println("Length: " + ans);\n        System.out.println("Sum: " + ansSum);\n        System.out.println("Array: " + Arrays.toString(ansArray));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '198aef24-2c00-43fb-b70e-ae35cd58e4f0',
                  isFolder: false,
                  name: 'LongestConsecutiveSequence.java',
                  code: 'import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class LongestConsecutiveSequence {\n    public static boolean found(int[] arr, int target) {\n        for (int i : arr)\n            if (target == i) return true;\n        return false;\n    }\n\n    public static int longestConsecutiveSequenceLength(int[] arr) {\n//        Brute force: O(N^2) time\n//        int longest = 1;\n//        for (int j : arr) {\n//            int count = 1;\n//            int x = j;\n//            while (found(arr, x+1)) {\n//                x++;\n//                count++;\n//            }\n//            longest = Math.max(longest, count);\n//        }\n//        return longest;\n\n//        Better Solution\n//        Arrays.sort(arr);\n//        int longest = 1;\n//        int currentCount = 0;\n//        int last = Integer.MIN_VALUE;\n//        for (int i = 0; i < arr.length; i++) {\n//            if (arr[i] - 1 == last) {\n//                currentCount++;\n//            } else if (arr[i] != last) {\n//                currentCount = 1;\n//            }\n//            longest = Math.max(longest, currentCount);\n//            last = arr[i];\n//        }\n//        return longest;\n\n//        Best\n        int longest = 1;\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : arr) {\n            hs.add(i);\n        }\n        for (int j : arr) {\n            if (!hs.contains(j - 1)) {\n                int count = 1;\n                int element = j;\n                while (hs.contains(element + 1)) {\n                    count++;\n                    element++;\n                }\n                longest = Math.max(longest, count);\n            }\n        }\n        return longest;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 9, 4, 5};\n        int ans = longestConsecutiveSequenceLength(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '915e4c88-cf08-40cb-bf45-aea462161059',
                  isFolder: false,
                  name: 'NextPermutation.java',
                  code: 'import java.util.Arrays;\n\npublic class NextPermutation {\n    // Reverse\n    public static void reverse(int[] arr, int start, int end) {\n        while (start < end) {\n            swap(arr, start++, end--);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int[] nextPermutation(int[] arr) {\n        int n = arr.length;\n        int bp = -1;\n        for (int i = n - 1; i > 0; i--) {\n            if (arr[i] > arr[i - 1]) {\n                bp = i - 1;\n                break;\n            }\n        }\n        if (bp == -1) {\n            reverse(arr, 0, n - 1);\n            return arr;\n        }\n//        Ceiling\n        for (int j = n - 1; j > bp; j--) {\n            if (arr[j] > arr[bp]) {\n                swap(arr, j, bp);\n                break;\n            }\n        }\n        reverse(arr, bp+1, n - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 2};\n        int[] ans = nextPermutation(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '27d11c4e-b401-4e55-badd-cf8d913366ba',
                  isFolder: false,
                  name: 'RotateBy90.java',
                  code: 'import java.util.Arrays;\n\npublic class RotateBy90 {\n    public static  void reverse (int[] arr) {\n        int start = 0, end = arr.length - 1;\n        while (start < end) {\n            int temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n    public static void rotateMatrix(int[][] mat) {\n        // Brute force solution\n//        int[][] newMat = new int[mat.length][mat[0].length];\n//        for (int r = 0; r < mat.length; r++) {\n//            for (int c = 0; c < mat[r].length; c++) {\n//                newMat[c][mat[r].length - r - 1] = mat[r][c];\n//            }\n//        }\n//        return newMat;\n//                if (r != c) System.out.println("r: "+r + " c: " + c + " A: " + mat[r][c] + " B: " + mat[c][r]);\n        // Best solution\n        for (int r = 0; r < mat.length; r++) {\n            for (int c = r; c < mat[r].length; c++) {\n                int temp = mat[r][c];\n                mat[r][c] = mat[c][r];\n                mat[c][r] = temp;\n            }\n        }\n        for (int[] row : mat) reverse(row);\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 9},\n        };\n        rotateMatrix(mat);\n        for (int[] a : mat) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '059ec060-359f-4c7e-bb17-9804d969dc8b',
                  isFolder: false,
                  name: 'SetMatrixZero.java',
                  code: 'import java.util.Arrays;\n\npublic class SetMatrixZero {\n    //    Helper functions\n    public static void setRow(int[][] mat, int index) {\n        for (int i = 0; i < mat.length; i++)\n            mat[index][i] = -1;\n    }\n\n    public static void setCol(int[][] mat, int index) {\n        for (int i = 0; i < mat.length; i++)\n            mat[i][index] = -1;\n    }\n\n    public static int[][] setMatrixZero(int[][] mat) {\n//        Brute force\n//        for (int i = 0; i < mat.length; i++) {\n//            for (int j = 0; j < mat[i].length; j++) {\n//                if (mat[i][j] == 0) {\n//                    setRow(mat, i);\n//                    setCol(mat, j);\n//                }\n//            }\n//        }\n//        for (int i = 0; i < mat.length; i++)\n//            for (int j = 0; j < mat[i].length; j++)\n//                if (mat[i][j] == -1) mat[i][j] = 0;\n\n//        Better\n//        int[] rows = new int[mat.length];\n//        int[] cols = new int[mat[0].length];\n//        for (int i = 0; i < mat.length; i++) {\n//            for (int j = 0; j < mat[i].length; j++) {\n//                if (mat[i][j] == 0) {\n//                    rows[i] = -1;\n//                    cols[j] = -1;\n//                }\n//            }\n//        }\n//        for (int i = 0; i < mat.length; i++)\n//            for (int j = 0; j < mat[i].length; j++)\n//                if (cols[j] == -1 || rows[i] == -1) mat[i][j] = 0;\n\n//        Best\n        int col0 = 1;\n        for (int i = 0; i < mat.length; i++) {\n            if (mat[i][0] == 0) col0 = 0; // One column\n            // Rest of the columns\n            for (int j = 1; j < mat[i].length; j++) {\n                if (mat[i][j] == 0) {\n                    mat[i][0] = 0;\n                    mat[0][j] = 0;\n                }\n            }\n        }\n        for (int r = mat.length  - 1; r >= 0; r--) {\n            for (int c = mat[r].length - 1; c > 0; c--) {\n                if (mat[r][0] == 0 || mat[0][c] == 0) mat[r][c] = 0;\n            }\n            // First column\n            if (col0 == 0) {\n                mat[r][0] = 0;\n            }\n        }\n\n        return mat;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 1, 1, 1},\n                {1, 0, 0, 1},\n                {1, 1, 0, 1},\n                {1, 1, 1, 1}\n        };\n        int[][] ans = setMatrixZero(mat);\n        for (int[] a : ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '1450b2a9-3f69-46d5-bda5-6e978378d233',
                  isFolder: false,
                  name: 'SpiralMatrix1.java',
                  code: 'import java.util.Arrays;\n\npublic class SpiralMatrix1 {\n    public static int[] printSpiralMatrix(int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n        int rStart = 0, rEnd = n - 1;\n        int cStart = 0, cEnd = m - 1;\n        int[] ans = new int[n*m];\n        int index = 0;\n        while (rStart <= rEnd && cStart <= cEnd) {\n//            LR\n            for (int i = cStart; i <= cEnd; i++) {\n                ans[index++] = mat[rStart][i];\n            }\n            rStart++;\n//            TB\n            for (int i = rStart; i <= rEnd; i++) {\n                ans[index++] = mat[i][cEnd];\n            }\n            cEnd--;\n            if (index == n*m) break;\n//            RL\n            for (int i = cEnd; i >= cStart; i--) {\n                ans[index++] = mat[rEnd][i];\n            }\n            rEnd--;\n//            BT\n            for (int i = rEnd; i >= rStart; i--) {\n                ans[index++] = mat[i][cStart];\n            }\n            cStart++;\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int[][] mat = {\n                { 1, 2, 3 },\n                { 4, 5, 6 },\n                { 7, 8, 9 }\n        };\n        int[] ans = printSpiralMatrix(mat);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '508ce80b-e4d3-40ec-aa2a-9166f2c109b9',
                  isFolder: false,
                  name: 'SubArraysWithGivenSum.java',
                  code: 'import java.util.HashMap;\n\npublic class SubArraysWithGivenSum {\n    public static int getSubArraysWithGivenSum(int[] arr, int k) {\n        // This solution wont handle negative numbers\n//        int l = 0, r = 0;\n//        int count = 0;\n//        int sum = 0;\n//        while (r < arr.length) {\n//            sum += arr[r];\n//            while (l <= r && sum > k)\n//                sum -= arr[l++];\n//            if (sum == k) count++;\n//            r++;\n//        }\n//        return count;\n//        This can handle positive and negative numbers\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        int count = 0, sum = 0;\n        for (int j : arr) {\n            sum += j;\n            if (hm.containsKey(sum - k))\n                count += hm.get(sum - k);\n            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, -3, 1, 1, 1, 4, 2, -3};\n        int ans = getSubArraysWithGivenSum(arr, 3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
              ],
            },
            {
              id: '73942593-57c7-4c03-a8d0-0067b6cacdaf',
              isFolder: true,
              name: 'Binary Search',
              content: [
                {
                  id: '57aade9d-cbff-4dcb-ab98-27299a8e059d',
                  isFolder: false,
                  name: 'CeilAndFloor.java',
                  code: 'import java.util.*;\nimport java.io.*;\n\npublic class CeilAndFloor {\n    public static int floor(int[] arr, int target, int n) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int ceil(int[] arr, int target, int n) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static int ceilingInSortedArray(int n, int x, int[] arr) {\n        // Write your code here.\n        Arrays.sort(arr);\n        int ceilElement = ceil(arr, x, n);\n        int floorElement = floor(arr, x, n);\n        if (ceilElement != n) {\n            ceilElement = arr[ceilElement];\n        } else {\n            ceilElement = -1;\n        }\n        if (floorElement != -1) {\n            floorElement = arr[floorElement];\n        }\n\n        System.out.print(floorElement + " ");\n        return ceilElement;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {48, 26, 2, 6, 10, 48, 11, 21, 47, 50, 50, 45, 43, 27};\n        int ans = ceilingInSortedArray(arr.length, 51, arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '48a52251-7405-486d-86b0-33e9c3f54176',
                  isFolder: false,
                  name: 'CountOccurrencesSortedArrayWithDuplicates.java',
                  code: 'public class CountOccurrencesSortedArrayWithDuplicates {\n    public static int count(int[] arr, int n, int x) {\n        //Your code goes here\n        int first = bs(arr, x, true);\n        if (first == -1)\n            return 0;\n        int second = bs(arr, x, false);\n        return second - first + 1;\n    }\n\n    public static int bs(int[] arr, int target, boolean lookLeft) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) {\n                ans = mid;\n                if (lookLeft)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 1, 2, 2, 3, 3};\n        int count = count(arr, arr.length,1);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'ceafb152-3ca3-4f2e-a93d-c80be0f9e893',
                  isFolder: false,
                  name: 'FindMinimumRotatedSortedArray.java',
                  code: 'public class FindMinimumRotatedSortedArray {\n    public static int getMinimumInRotatedSortedArray(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n//            Condition to handle duplicates\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                end--;\n                continue;\n            }\n            if (arr[mid] > arr[end]) {\n                // left sorted\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                // right sorted\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n\n    public static int getPivot(int[] arr) {\n//        PIVOT: Index of the point till where the array is rotated (MAX Element)\n        int start = 0;\n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (mid < end && arr[mid] > arr[mid + 1]) return mid;\n            if (mid > start && arr[mid - 1] > arr[mid]) return mid - 1;\n            if (arr[mid] > arr[end])\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 1, 3, 3, 3, 3, 3};\n        int ans = getMinimumInRotatedSortedArray(arr);\n        System.out.println(ans);\n        int pivot = getPivot(arr);\n        System.out.println(pivot + 1);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '956ae631-6b5d-4e06-a763-2d12b3a5bb46',
                  isFolder: false,
                  name: 'FindPeakElement.java',
                  code: 'public class FindPeakElement {\n    public static int getPeakIndex(int[] arr) {\n//        Brute force solution\n//        int n = arr.length;\n//        if (n == 1 || arr[0] > arr[1]) return 0;\n//        if (arr[n-1] > arr[n-2]) return n-1;\n//        for (int i = 1; i < arr.length - 1; i++) {\n//            if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {\n//                return i;\n//            }\n//        }\n//        return -1;\n//        Optimised approach\n        int n = arr.length;\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            boolean isLeftBig = mid > start && arr[mid - 1] > arr[mid];\n            boolean isRightBig = mid < end && arr[mid + 1] > arr[mid];\n            if (!isLeftBig && !isRightBig) return mid;\n            if (isLeftBig) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1,2,1,3,4};\n        int ans = getPeakIndex(arr);\n        System.out.println(arr[ans]);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '8862c7b6-967e-4a69-84ef-1b3f7e85473b',
                  isFolder: false,
                  name: 'FirstAndLastPosition.java',
                  code: 'import java.util.* ;\nimport java.io.*;\npublic class FirstAndLastPosition {\n    public static int lower_bound(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) >= k) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static int upper_bound(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) > k) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public  static int bSearchFirstLast(ArrayList<Integer> arr, int target, boolean lookLeft) {\n        int start = 0;\n        int end = arr.size() - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) == target) {\n                ans = mid;\n                if (lookLeft)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n            else  if (arr.get(mid) > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return ans;\n    }\n\n    public static int[] firstAndLastPosition(ArrayList<Integer> arr, int n, int k) {\n        // Write your code here.\n//        int first = lower_bound(arr, n, k);\n//        int last = upper_bound(arr, n, k) - 1;\n        int first = bSearchFirstLast(arr, k, true);\n        int last = bSearchFirstLast(arr, k, false);\n        return new int[] {first, last};\n    }\n\n};',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '345a0be0-f4db-46e3-948f-4c52b9ae2e27',
                  isFolder: false,
                  name: 'LowerBound.java',
                  code: 'public class LowerBound {\n//    Brute force is Linear search or a simple for loop\n\n//    If the arr has duplicates go left\n    public static int lowerBound(int []arr, int n, int x) {\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] >= x)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 3, 3, 5};\n//        int[] arr = {1, 2, 2, 2, 2, 2};\n        int ans = lowerBound(arr, arr.length, 2);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '971b6c69-f2c3-4246-a2c1-4c024febade9',
                  isFolder: false,
                  name: 'SearchIndexPosition.java',
                  code: 'public class SearchIndexPosition {\n    public static int searchInsert(int [] arr, int m){\n        // Write your code here.\n        int start = 0; \n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] >= m) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 4, 7};\n        int ans = searchInsert(arr, 9);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'ce09f415-8a5b-4c84-851f-2e7f6a0cdcd7',
                  isFolder: false,
                  name: 'SearchInRotatedArray1.java',
                  code: 'import java.util.*;\n\npublic class SearchInRotatedArray1 {\n    public static int search(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int midValue = arr.get(mid);\n            if (midValue == k) return mid;\n            if (midValue < arr.get(end)) {\n                if (k > midValue && k <= arr.get(end))\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            } else {\n                if (k >= arr.get(start) && k < midValue)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(8, 9, 4, 5));\n        int search = search(arr, 4, 8);\n        System.out.println(search);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'b9d2ccfc-1a60-4b0f-903c-3c41b50f1cf5',
                  isFolder: false,
                  name: 'SearchInRotatedArray2.java',
                  code: 'public class SearchInRotatedArray2 {\n    public static boolean searchInARotatedSortedArrayII(int[] arr, int k) {\n        int start = 0;\n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] == k) return true;\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                start++;\n                end--;\n                continue;\n            }\n            if (arr[mid] < arr[end]) { //Right sorted\n                if (k > arr[mid] && k <= arr[end])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            } else { // Left sorted\n                if (k >= arr[start] && k < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 1, 3, 3, 3, 3};\n        boolean found = searchInARotatedSortedArrayII(arr, 10);\n        System.out.println(found);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'b0fced99-6d98-4467-8720-3447a3a70163',
                  isFolder: false,
                  name: 'SingleNonDuplicateElementSortedArray.java',
                  code: 'public class SingleNonDuplicateElementSortedArray {\n    public static int singleNonDuplicate(int[] arr) {\n//        Write the code here\n//        int n = arr.length;\n//        for (int i = 0; i < n; i++) {\n//            if (i == 0) {\n//                if (arr[0] != arr[1])\n//                    return 0;\n//            } else if (i == n - 1) {\n//                if (arr[n-1] != arr[n-2])\n//                    return n-1;\n//            } else {\n//                if (arr[i-1] != arr[i] && arr[i+1] != arr[i])\n//                    return i;\n//            }\n//        }\n//        return -1;\n        int n = arr.length;\n        if (n == 1) return arr[0];\n        if (arr[0] != arr[1]) return arr[0];\n        if (arr[n-1] != arr[n-2]) return arr[n-1];\n        int start = 1;\n        int end = n-2;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] != arr[mid + 1] && arr[mid] != arr[mid - 1]) return arr[mid];\n            if ((mid%2==0 && arr[mid] == arr[mid+1]) || (mid%2==1 && arr[mid] == arr[mid - 1])) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6};\n        int ans = singleNonDuplicate(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '3d6c762e-163d-4b6d-9cf9-3f428626001a',
                  isFolder: false,
                  name: 'SortedArrayRotationCount.java',
                  code: 'public class SortedArrayRotationCount {\n    public static int findKRotation(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        int idx = 0;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n//            For removing duplicates\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                if (ans > arr[mid]) {\n                    ans = arr[mid];\n                    idx = mid;\n                }\n                end--;\n                continue;\n            }\n            if (arr[mid] > arr[end]) {\n                if (ans > arr[start]) {\n                    ans = arr[start];\n                    idx = start;\n                }\n                start = mid + 1;\n            } else {\n                if (ans > arr[mid]) {\n                    ans = arr[mid];\n                    idx = mid;\n                }\n                end = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 4, 4, 4, 4, 4, 4, 4};\n        int ans = findKRotation(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '31ea7f5d-390c-4c30-8af5-6045392dc2c9',
                  isFolder: false,
                  name: 'UpperBound.java',
                  code: 'public class UpperBound {\n    public static int upperBound(int[] arr, int x, int n) {\n        // Write your code here.\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] <= x) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 14, 16, 23};\n        int ans = upperBound(arr, 12, arr.length);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'd5a0156f-ab53-4495-9d07-8abf6601da7f',
                  isFolder: false,
                  name: 'FindPeakElementInGrid.java',
                  code: 'import java.util.Arrays;\n\npublic class FindPeakElementInGrid {\n    public static int[] findPeakGrid(int [][]mat) {\n// Brute force solution\n//        int n = mat.length;\n//        int m = mat[0].length;\n//        int max = Integer.MIN_VALUE;\n//        int[] ans = {-1, -1};\n//        for (int i = 0; i < n; i++) {\n//            for (int j = 0; j < m; j++) {\n//                if (mat[i][j] > max) {\n//                    max = mat[i][j];\n//                    ans[0] = i;\n//                    ans[1] = j;\n//                }\n//            }\n//        }\n//        return ans;\n\n        // Optimal solution\n        int start = 0;\n        int end = mat[0].length - 1;\n        while (start <= end) {\n            int maxRow = 0;\n            int mid = start + (end - start)/2;\n            for (int i = 0; i < mat.length; i++) {\n                if (mat[maxRow][mid] < mat[i][mid])\n                    maxRow = i;\n            }\n            boolean leftBig = mid > start && mat[maxRow][mid] < mat[maxRow][mid-1];\n            boolean rightBig = mid < end && mat[maxRow][mid] < mat[maxRow][mid+1];\n            if (!leftBig && !rightBig) return new int[]{maxRow, mid};\n            if (leftBig) end = mid - 1;\n            else start = mid + 1;\n        }\n        return new int[]{-1, -1};\n    }\n\n    public static void main(String[] args) {\n        int[][] values = {\n                {6},\n                {1},\n                {10}\n        };\n        int[] ans = findPeakGrid(values);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '4847b1d6-f277-4be2-9761-30fa18cc5cce',
                  isFolder: false,
                  name: 'MatrixMaximumOnesRow.java',
                  code: 'import java.util.ArrayList;\n\npublic class MatrixMaximumOnesRow {\n    public static int maximumOnesRow(ArrayList<ArrayList<Integer>> matrix, int n, int m) {\n        //\t  Brute force O(m*n)\n//        int maxRow = 0;\n//        int maxCount = 0;\n//        for (int i = 0; i < n; i++) {\n//            int count = 0;\n//            for (int j = 0; j < m; j++) {\n//                if (matrix.get(i).get(j) == 1) count++;\n//            }\n//            if (count > maxCount) {\n//                maxCount = count;\n//                maxRow = i;\n//            }\n//        }\n//        return maxRow;\n\n//        Optimal solution\n        int lastIdx = m - 1;\n        int maxRow = -1;\n        for (int i = 0; i < n; i++) {\n            if (lastIdx < 0) break;\n            if (matrix.get(i).get(lastIdx) == 1) {\n                while (lastIdx >= 0 && matrix.get(i).get(lastIdx) == 1) {\n                    lastIdx--;\n                }\n                maxRow = i;\n            }\n        }\n        return maxRow;\n    }\n\n    public static void main(String[] args) {\n        int[][] values = {\n                {0, 0, 1},\n                {0, 0, 1},\n                {0, 1, 1}\n        };\n\n        // Create a 2D ArrayList and populate it with values from the array\n        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();\n        for (int[] row : values) {\n            ArrayList<Integer> arrayListRow = new ArrayList<>();\n            for (int num : row) {\n                arrayListRow.add(num);\n            }\n            matrix.add(arrayListRow);\n        }\n        int ans = maximumOnesRow(matrix, 3,3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: 'd8ca3a79-e5fe-4554-b0cc-3e98affb1880',
                  isFolder: false,
                  name: 'MatrixMedian.java',
                  code: 'public class MatrixMedian {\n    public static int getCount(int[] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static int findMedian(int[][] M, int m, int n) {\n        // Write your code here\n        int start = 1;\n        int end = 1000000000;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i = 0; i < M.length; i++) {\n                count += getCount(M[i], mid);\n            }\n            if (count <= (n*m)/2) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int row = 3, col = 3;\n        int[][] arr = {{1, 3, 8},\n                {2, 3, 4},\n                {1, 2, 5}};\n        System.out.println("The median of the row-wise sorted matrix is: "+ findMedian(arr, row, col));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: 'b29a2e50-d7cf-46f4-a94b-bee63dfb33ce',
                  isFolder: false,
                  name: 'Search2DMatrixRowsSorted.java',
                  code: 'import java.util.ArrayList;\n\npublic class Search2DMatrixRowsSorted {\n    //    A Row-wise sorted matrix where the first element of each row is\n//    greater than the last element of previous row\n    static boolean searchMatrix(ArrayList<ArrayList<Integer>> mat, int target) {\n        // Optimised\n        int n = mat.size();\n        int m = mat.get(0).size();\n        int start = 0, end = n*m - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int element = mat.get(mid/m).get(mid%m);\n            if (element == target) return true;\n            if (element > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        int[][] values = {\n                {1, 2, 4},\n                {6, 7, 8},\n                {9, 10, 34}\n        };\n\n        // Create a 2D ArrayList and populate it with values from the array\n        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();\n        for (int[] row : values) {\n            ArrayList<Integer> arrayListRow = new ArrayList<>();\n            for (int num : row) {\n                arrayListRow.add(num);\n            }\n            matrix.add(arrayListRow);\n        }\n        boolean ans = searchMatrix(matrix, 78);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '8e33c60d-0270-4e0d-a93e-898fda600fad',
                  isFolder: false,
                  name: 'SearchRowColSortedMatrix.java',
                  code: 'import java.util.ArrayList;\n\npublic class SearchRowColSortedMatrix {\n    public static int bS(int[] arr, int target) {\n        int start = 0, end = arr.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target) end = mid - 1;\n            else start = mid + 1;\n        }\n        return -1;\n    }\n    public static boolean searchElement(int [][]mat, int target) {\n//        Better solution\n//        int n = mat.length;\n//        int m = mat[0].length;\n//        // Write your code here.\n//        for (int i = 0; i < n; i++) {\n//            if (mat[i][m-1] >= target) {\n//                int result = bS(mat[i], target);\n//                if (result != -1) return true;\n//                break;\n//            }\n//        }\n//        return false;\n        int j = mat[0].length - 1;\n        int i = 0;\n        while (i < mat.length && j >= 0) {\n            System.out.println(mat[i][j]);\n            if (mat[i][j] == target) return true;\n            if (mat[i][j] < target) i++;\n            else if (mat[i][j] > target) j--;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[][] matrix = {\n                {1, 2, 4},\n                {6, 7, 8},\n                {9, 10, 34}\n        };\n        boolean ans = searchElement(matrix, 11);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '610d3189-11d5-4e1f-abb9-a97626ec2ec0',
                  isFolder: false,
                  name: 'AggressiveCows.java',
                  code: 'import java.util.Arrays;\npublic class AggressiveCows {\n    public static boolean isPossible(int[] stalls, int k, int minDiff) {\n        int totalCows = 1;\n        int last = stalls[0];\n        for (int i = 1; i < stalls.length; i++) {\n            if (stalls[i] - last >= minDiff) {\n                totalCows++;\n                last = stalls[i];\n            }\n            if (totalCows >= k) return true;\n        }\n        return false;\n    }\n    public static int aggressiveCows(int []stalls, int k) {\n        int n = stalls.length;\n        Arrays.sort(stalls);\n//        Brute force\n//        int maxDifference = stalls[n-1] - stalls[0];\n//        for (int i = 1; i <= maxDifference; i++) {\n//            if (!isPossible(stalls, k, i)) return i-1;\n//        }\n//        return maxDifference;\n\n//        Optimised approach\n        int start = 1, end = stalls[n-1] - stalls[0];\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(stalls, k, mid)) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return end;\n    }\n    public static void main(String[] args) {\n        int[] stalls = {4,2,1,3,6};\n        int k = 2;\n        int ans = aggressiveCows(stalls, k);\n        System.out.println("The maximum possible minimum distance is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'b35529cb-6626-440a-9bce-1f0b647f2d5e',
                  isFolder: false,
                  name: 'BookAllocation.java',
                  code: 'import java.util.*;\npublic class BookAllocation {\n    public static boolean isPossible(ArrayList<Integer> arr, int j, int m) {\n        int students = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr.get(i) <= j) {\n                sum += arr.get(i);\n            } else {\n                sum = arr.get(i);\n                students++;\n            }\n        }\n        return students <= m;\n    }\n    public static int findPages(ArrayList<Integer> arr, int n, int m) {\n//        Brute force\n//        if (m > n) return -1;\n//        int min = arr.get(0);\n//        int max = arr.get(0);\n//        for (int i = 1; i < n; i++) {\n//            min = Math.max(min, arr.get(i));\n//            max += arr.get(i);\n//        }\n//        for (int j = min; j <= max; j++) {\n//            if (isPossible(arr, j, m)) return j;\n//        }\n//        return -1;\n\n//        Optimized\n        if (m > n) return -1;\n        int start = arr.get(0);\n        int end = arr.get(0);\n        for (int i = 1; i < n; i++) {\n            start = Math.max(start, arr.get(i));\n            end += arr.get(i);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, mid, m))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(25, 46, 28, 49, 24));\n        int n = 5;\n        int m = 4;\n        int ans = findPages(arr, n, m);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '51457402-df9c-4d60-a1df-124791231487',
                  isFolder: false,
                  name: 'CapacityToShipPackages.java',
                  code: 'public class CapacityToShipPackages {\n    public static boolean isPossible(int[] arr, int d, int capaciity) {\n        int total = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] <= capaciity) {\n                sum += arr[i];\n            } else {\n                total++;\n                sum = arr[i];\n            }\n        }\n        return total <= d;\n    }\n\n    public static int leastWeightCapacity(int[] arr, int d) {\n        // Write your code here.\n//        Brute force\n//        int max = arr[0];\n//        int min = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            max += arr[i];\n//            min = Math.max(arr[i], min);\n//        }\n//        for (int i = min; i <= max; i++) {\n//            if (isPossible(arr, d, i)) return i;\n//        }\n//        return -1;\n\n//        Optimised approach\n        int start = arr[0], end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end += arr[i];\n            start = Math.max(arr[i], start);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, d, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 4, 5, 2, 3, 4, 5, 6};\n        int ans = leastWeightCapacity(arr, 5);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'd9524492-e2ce-48c4-9395-ea3d2f2ec4c4',
                  isFolder: false,
                  name: 'FindSmallestDivisor.java',
                  code: 'public class FindSmallestDivisor {\n    public static boolean isPossible(int[] arr, int limit, int divisor) {\n        int total = 0;\n        for (int i = 0; i < arr.length; i++) {\n            total += (arr[i] + divisor - 1) / divisor;\n        }\n        return total <= limit;\n    }\n    public static int smallestDivisor(int[] arr, int limit) {\n        // Write your coder here\n//        Brute force\n//        int maxi = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            maxi = Math.max(maxi, arr[i]);\n//        }\n//        for (int ans = 1; ans <= maxi; ans++) {\n//            if (isPossible(arr, limit, ans)) return ans;\n//        }\n//        return -1;\n\n//        Optimal approach\n        int start = 1;\n        int end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end = Math.max(end, arr[i]);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, limit, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int ans = smallestDivisor(arr, 8);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'd92f99a7-5e16-4318-b34b-3e05d6cfb269',
                  isFolder: false,
                  name: 'KokoEatingBananas.java',
                  code: 'public class KokoEatingBananas {\n    public static boolean isPossible(int[] v, int h, int rate) {\n        int hourCount = 0;\n        for (int i = 0; i < v.length; i++) {\n            hourCount += (v[i] + rate - 1)/rate;\n            if (hourCount > h) return false;\n        }\n        return hourCount <= h;\n    }\n    public static int minimumRateToEatBananas(int []v, int h) {\n        // Write Your Code Here\n//        Brute force\n//        int max = v[0];\n//        for (int i: v) {\n//            max = Math.max(max, i);\n//        }\n//        for (int ans = 1; ans <= max; ans++) {\n//            if (isPossible(v, h, ans)) return ans;\n//        }\n//        return -1;\n\n//        Best approach: Binary search\n        int start = 1;\n        int end = v[0];\n        for (int i = 1; i < v.length; i++) {\n            end = Math.max(end, v[i]);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(v, h, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] v = {7, 15, 6, 3};\n        int h = 8;\n        int ans = minimumRateToEatBananas(v,h);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'fb493e17-a9ae-4dd9-ba68-86d739115037',
                  isFolder: false,
                  name: 'KthElementOf2SortedArrays.java',
                  code: 'import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class KthElementOf2SortedArrays {\n    public static int kthElement(ArrayList<Integer> a, ArrayList<Integer> b, int n, int m, int k) {\n//        Brute force solution\n//        int[] temp = new int[n + m];\n//        int left = 0, right = 0, i = 0;\n//        while (left < n && right < m) {\n//            if (a.get(left) <= b.get(right))\n//                temp[i++] = a.get(left++);\n//            else\n//                temp[i++] = b.get(right++);\n//        }\n//        while (left < n) temp[i++] = a.get(left++);\n//        while (right < m) temp[i++] = b.get(right++);\n//        return temp[k-1];\n\n//        Better solution\n//        int left = 0, right = 0, i = 0;\n//        while (left < n && right < m) {\n//            if (a.get(left) <= b.get(right)) {\n//                if (i == k - 1) return a.get(left);\n//                left++;\n//            } else {\n//                if (i == k - 1) return b.get(right);\n//                right++;\n//            }\n//            i++;\n//        }\n//        while (left < n) {\n//            if (i == k - 1) return a.get(left);\n//            left++;\n//            i++;\n//        }\n//        while (right < m) {\n//            if (i == k - 1) return b.get(right);\n//            right++;\n//            i++;\n//        }\n//        return Math.max(a.get(n-1), b.get(m-1));\n\n//        Optimal approach\n        if (n > m) return kthElement(b, a, m, n, k);\n        int start = Math.max(0, k-m), end = Math.min(k,n);\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int mid2 = k - mid;\n            int l1 = mid > 0 ? a.get(mid - 1) : Integer.MIN_VALUE;\n            int l2 = mid2 > 0 ? b.get(mid2 - 1) : Integer.MIN_VALUE;\n            int r1 = mid < n? a.get(mid) : Integer.MAX_VALUE;\n            int r2 = mid2 < m? b.get(mid2) : Integer.MAX_VALUE;\n            if (l1 <= r2 && l2 <= r1) return Math.max(l1, l2);\n            if (l1 > r2) end = mid - 1;\n            else start = mid + 1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr1 = new ArrayList<>(Arrays.asList(2, 3, 6, 7, 9));\n        ArrayList<Integer> arr2 = new ArrayList<>(Arrays.asList(1, 4, 8, 10));\n        int m = arr1.size();\n        int n = arr2.size();\n        int k = 5;\n        System.out.println("The element at the kth position in the final sorted array is " + kthElement(arr1, arr2, m, n, k));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '1b9a74fe-9c7b-490c-9267-40600b69a4de',
                  isFolder: false,
                  name: 'KthMissingPositiveNumber.java',
                  code: 'public class KthMissingPositiveNumber {\n    public static int missingK(int[] arr, int n, int k) {\n//        Brute force solution\n//        for (int i = 0; i < n; i++) {\n//            if (arr[i] > k) break;\n//            k++;\n//        }\n//        return k;\n\n//        Optimised approach\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int missing = arr[mid] - (mid + 1);\n            if (missing < k) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start + k;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 4, 5, 7};\n        int ans = missingK(arr, arr.length, 3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '3025622f-253b-46f0-af6a-50c326b5d9b3',
                  isFolder: false,
                  name: 'MedianOfTwoSortedArrays.java',
                  code: 'public class MedianOfTwoSortedArrays {\n    public static double median(int[] a, int[] b) {\n//        Brute force solution\n//        Use another array ans add all elements in sorted order, then calculate median\n//        int n1 = a.length;\n//        int n2 = b.length;\n//        int[] temp = new int[n1 + n2];\n//        int left = 0, right = 0, i = 0;\n//        while (left < n1 && right < n2) {\n//            if (a[left] <= b[right]) {\n//                temp[i++] = a[left++];\n//            } else {\n//                temp[i++] = b[right++];\n//            }\n//        }\n//        while (left < n1) {\n//            temp[i++] = a[left++];\n//        }\n//        while (right < n2) {\n//            temp[i++] = b[right++];\n//        }\n////        returning median\n//        int m1 = temp.length / 2;\n//        if (temp.length % 2 == 0) {\n//            int m2 = m1 - 1;\n//            return (temp[m1] + temp[m2]) / 2.0;\n//        }\n//        return temp[m1];\n\n//        Better solution\n//        We don\'t need to store all the elements just medians elements are needed to calculate median\n//        int n1 = a.length, n2 = b.length;\n//        int left = 0, right = 0, i = 0;\n//        int m1 = (n1 + n2) / 2;\n//        int mid1 = -1,  mid2 = -1;\n//        while (left < n1 && right < n2) {\n//            if (a[left] <= b[right]) {\n//                if (i == m1 - 1) mid1 = a[left];\n//                else if (i == m1) mid2 = a[left];\n//                left++;\n//            } else {\n//                if (i == m1 - 1) mid1 = b[right];\n//                else if (i == m1) mid2 = b[right];\n//                right++;\n//            }\n//            i++;\n//        }\n//        while (left < n1) {\n//            if (i == m1 - 1) mid1 = a[left];\n//            else if (i == m1) mid2 = a[left];\n//            i++;\n//            left++;\n//        }\n//        while (right < n2) {\n//            if (i == m1 - 1) mid1 = b[right];\n//            else if (i == m1) mid2 = b[right];\n//            i++;\n//            right++;\n//        }\n//        if ((n1 + n2) % 2 == 1) return mid2;\n//        return (double)(mid1 + mid2) / 2.0;\n\n//        Optimal solution\n//        Use binary search to get the mid value of the merged array (without merging)\n        int n1 = a.length, n2 = b.length;\n        if (n1 > n2) return median(b, a);\n        int n = n1 + n2;\n        int minElements = (n + 1) / 2;\n        int start = 0, end = n1;\n        while (start <= end) {\n            int mid1 = start + (end - start) / 2;\n            int mid2 = minElements - mid1;\n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE;\n            int r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\n            if (mid1 > 0) l1 = a[mid1 - 1];\n            if (mid2 > 0) l2 = b[mid2 - 1];\n            if (mid1 < n1) r1 = a[mid1];\n            if (mid2 < n2) r2 = b[mid2];\n            if (l1 <= r2 && l2 <= r1) {\n                double median = Math.max(l1, l2);\n                if (n % 2 == 0) {\n                    median += Math.min(r1, r2);\n                    return median / 2.0;\n                }\n                return median;\n            }\n            if (l1 > r2) end = mid1 - 1;\n            else start = mid1 + 1;\n        }\n        return 0.0;\n    }\n\n    public static void main(String[] args) {\n        int[] a = {2, 4, 6};\n        int[] b = {1, 3};\n        System.out.println("The median of two sorted arrays is " + median(a, b));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '67495ef2-a765-4d42-ade5-e316a7392479',
                  isFolder: false,
                  name: 'MinimiseMaximumDistanceBetweenGasStations.java',
                  code: 'import java.util.*;\n\npublic class MinimiseMaximumDistanceBetweenGasStations {\n    public static double minimiseMaxDistance(int []arr, int k){\n//        Brute force\n//        1. Make a sections array to store the count of added gas stations in each section\n//        int[] sections = new int[arr.length - 1];\n//        for (int i = 0; i < k; i++) {\n//            double maxVal = -1;\n//            int maxIdx = -1;\n//            for (int j = 0; j < sections.length; j++) {\n//                double distance = arr[j+1] - arr[j];\n//                double sectionLength = distance/(sections[j]+1);\n//                if (sectionLength > maxVal) {\n//                    maxVal = sectionLength;\n//                    maxIdx = j;\n//                }\n//            }\n//            sections[maxIdx]++;\n//        }\n//        2. Iterate sections to get the maxLength of the difference\n//        double maxLength = 0;\n//        for (int i  = 0; i < sections.length; i++) {\n//            double distance = arr[i+1] - arr[i];\n//            double len = distance / (sections[i]+ 1);\n//            maxLength = Math.max(maxLength, len);\n//        }\n//        return maxLength;\n\n//        Optimised approach - Priority queue\n//        Add all sections current length to the pq\n//        Iterate on range k and update the highest element pair in pq\n//        return the pq.peek();\n        PriorityQueue<Map.Entry<Double, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByKey(Collections.reverseOrder()));\n        for (int i = 0; i < arr.length - 1; i++) {\n            pq.add(new AbstractMap.SimpleEntry<>((double) arr[i+1] - arr[i], i));\n        }\n        int[] sections = new int[arr.length - 1];\n        for (int j = 0; j < k; j++) {\n            int idx = pq.remove().getValue();\n            sections[idx]++;\n            double distance = arr[idx+1] - arr[idx];\n            double sectionLength = distance / (sections[idx] + 1);\n            pq.add(new AbstractMap.SimpleEntry<>(sectionLength, idx));\n        }\n        return pq.remove().getKey();\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int k = 4;\n        double ans = minimiseMaxDistance(arr, k);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '3476977d-5d62-439e-970e-6c9a8d4fc13e',
                  isFolder: false,
                  name: 'NthRoot.java',
                  code: 'public class NthRoot {\n    public static int getNthPower(int num, int pow, int m) {\n        long ans = 1;\n        for (int i = 0; i < pow; i++) {\n            ans *= num;\n            if (ans > m) return 1;\n        }\n        if (ans == m) return 0;\n        return -1;\n    }\n    public static int getNthRoot(int n, int m) {\n//        for (int i = 1; i < m; i++) {\n//            int x = getNthPower(i, n);\n//            if (x == m) return i;\n//        }\n//        return -1;\n\n        int start = 0;\n        int end = m;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int res = getNthPower(mid, n, m);\n            if (res == 0) return mid;\n            if (res == 1) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        int n = 9;\n        int m = 262144;\n        int ans = getNthRoot(n,m);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '1b1c395b-bc0a-46dc-8d9c-69457e9b72eb',
                  isFolder: false,
                  name: 'PaintersPartition.java',
                  code: 'import java.util.ArrayList;\n\npublic class PaintersPartition {\n    public static boolean isPossible(ArrayList<Integer> arr, int k, int maxArea) {\n        int sum = 0;\n        int totalPainters = 1;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr.get(i) <= maxArea) {\n                sum += arr.get(i);\n            } else {\n                sum = arr.get(i);\n                totalPainters++;\n            }\n        }\n        return totalPainters <= k;\n    }\n    public static int findLargestMinDistance(ArrayList<Integer> arr, int k) {\n        int min = arr.get(0);\n        int max = arr.get(0);\n        for (int i = 1; i < arr.size(); i++) {\n            min = Math.max(min, arr.get(i));\n            max += arr.get(i);\n        }\n\n//        Brute force\n//        for (int i = min; i <= max; i++) {\n//            if (isPossible(arr, k, i)) return i;\n//        }\n//        return -1;\n\n//        Optimised solution\n        int start = min, end = max;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, k, mid))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n\n    }\n    public static void main(String[] args) {\n\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'be285026-6c92-4329-8e72-f540e2780646',
                  isFolder: false,
                  name: 'RoseGarden.java',
                  code: 'public class RoseGarden {\n    public static boolean isPossible(int[] arr, int r, int b, int d) {\n        int totalBouquets = 0;\n        int rCount = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] <= d) {\n                rCount++;\n            } else {\n                totalBouquets += rCount / r;\n                rCount = 0;\n            }\n        }\n        totalBouquets += rCount / r;\n        return totalBouquets >= b;\n    }\n\n    public static int roseGarden(int[] arr, int r, int b) {\n//        Brute force\n//        int max = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            max = Math.max(max, arr[i]);\n//        }\n//        for (int ans = 1; ans <= max; ans++) {\n//            if (isPossible(arr, r, b, ans)) return ans;\n//        }\n//        return -1;\n\n//        Optimised approach\n        if (b*r > arr.length) return -1;\n        int start = arr[0];\n        int end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end = Math.max(arr[i], end);\n            start = Math.min(arr[i], start);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, r, b, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 6, 8, 13, 17, 6, 16};\n        int ans = roseGarden(arr, 2, 2);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '31fe6862-061f-47ae-b44e-337519906372',
                  isFolder: false,
                  name: 'SplitArrayLargestSum.java',
                  code: 'public class SplitArrayLargestSum {\n\n    public static boolean isPossible(int[] arr, int limit, int splits) {\n        int totalSplits = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] <= limit) {\n                sum += arr[i];\n            } else {\n                sum = arr[i];\n                totalSplits++;\n            }\n            if (totalSplits > splits) return false;\n        }\n        return true;\n    }\n\n    public static int largestSubarraySumMinimized(int []arr, int k) {\n        // Write Your Code Here\n//        Brute same as book allocation problem\n        int n = arr.length;\n        if (k > n) return -1;\n        int start = arr[0];\n        int end = arr[0];\n        for (int i = 1; i < n; i++) {\n            start = Math.max(start, arr[i]);\n            end += arr[i];\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, mid, k))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] a = {10, 20, 30, 40};\n        int k = 2;\n        int ans = largestSubarraySumMinimized(a, k);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '551140bf-797f-4628-aafd-a0df03a14bc4',
                  isFolder: false,
                  name: 'SquareRoot.java',
                  code: 'public class SquareRoot {\n    public static int getSQRT(int x) {\n//        Brute force\n//        int ans = 1;\n//        for (int i = 1; i <= x; i++) {\n//            if (i*i <= x) {\n//                ans = i;\n//            } else {\n//                break;\n//            }\n//        }\n//        return ans;\n\n//        Optimised approach\n        int start = 1;\n        int end = x;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int root = x/mid;\n            if (mid == root) {\n                return mid;\n            }\n            if (mid > root) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return end;\n    }\n    public static void main(String[] args) {\n        int num = 21;\n        int ans = getSQRT(num);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
              ],
            },
            {
              id: '6fa0bc49-1211-425c-8d38-4a2d339e8c4a',
              isFolder: true,
              name: 'Binary Search Trees',
              content: [
                {
                  id: 'c21c487d-0a2e-4c59-be0e-65571de4e780',
                  isFolder: false,
                  name: 'MinMaxInBST.java',
                  code: 'public class MinMaxInBST {\n    public static int minValue(TreeNode root) {\n        // Write your code here.\n        TreeNode temp = root;\n        if (root == null) return -1;\n        while (temp.left != null) {\n            temp = temp.left;\n        }\n        return temp.val;\n    }\n    public static int maxValue(TreeNode root) {\n        // Write your code here.\n        TreeNode temp = root;\n        if (root == null) return -1;\n        while (temp.right != null) {\n            temp = temp.right;\n        }\n        return temp.val;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-element-in-bst_8160462',
                  notes: '',
                  tags: ['Concepts'],
                },
                {
                  id: 'dce131b7-00dd-4090-a356-f7bee642d5ae',
                  isFolder: false,
                  name: 'SearchInBST.java',
                  code: 'public class SearchInBST {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if (root == null) return null;\n        if (root.val == val) return root;\n        if (val > root.val) return searchBST(root.right, val);\n        return searchBST(root.left, val);\n    }\n}',
                  link: 'https://leetcode.com/problems/search-in-a-binary-search-tree/',
                  notes: '',
                  tags: ['Concepts'],
                },
                {
                  id: 'bf01a7b8-63fe-4bdc-aac8-881a88479fbd',
                  isFolder: false,
                  name: 'BSTFromPreorder.java',
                  code: 'import java.util.*;\npublic class BSTFromPreorder {\n    public TreeNode bstFromPreorder(int[] preorder) {\n        if (preorder.length == 0) return null;\n        TreeNode root = new TreeNode(preorder[0]);\n        int start = 1;\n        for (int i = 1; i < preorder.length; i++) {\n            if (preorder[0] < preorder[i]) break;\n            start++;\n        }\n        int[] left = Arrays.copyOfRange(preorder, 1, start);\n        int[] right = Arrays.copyOfRange(preorder, start, preorder.length);\n        root.left = bstFromPreorder(left);\n        root.right = bstFromPreorder(right);\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '2e81f813-da3c-4d65-a365-300aee0cf059',
                  isFolder: false,
                  name: 'CeilBST.java',
                  code: 'public class CeilBST {\n    public  static int findCeil(TreeNode node, int x) {\n        // Write your code here\n        TreeNode curr = node;\n        int ceil = -1;\n        while (curr != null) {\n            if (curr.val == x) {\n                return curr.val;\n            }\n            if (curr.val > x) {\n                ceil = curr.val;\n                curr = curr.left;\n            } else {\n                curr = curr.right;\n            }\n        }\n        return ceil;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/ceil-from-bst_920464',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '7556ce8a-3da6-4c4f-8114-323c64dfb440',
                  isFolder: false,
                  name: 'DeleteNodeBST.java',
                  code: 'public class DeleteNodeBST {\n    public int getMinNodeVal(TreeNode root) {\n        TreeNode curr = root;\n        while (curr.left != null)\n            curr = curr.left;\n        return curr.val;\n    }\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) return null;\n        if (key > root.val)\n            root.right = deleteNode(root.right, key);\n        else if (key < root.val)\n            root.left = deleteNode(root.left, key);\n        else {\n            if (root.left == null)\n                root = root.right;\n            else if (root.right == null)\n                root = root.left;\n            else {\n                root.val = getMinNodeVal(root.right);\n                root.right = deleteNode(root.right, root.val);\n            }\n        }\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/delete-node-in-a-bst/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '0bc43ccb-a955-439a-b118-47c6376aba91',
                  isFolder: false,
                  name: 'FixBST.java',
                  code: 'public class FixBST {\n    TreeNode node1, node2, prev;\n    public void inoFix(TreeNode root) {\n        if (root == null) return;\n        inoFix(root.left);\n        if (prev != null && prev.val > root.val) {\n            if (node1 == null) {\n                node1 = prev;\n            }\n            node2 = root;\n        }\n        prev = root;\n        inoFix(root.right);\n    }\n    public void recoverTree(TreeNode root) {\n        inoFix(root);\n        int temp = node1.val;\n        node1.val = node2.val;\n        node2.val = temp;\n    }\n}',
                  link: 'https://leetcode.com/problems/recover-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: 'f697137e-5569-4644-ae38-22eb5d82d3e2',
                  isFolder: false,
                  name: 'FloorBST.java',
                  code: 'public class FloorBST {\n    public static int Floor(TreeNode node, int x) {\n        TreeNode curr = node;\n        int floor = -1;\n        while (curr != null) {\n            if (curr.val == x) return x;\n            if (curr.val < x) {\n                floor = curr.val;\n                curr = curr.right;\n            } else {\n                curr = curr.left;\n            }\n        }\n        return floor;\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/floor-from-bst_625868',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '40a5109d-ef8f-4b31-aa39-3811e4d35847',
                  isFolder: false,
                  name: 'InorderSuccessorPredecessorOfBST.java',
                  code: 'import java.util.*;\npublic class InorderSuccessorPredecessorOfBST {\n    public static List<Integer> predecessorSuccessor(TreeNode root, int key) {\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        // predecessor\n        int p = -1;\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.val < key) {\n                p = curr.val;\n                curr = curr.right;\n            } else {\n                curr = curr.left;\n            }\n        }\n        // successor\n        int s = -1;\n        curr = root;\n        while (curr != null) {\n            if (curr.val > key) {\n                s = curr.val;\n                curr = curr.left;\n            } else {\n                curr = curr.right;\n            }\n        }\n        ans.add(p);\n        ans.add(s);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/predecessor-and-successor-in-bst_893049',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '5d8c24df-53bd-4b6a-9701-77c8986b9f1a',
                  isFolder: false,
                  name: 'InsertNodeBST.java',
                  code: 'public class InsertNodeBST {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) return new TreeNode(val);\n        if (val > root.val) {\n            root.right = insertIntoBST(root.right, val);\n        } else {\n            root.left = insertIntoBST(root.left, val);\n        }\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/insert-into-a-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '3fe0d498-0937-4b5f-a4fb-ea50f6fa6f7d',
                  isFolder: false,
                  name: 'KthSmallestElementBST.java',
                  code: 'public class KthSmallestElementBST {\n    public static void solve(TreeNode root, int[] ans, int k) {\n        if (root == null) return;\n        solve(root.left, ans, k);\n        ans[1]++;\n        if (ans[1] == k) {\n            ans[0] = root.val;\n            return;\n        }\n        solve(root.right, ans, k);\n    }\n    public int kthSmallest(TreeNode root, int k) {\n        int[] ans = { -1, 0 };\n        solve(root, ans, k);\n        return ans[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/kth-smallest-element-in-a-bst/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '017e95e0-8b24-4399-97b6-4ec4901fdb04',
                  isFolder: false,
                  name: 'LCAOfBST.java',
                  code: 'public class LCAOfBST {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right ,p,q);\n        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left ,p,q);\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '067fa1d7-a224-43f1-98c5-160d0619899a',
                  isFolder: false,
                  name: 'Merge2BST.java',
                  code: '// https://www.codingninjas.com/studio/problems/merge-two-bsts_920474\nimport java.util.*;\npublic class Merge2BST {\n    public static List<Integer> mergeLL(TreeNode list1, TreeNode list2, List<Integer> ans) {\n        TreeNode i = list1;\n        TreeNode j = list2;\n        while (i != null && j != null) {\n            if (i.val <= j.val) {\n                ans.add(i.val);\n                i = i.right;\n            } else {\n                ans.add(j.val);\n                j = j.right;\n            }\n        }\n        while (i != null) {\n            ans.add(i.val);\n            i = i.right;\n        }\n        while (j != null) {\n            ans.add(j.val);\n            j = j.right;\n        }\n        return ans;\n    }\n    public static List<Integer> merge(List<Integer> list1, List<Integer> list2) {\n        List<Integer> ans = new ArrayList<>();\n        int i = 0, j = 0;\n        while (i < list1.size() && j < list2.size()) {\n            int l1 = list1.get(i), l2 = list2.get(j);\n            if (l1 <= l2) {\n                ans.add(l1);\n                i++;\n            } else {\n                ans.add(l2);\n                j++;\n            }\n        }\n        while (i < list1.size()) ans.add(list1.get(i++));\n        while (j < list2.size()) ans.add(list2.get(j++));\n        return ans;\n    }\n    public static void ino(TreeNode root, List<Integer> ans) {\n        if (root == null) return;\n        Stack<TreeNode> st = new Stack<>();\n        TreeNode node = root;\n        while (node != null || !st.isEmpty()) {\n            while (node != null) {\n                node = st.push(node).left;\n            }\n            node = st.pop();\n            ans.add(node.val);\n            node = node.right;\n        }\n    }\n\n    static TreeNode head = new TreeNode(0);\n    public static void sortedFlatten(TreeNode root) {\n        if (root == null) return;\n        sortedFlatten(root.left);\n        head.right = root;\n        head = head.right;\n        head.left = null;\n        sortedFlatten(root.right);\n    }\n\n    public static List<Integer> mergeBST(TreeNode root1, TreeNode root2) {\n        // Write your code here.\n        // List<Integer> list1 = new ArrayList<>();\n        // List<Integer> list2 = new ArrayList<>();\n        // return merge(list1, list2);\n        TreeNode list1 = head;\n        sortedFlatten(root1);\n        head = new TreeNode(0);\n        TreeNode list2 = head;\n        sortedFlatten(root2);\n        List<Integer> ans = new ArrayList<>();\n        return mergeLL(list1.right, list2.right, ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '4379f824-982b-457c-93c9-c999e956d6b8',
                  isFolder: false,
                  name: 'SizeOfLargestBST.java',
                  code: 'public class SizeOfLargestBST {\n    static class TreeInfo {\n        int size, max, min;\n        TreeInfo(int s, int min, int max) {\n            this.size = s;\n            this.min = min;\n            this.max = max;\n        }\n    }\n    public static TreeInfo solve(TreeNode root) {\n        if (root == null)\n            return new TreeInfo(0, Integer.MAX_VALUE, Integer.MIN_VALUE);\n        if (root.left == null && root.right == null)\n            return new TreeInfo(1, root.val, root.val);\n        TreeInfo l = solve(root.left);\n        TreeInfo r = solve(root.right);\n        if (root.val > l.max && root.val < r.min) {\n            int min = Math.min(l.min, root.val);\n            int max = Math.max(r.max, root.val);\n            return new TreeInfo(l.size + r.size + 1, min, max);\n        }\n        return new TreeInfo(Math.max(l.size, r.size), Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    public static int largestBST(TreeNode root) {\n        // Write your code here.\n        TreeInfo temp = solve(root);\n        return temp.size;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/size-of-largest-bst-in-binary-tree_893103',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '124cabec-5e9c-492b-ab20-40704281946f',
                  isFolder: false,
                  name: 'TwoSum4.java',
                  code: 'import java.util.*;\npublic class TwoSum4 {\n    public static void ino(TreeNode root, List<Integer> ans) {\n        if (root == null) return;\n        ino(root.left, ans);\n        ans.add(root.val);\n        ino(root.right, ans);\n    }\n    public boolean findTarget(TreeNode root, int k) {\n        List<Integer> inorder = new ArrayList<>();\n        ino(root, inorder);\n        int i = 0, j = inorder.size() - 1;\n        while (i < j) {\n            int sum = inorder.get(i) + inorder.get(j);\n            if (sum > k) j--;\n            else if (sum < k) i++;\n            else return true;\n        }\n        return false;\n    }\n}',
                  link: 'https://leetcode.com/problems/two-sum-iv-input-is-a-bst/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: 'd141a32a-72a3-4314-b721-225582f4ed5f',
                  isFolder: false,
                  name: 'ValidateBST.java',
                  code: 'public class ValidateBST {\n    public static boolean solve(TreeNode root, Integer low, Integer high) {\n        if (root == null) return true;\n        if (low != null && root.val <= low) return false;\n        if (high != null && root.val >= high) return false;\n        return solve(root.left, low, root.val) && solve(root.right, root.val, high);\n    }\n    public boolean isValidBST(TreeNode root) {\n        return solve(root, null, null);\n    }\n}',
                  link: 'https://leetcode.com/problems/validate-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
              ],
            },
            {
              id: 'c53c1cfd-f1ec-427e-9930-c539c05efb37',
              isFolder: true,
              name: 'Binary Trees',
              content: [
                {
                  id: '572ee1ba-f051-4034-95b5-9cc2d1b5ce76',
                  isFolder: false,
                  name: 'AllNodesDistanceKInBinaryTree.java',
                  code: 'import java.util.*;\npublic class AllNodesDistanceKInBinaryTree {\n    public static void markParents(TreeNode root, HashMap<Integer, TreeNode> hm) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node.left != null) {\n                q.add(node.left);\n                hm.put(node.left.val, node);\n            }\n            if (node.right != null) {\n                q.add(node.right);\n                hm.put(node.right.val, node);\n            }\n        }\n    }\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\n        HashMap<Integer, TreeNode> hm = new HashMap<>();\n        markParents(root, hm);\n        Queue<TreeNode> q = new LinkedList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        q.add(target);\n        hs.add(target.val);\n        int range = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            if (range == k) break;\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                TreeNode parent = hm.getOrDefault(node.val, null);\n                if (parent != null && !hs.contains(parent.val)) {\n                    q.add(parent);\n                    hs.add(parent.val);\n                }\n                if (node.left != null && !hs.contains(node.left.val)) {\n                    q.add(node.left);\n                    hs.add(node.left.val);\n                }\n                if (node.right != null && !hs.contains(node.right.val)) {\n                    q.add(node.right);\n                    hs.add(node.right.val);\n                }\n            }\n            range++;\n        }\n        List<Integer> ans = new ArrayList<>();\n        while (!q.isEmpty()) ans.add(q.poll().val);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'cac280e6-c109-4a8b-8b5b-4f31e58fbc38',
                  isFolder: false,
                  name: 'AllPathsToLeafNodeFromRoot.java',
                  code: 'import java.util.*;\npublic class AllPathsToLeafNodeFromRoot {\n    public static void solve(TreeNode root, String path, List<String> ans) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) ans.add(path + root.val);\n        solve(root.left, path + root.val +" ", ans);\n        solve(root.right, path + root.val + " ", ans);\n    }\n    public static List<String> allRootToLeaf(TreeNode root) {\n        // Write your code here.\n        List<String> ans = new ArrayList<>();\n        solve(root, "", ans);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/all-root-to-leaf-paths-in-binary-tree._983599',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '7588ac2c-1593-4bf0-bfe9-305c8516d637',
                  isFolder: false,
                  name: 'BinaryTreeFromInorderPostorder.java',
                  code: 'import java.util.Arrays;\n\npublic class BinaryTreeFromInorderPostorder {\n    public static TreeNode solve(int[] inorder, int[] postorder) {\n        if (inorder.length == 0 || postorder.length == 0) return null;\n        TreeNode root = new TreeNode(postorder[postorder.length - 1]);\n        int start = 0;\n        for (int j : inorder) {\n            if (j == postorder[postorder.length - 1]) break;\n            start++;\n        }\n        int[] left_inorder = Arrays.copyOfRange(inorder, 0, start);\n        int[] left_postorder = Arrays.copyOfRange(postorder, 0, start);\n        int[] right_inorder = Arrays.copyOfRange(inorder, start + 1, inorder.length);\n        int[] right_postorder = Arrays.copyOfRange(postorder, start, postorder.length - 1);\n        root.left = solve(left_inorder, left_postorder);\n        root.right = solve(right_inorder, right_postorder);\n        return root;\n    }\n\n    public static TreeNode buildTree(int[] inorder, int[] postorder) {\n        return solve(inorder, postorder);\n    }\n\n    public static void main(String[] args) {\n        int[] inorder = {9, 3, 15, 20, 7};\n        int[] postorder = {9, 15, 7, 20, 3};\n        TreeNode root = buildTree(inorder, postorder);\n        System.out.println(root.val);\n        System.out.println(root.left.val);\n        System.out.println(root.right.val);\n        System.out.println(root.right.left.val);\n        System.out.println(root.right.right.val);\n    }\n}',
                  link: 'https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '12d71a63-f07d-4b4f-af73-73a400a2abbd',
                  isFolder: false,
                  name: 'BinaryTreeFromInorderPreorder.java',
                  code: 'import java.util.Arrays;\n\npublic class BinaryTreeFromInorderPreorder {\n    public static TreeNode solve(int[] preorder, int[] inorder) {\n        if (preorder.length == 0 || inorder.length == 0) return null;\n        TreeNode root = new TreeNode(preorder[0]);\n        int start = 0;\n        for (int j : inorder) {\n            if (j == preorder[0]) break;\n            start++;\n        }\n        int[] left_inorder = Arrays.copyOfRange(inorder, 0, start);\n        int[] left_preorder = Arrays.copyOfRange(preorder, 1, start+1);\n        int[] right_inorder = Arrays.copyOfRange(inorder, start+1, inorder.length);\n        int[] right_preorder = Arrays.copyOfRange(preorder, start+1, preorder.length);\n        root.left = solve(left_preorder, left_inorder);\n        root.right = solve(right_preorder, right_inorder);\n        return root;\n    }\n\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\n        return solve(preorder, inorder);\n    }\n\n    public static void main(String[] args) {\n        int[] inorder = {9, 3, 15, 20, 7};\n        int[] preorder = {3, 9, 20, 15, 7};\n        TreeNode root = buildTree(preorder, inorder);\n        System.out.println(root.val);\n        System.out.println(root.left.val);\n        System.out.println(root.right.val);\n        System.out.println(root.right.left.val);\n        System.out.println(root.right.right.val);\n    }\n}',
                  link: 'https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '245eaafc-5eab-4537-a86b-f2ceaf4dc5b3',
                  isFolder: false,
                  name: 'CountTotalNodesInBinaryTree.java',
                  code: 'public class CountTotalNodesInBinaryTree {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        int l = countNodes(root.left);\n        int r = countNodes(root.right);\n        return l + r + 1;\n    }\n}',
                  link: 'https://leetcode.com/problems/count-complete-tree-nodes/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '8ad5993a-1c0f-4899-8ac3-89e331f48d41',
                  isFolder: false,
                  name: 'FlattenBinaryTreeToLinkedList.java',
                  code: 'public class FlattenBinaryTreeToLinkedList {\n    public void flatten(TreeNode root) {\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left != null) {\n                TreeNode temp = curr.left;\n                while (temp.right != null) {\n                    temp = temp.right;\n                }\n                temp.right = curr.right;\n                curr.right = curr.left;\n                curr.left = null;\n            }\n            curr = curr.right;\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/flatten-binary-tree-to-linked-list/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '794194ae-072a-4927-8b71-247bfe09e4af',
                  isFolder: false,
                  name: 'ImmediateChildrenSumProperty.java',
                  code: 'public class ImmediateChildrenSumProperty {\n    public static int solve(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return root.val;\n        int l = solve(root.left);\n        int r = solve(root.right);\n        if (l == - 1 || r == - 1 || root.val != (l + r)) return -1;\n        return root.val;\n    }\n    public static boolean isParentSum(TreeNode root) {\n        // Write your code here.\n        // int[] flag = {1};\n        int val = solve(root);\n        return val != -1;\n        // return flag[0] == 1;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/children-sum-property_8357239',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'bda47bf2-3e5d-4291-8544-e09d9032a7d3',
                  isFolder: false,
                  name: 'LowestCommonAncestor.java',
                  code: 'public class LowestCommonAncestor {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // return solve(root, p, q);\n        if (root == null || root == p || root == q) return root;\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\n        if (l != null && r != null) return root;\n        return l != null ? l : r;\n    }\n}',
                  link: 'https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '4edb8cfa-188f-4e99-86c0-646229d799cf',
                  isFolder: false,
                  name: 'MaximumWidthOfBinaryTree.java',
                  code: 'import java.util.*;\npublic class MaximumWidthOfBinaryTree {\n    static class Pair {\n        int idx;\n        TreeNode node;\n        Pair (TreeNode n, int i) {\n            this.idx = i;\n            this.node = n;\n        }\n    }\n    public int widthOfBinaryTree(TreeNode root) {\n        ArrayDeque<Pair> q = new ArrayDeque<>();\n        q.add(new Pair(root, 0));\n        int maxWidth = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            if (size > 1) {\n                Pair min = q.peekFirst();\n                Pair max = q.peekLast();\n                maxWidth = Math.max(max.idx - min.idx + 1, maxWidth);\n            }\n            for (int i = 0; i < size; i++) {\n                Pair p = q.pollFirst();\n                if (p.node.left != null) {\n                    q.add(new Pair(p.node.left, 2*p.idx + 1));\n                }\n                if (p.node.right != null) {\n                    q.add(new Pair(p.node.right, 2*p.idx + 2));\n                }\n            }\n        }\n        return maxWidth;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-width-of-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '1ea7c6da-b2af-454c-bc3f-497861205755',
                  isFolder: false,
                  name: 'MorrisTraversalInorder.java',
                  code: 'import java.util.*;\npublic class MorrisTraversalInorder {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left == null) {\n                ans.add(curr.val);\n                curr = curr.right;\n            } else {\n                TreeNode prev = curr.left;\n                while (prev.right != null && prev.right != curr) {\n                    prev = prev.right;\n                }\n                if (prev.right == null) {\n                    prev.right = curr;\n                    curr = curr.left;\n                } else {\n                    prev.right = null;\n                    ans.add(curr.val);\n                    curr = curr.right;\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-inorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '97771a87-ba6a-4eb6-8a0e-13a25a72c4f7',
                  isFolder: false,
                  name: 'MorrisTraversalPreorder.java',
                  code: 'import java.util.*;\npublic class MorrisTraversalPreorder {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left == null) {\n                ans.add(curr.val);\n                curr = curr.right;\n            } else {\n                TreeNode prev = curr.left;\n                while (prev.right != null && prev.right != curr) {\n                    prev = prev.right;\n                }\n                if (prev.right == null) {\n                    prev.right = curr;\n                    ans.add(curr.val);\n                    curr = curr.left;\n                } else {\n                    prev.right = null;\n                    curr = curr.right;\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-preorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '30154ddf-5de1-4e6e-9d29-835010a9d8a7',
                  isFolder: false,
                  name: 'SerializeAndDeserialize.java',
                  code: 'public class SerializeAndDeserialize {\n    public static void preorder(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append("N,");\n            return;\n        }\n        sb.append(root.val).append(",");\n        preorder(root.left, sb);\n        preorder(root.right, sb);\n    }\n\n    // Encodes a tree to a single string.\n    public static String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        preorder(root, sb);\n        sb.deleteCharAt(sb.length() - 1);\n        return sb.toString();\n    }\n\n    public static TreeNode solve(String[] arr, int[] idx) {\n        if (idx[0] == arr.length || arr[idx[0]].compareTo("N") == 0) {\n            idx[0]++;\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]]));\n        idx[0]++;\n        root.left = solve(arr, idx);\n        root.right = solve(arr, idx);\n        return root;\n    }\n    // Decodes your encoded data to tree.\n    public static TreeNode deserialize(String data) {\n        String[] arr = data.split(",");\n        return solve(arr, new int[] {0});\n    }\n}',
                  link: 'https://leetcode.com/problems/serialize-and-deserialize-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'c786aa46-b59b-418f-8a9b-8dceeed5ae26',
                  isFolder: false,
                  name: 'TimeToBurnBinaryTree.java',
                  code: 'import java.util.*;\npublic class TimeToBurnBinaryTree {\n    public static TreeNode getNode(TreeNode root, int val) {\n        if (root == null) return null;\n        if (root.val == val) return root;\n        TreeNode l = getNode(root.left, val);\n        TreeNode r = getNode(root.right, val);\n        return l == null ? r : l;\n    }\n    public static void markParents(TreeNode root, HashMap<Integer, TreeNode> hm) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node.left != null) {\n                q.add(node.left);\n                hm.put(node.left.val, node);\n            }\n            if (node.right != null) {\n                q.add(node.right);\n                hm.put(node.right.val, node);\n            }\n        }\n    }\n    public static int timeToBurnTree(TreeNode root, int start) {\n        TreeNode target = getNode(root, start);\n        HashMap<Integer, TreeNode> hm = new HashMap<>();\n        markParents(root, hm);\n        Queue<TreeNode> q = new LinkedList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        q.add(target);\n        hs.add(target.val);\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            boolean flag = false;\n            for(int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                TreeNode parent = hm.getOrDefault(node.val, null);\n                if (parent != null && !hs.contains(parent.val)) {\n                    hs.add(parent.val);\n                    q.add(parent);\n                    flag = true;\n                }\n                if (node.left != null && !hs.contains(node.left.val)) {\n                    hs.add(node.left.val);\n                    q.add(node.left);\n                    flag = true;\n                }\n                if (node.right != null && !hs.contains(node.right.val)) {\n                    hs.add(node.right.val);\n                    q.add(node.right);\n                    flag = true;\n                }\n            }\n            if (flag) count++;\n        }\n        return count;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/time-to-burn-tree_1469067',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'a1570c11-3f3c-4fb9-aa50-d8f974355269',
                  isFolder: false,
                  name: 'BalancedBinaryTree.java',
                  code: 'public class BalancedBinaryTree {\n    public int solve(TreeNode root) {\n        if (root == null) return 0;\n        int left = solve(root.left);\n        int right = solve(root.right);\n        if (left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;\n        return Math.max(left, right) + 1;\n    }\n    public boolean isBalanced(TreeNode root) {\n        return solve(root) != -1;\n    }\n}',
                  link: 'https://leetcode.com/problems/balanced-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '85ac0494-a705-4126-8704-faaa4961e6b1',
                  isFolder: false,
                  name: 'BinaryTreeMaximumPathSum.java',
                  code: 'class BinaryTreeMaximumPathSum {\n    public static int solve(TreeNode root, int[] maxSum) {\n        if (root == null) return 0;\n        int l = Math.max(0, solve(root.left, maxSum));\n        int r = Math.max(0, solve(root.right, maxSum));\n        maxSum[0] = Math.max(maxSum[0], l + r + root.val);\n        return Math.max(l, r) + root.val;\n    }\n    public int maxPathSum(TreeNode root) {\n        int[] maxSum = new int[1];\n        maxSum[0] = Integer.MIN_VALUE;\n        solve(root, maxSum);\n        return maxSum[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-maximum-path-sum/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '812e9da2-fcd8-43f2-8f48-1627be29fcdd',
                  isFolder: false,
                  name: 'BottomViewBinaryTree.java',
                  code: 'import java.util.*;\npublic class BottomViewBinaryTree {\n    static class Pair{\n        int idx;\n        TreeNode node;\n        Pair(int idx, TreeNode node) {\n            this.idx = idx;\n            this.node = node;\n        }\n    }\n    public static ArrayList<Integer> verticalTraversal(TreeNode root) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        Queue<Pair> q = new LinkedList<>();\n        int min = 0, max = 0;\n        q.add(new Pair(0, root));\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                TreeNode node = p.node;\n                hm.put(p.idx, node.val);\n                if (node.left != null) {\n                    min = Math.min(min, p.idx - 1);\n                    q.add(new Pair(p.idx - 1, node.left));\n                }\n                if (node.right != null) {\n                    max = Math.max(max, p.idx + 1);\n                    q.add(new Pair(p.idx + 1, node.right));\n                }\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) ans.add(hm.get(i));\n        return ans;\n    }\n    //Function to return a list containing the bottom view of the given tree.\n    public ArrayList <Integer> bottomView(TreeNode root)\n    {\n        // Code here\n        return verticalTraversal(root);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/bottom-view-of-binary-tree_893110',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'cd98d2bc-9904-464f-bc83-62195c094ce6',
                  isFolder: false,
                  name: 'BoundaryTraversalOfBinaryTree.java',
                  code: 'import java.util.*;\npublic class BoundaryTraversalOfBinaryTree {\n    public static boolean isLeaf(TreeNode root) {\n        return root != null && root.left == null && root.right == null;\n    }\n    public static void addLeafNodes(TreeNode root, List<Integer> ans) {\n        if (root == null) return;\n        if (isLeaf(root)) ans.add(root.val);\n        addLeafNodes(root.left, ans);\n        addLeafNodes(root.right, ans);\n    }\n    public static void addLeftNodes(TreeNode curr, List<Integer> ans) {\n        while (curr != null) {\n            if (!isLeaf(curr)) ans.add(curr.val);\n            curr = curr.left != null ? curr.left : curr.right;\n        }\n    }\n    public static void addRightNodes(TreeNode curr, List<Integer> ans) {\n        Stack<Integer> st = new Stack<>();\n        while (curr != null) {\n            if (!isLeaf(curr)) st.add(curr.val);\n            curr = curr.right != null ? curr.right : curr.left;\n        }\n        while (!st.isEmpty()) ans.add(st.pop());\n    }\n    public static List<Integer> traverseBoundary(TreeNode root){\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        ans.add(root.val);\n        addLeftNodes(root.left, ans);\n        addLeafNodes(root, ans);\n        addRightNodes(root.right, ans);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/boundary-traversal-of-binary-tree_790725',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'cfabc7a2-0c71-4750-a0e0-6e2ff9fc8025',
                  isFolder: false,
                  name: 'DiameterOfBinaryTree.java',
                  code: 'public class DiameterOfBinaryTree {\n    public static int solve(TreeNode root, int[] ans) {\n        // Write your code here.\n        if (root == null) return 0;\n        int l = solve(root.left, ans);\n        int r = solve(root.right, ans);\n        ans[0] = Math.max(ans[0], l+r);\n        return 1 + Math.max(l,r);\n    }\n    public int diameterOfBinaryTree(TreeNode root) {\n        int[] ans = new int[1];\n        solve(root, ans);\n        return ans[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/diameter-of-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'c6d385fb-b915-4b14-a1aa-6b7d561df4e5',
                  isFolder: false,
                  name: 'HeightOfABinaryTree.java',
                  code: 'public class HeightOfABinaryTree {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int depthL = maxDepth(root.left);\n        int depthR = maxDepth(root.right);\n        return Math.max(depthL, depthR) + 1;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-depth-of-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'a7d32409-04cb-455c-8d10-90406f56f124',
                  isFolder: false,
                  name: 'LeftRightViewBinaryTree.java',
                  code: 'import java.util.*;\npublic class LeftRightViewBinaryTree {\n    void solve(TreeNode root, List<Integer> ans, int lvl) {\n        if (root == null) return;\n        if (ans.size() <= lvl) ans.add(root.val);\n        solve(root.right, ans, lvl + 1);\n        solve(root.left, ans, lvl + 1);\n    }\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        solve(root, ans, 0);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-right-side-view/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'd72b59cd-e5a1-4a88-901c-3074937e0159',
                  isFolder: false,
                  name: 'SameTree.java',
                  code: 'class SameTree {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}',
                  link: 'https://leetcode.com/problems/same-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '6c49ca37-964b-48e2-8999-06e695c71b75',
                  isFolder: false,
                  name: 'SymmetricBinaryTree.java',
                  code: 'public class SymmetricBinaryTree {\n    public static boolean solve(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return solve(p.left, q.right) && solve(p.right, q.left);\n    }\n    public boolean isSymmetric(TreeNode root) {\n        return root == null || solve(root.left, root.right);\n    }\n}',
                  link: 'https://leetcode.com/problems/symmetric-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '1a835076-b5e0-463a-944f-7c5fca105070',
                  isFolder: false,
                  name: 'TopViewBinaryTree.java',
                  code: 'import java.util.*;\npublic class TopViewBinaryTree {\n    static class Pair{\n        int idx;\n        TreeNode node;\n        Pair(int idx, TreeNode node) {\n            this.idx = idx;\n            this.node = node;\n        }\n    }\n    public static ArrayList<Integer> verticalTraversal(TreeNode root) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        Queue<Pair> q = new LinkedList<>();\n        int min = 0, max = 0;\n        q.add(new Pair(0, root));\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                TreeNode node = p.node;\n                if (!hm.containsKey(p.idx))\n                    hm.put(p.idx, node.val);\n                if (node.left != null) {\n                    min = Math.min(min, p.idx - 1);\n                    q.add(new Pair(p.idx - 1, node.left));\n                }\n                if (node.right != null) {\n                    max = Math.max(max, p.idx + 1);\n                    q.add(new Pair(p.idx + 1, node.right));\n                }\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) ans.add(hm.get(i));\n        return ans;\n    }\n    static ArrayList<Integer> topView(TreeNode root) {\n        // add your code\n        return verticalTraversal(root);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/top-view-of-binary-tree_799401',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'bbdb2591-a35f-436a-bb1b-83120f53f5a8',
                  isFolder: false,
                  name: 'VerticalOrderTraversalBinaryTree.java',
                  code: 'import java.util.*;\n\npublic class VerticalOrderTraversalBinaryTree {\n    static class Pair{\n        int idx, row;\n        TreeNode node;\n        Pair(int idx, int row, TreeNode node) {\n            this.idx = idx;\n            this.row = row;\n            this.node = node;\n        }\n    }\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\n        PriorityQueue<Pair> q = new PriorityQueue<>((a,b) -> a.row == b.row ? a.node.val - b.node.val : a.row - b.row);\n        int min = 0, max = 0;\n        q.add(new Pair(0, 0, root));\n        int row = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                TreeNode node = p.node;\n                if (!hm.containsKey(p.idx))\n                    hm.put(p.idx, new ArrayList<>());\n                hm.get(p.idx).add(node.val);\n                if (node.left != null) {\n                    min = Math.min(min, p.idx - 1);\n                    q.add(new Pair(p.idx - 1, row, node.left));\n                }\n                if (node.right != null) {\n                    max = Math.max(max, p.idx + 1);\n                    q.add(new Pair(p.idx + 1, row, node.right));\n                }\n            }\n            row++;\n        }\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) ans.add(hm.get(i));\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'c477718d-dbfc-4a2b-94f4-9b2c245b70ab',
                  isFolder: false,
                  name: 'ZigZagLevelOrderTraversal.java',
                  code: 'import java.util.*;\nclass ZigZagLevelOrderTraversal {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) return ans;\n        boolean flip = true;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            List<Integer> temp = new ArrayList<>();\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                if (node != null) {\n                    if (flip) temp.add(node.val);\n                    else temp.add(0, node.val);\n\n                    if (node.left != null) q.add(node.left);\n                    if (node.right != null) q.add(node.right);\n                }\n            }\n            flip ^= true;\n            ans.add(temp);\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '27bc7723-09eb-44d4-8297-af4ef395c9ef',
                  isFolder: false,
                  name: 'BinarySearchTree.java',
                  code: 'import java.util.*;\n\npublic class BinarySearchTree {\n    public static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) {\n            this.val = val;\n            this.left = this.right = null;\n        }\n    }\n    public static class Pair {\n        TreeNode node;\n        int s;\n        Pair (TreeNode n, int s) {\n            this.node = n;\n            this.s = s;\n        }\n    }\n    TreeNode treeRoot;\n\n    TreeNode buildTree () {\n        return treeRoot;\n    }\n\n    //    TREE TRAVERSALS\n    //    DFS\n    public void printTree(String type) {\n        System.out.print(type + " traversal of Tree: [ ");\n        switch (type) {\n            case "Inorder" -> printTreeInOrder(treeRoot);\n            case "Preorder" -> printTreePreOrder(treeRoot);\n            case "Postorder" -> printTreePostOrder(treeRoot);\n        }\n        System.out.print("]\\n");\n    }\n\n    private void printTreeInOrder(TreeNode root) {\n//        Recursive\n//        if (root == null) return;\n//        printTreeInOrder(root.left);\n//        System.out.print(root.val + " ");\n//        printTreeInOrder(root.right);\n\n//        Iterative\n        Stack<TreeNode> st = new Stack<>();\n        TreeNode node = root;\n        while (node != null || !st.isEmpty()) {\n            while (node != null) {\n                st.push(node);\n                node = node.left;\n            }\n            node = st.pop();\n            System.out.print(root.val + " ");\n            node = node.right;\n        }\n    }\n\n    private void printTreePreOrder(TreeNode root) {\n//        Recursive\n//        if (root == null) return;\n//        System.out.print(root.val + " ");\n//        printTreePreOrder(root.left);\n//        printTreePreOrder(root.right);\n\n//        Iterative\n        Stack<TreeNode> st = new Stack<>();\n        TreeNode node = root;\n        while (node != null || !st.isEmpty()) {\n            while (node != null) {\n                System.out.print(root.val + " ");\n                st.push(node);\n                node = node.left;\n            }\n            node = st.pop().right;\n        }\n    }\n\n    private void printTreePostOrder(TreeNode root) {\n//        Recursive\n//        if (root == null) return;\n//        printTreePostOrder(root.left);\n//        printTreePostOrder(root.right);\n//        System.out.print(root.val + " ");\n\n//        Iterative (2 stack)\n//        if (root == null) return;\n//        Stack<TreeNode> st = new Stack<>();\n//        Stack<Integer> st2 = new Stack<>();\n//        st.push(root);\n//        while (!st.isEmpty()) {\n//            TreeNode temp = st.pop();\n//            st2.push(temp.val);\n//            if (temp.left != null) st.push(temp.left);\n//            if (temp.right != null) st.push(temp.right);\n//        }\n//        while (!st2.isEmpty()) {\n//            System.out.print(st2.pop() + " ");\n//        }\n\n//        Iterative (1 Stack)\n        TreeNode curr = root;\n        Stack<TreeNode> st = new Stack<>();\n        while (curr != null || !st.isEmpty()) {\n            if (curr != null) {\n                st.push(curr);\n                curr = curr.left;\n            } else {\n                TreeNode temp = st.peek().right;\n                if (temp == null) {\n                    temp = st.pop();\n                    System.out.print(temp.val + " ");\n                    while (!st.isEmpty() && temp == st.peek().right) {\n                        temp = st.pop();\n                        System.out.print(temp.val + " ");\n                    }\n                } else {\n                    curr = temp;\n                }\n            }\n        }\n    }\n\n    //    Level order traversal / BFS\n    public void levelOrderTraversal() {\n        Queue<TreeNode> q = new LinkedList<>();\n        if (treeRoot != null) q.add(treeRoot);\n        int level = 0;\n        while (!q.isEmpty()) {\n            System.out.print("level " + level + ": ");\n            int lvlLength = q.size();\n            for (int i = 0; i < lvlLength; i++) {\n                TreeNode temp = q.poll();\n                if (temp != null) {\n                    System.out.print(temp.val + " ");\n                    if (temp.left != null) q.add(temp.left);\n                    if (temp.right != null) q.add(temp.right);\n                }\n            }\n            level++;\n            System.out.println();\n        }\n    }\n\n    public void reverseLevelOrderTraversal() {\n        Queue<TreeNode> q = new LinkedList<>();\n        Stack<Integer> st = new Stack<>();\n        if (treeRoot != null) q.add(treeRoot);\n        int level = 0;\n        while (!q.isEmpty()) {\n            int lvlLength = q.size();\n            for (int i = 0; i < lvlLength; i++) {\n                TreeNode temp = q.poll();\n                if (temp != null) {\n                    st.add(temp.val);\n                    if (temp.right != null) q.add(temp.right);\n                    if (temp.left != null) q.add(temp.left);\n                }\n            }\n            st.push(null);\n            level++;\n        }\n        while (!st.isEmpty()) {\n            if (st.peek() == null) {\n                System.out.print("\\nlevel " + --level + ": ");\n                st.pop();\n            }\n            System.out.print(st.pop() + " ");\n        }\n    }\n\n\n    //    Insert\n    public void insert(int val) {\n        treeRoot = insert(treeRoot, val);\n    }\n\n    private TreeNode insert(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n        if (val >= root.val) {\n            root.right = insert(root.right, val);\n        } else {\n            root.left = insert(root.left, val);\n        }\n        return root;\n    }\n\n    //    Remove\n    public void remove(int val) {\n        treeRoot = remove(treeRoot, val);\n    }\n\n    public int findMinNodeValue() {\n        TreeNode node = findMinNode(treeRoot);\n        return node.val;\n    }\n\n    private TreeNode findMinNode(TreeNode root) {\n        TreeNode temp = root;\n        while (temp != null && temp.left != null) {\n            temp = temp.left;\n        }\n        return temp;\n    }\n\n    private TreeNode remove(TreeNode root, int val) {\n        if (root == null) return null;\n        if (val > root.val) {\n            root.right = remove(root.right, val);\n        } else if (val < root.val) {\n            root.left = remove(root.left, val);\n        } else {\n            if (root.left == null) return root.right;\n            if (root.right == null) return root.left;\n            TreeNode minNode = findMinNode(root.right);\n            root.val = minNode.val;\n            root.right = remove(root.right, minNode.val);\n        }\n        return root;\n    }\n\n    private void preInPostSingleTraversal(TreeNode root) {\n        Stack<Pair> st = new Stack<>();\n        List<Integer> inorder = new ArrayList<>();\n        List<Integer> preorder = new ArrayList<>();\n        List<Integer> postorder = new ArrayList<>();\n        st.push(new Pair(root, 1));\n        while (!st.isEmpty()) {\n            Pair temp = st.pop();\n            if (temp.s == 1) {\n                preorder.add(temp.node.val);\n                st.push(new Pair(temp.node, temp.s+1));\n                if (temp.node.left != null) {\n                    st.push(new Pair(temp.node.left, 1));\n                }\n            } else if (temp.s == 2) {\n                inorder.add(temp.node.val);\n                st.push(new Pair(temp.node, temp.s+1));\n                if (temp.node.right != null) {\n                    st.push(new Pair(temp.node.right, 1));\n                }\n            } else {\n                postorder.add(temp.node.val);\n            }\n        }\n        System.out.println("Pre: " + preorder);\n        System.out.println("In: " + inorder);\n        System.out.println("Post: " + postorder);\n\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n        int[] input = {7, 3, 5, 11, 17, 1, 8};\n        for (int j : input) tree.insert(j);\n//        tree.printTree("Inorder");\n//        tree.printTree("Preorder");\n//        tree.printTree("Postorder");\n//        tree.remove(7);\n//        tree.printTree("Inorder");\n//        HW\n        tree.levelOrderTraversal();\n//        tree.reverseLevelOrderTraversal();\n//        inorder, preorder, postorder traversal using iteration\n//        tree.preInPostSingleTraversal(tree.treeRoot);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Traversals'],
                },
              ],
            },
            {
              id: '8408e110-dc4f-4d55-887d-d342afdd9c18',
              isFolder: false,
              name: 'AdvancedMaths.java',
              code: 'import java.util.*;\n\npublic class AdvancedMaths {\n    public static List< Integer > countPrimes(int n) {\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        boolean[] check = new boolean[n+1];\n        check[0] = true;\n        check[1] = true;\n        for (int i = 2; i <= n; i++) {\n            if (!check[i]) {\n                if (n%i == 0) {\n                    ans.add(i);\n                }\n                for (int j = i*2; j <= n; j += i) {\n                    check[j] = true;\n                }\n            }\n        }\n        return ans;\n    }\n\n//    https://www.codingninjas.com/studio/problems/power-of-numbers_8157729\n    public static long fastExponentiation(int n, int p) {\n        if (p == 0) return 1;\n        else if (p == 1) return n;\n        else {\n            long R = fastExponentiation(n, p/2)%(long)(10e9+7);\n            if (p%2 == 0) return (R*R)%1000000007;\n            else return (((R*n)%1000000007)*R)%1000000007;\n        }\n    }\n    public static int power(int N, int R){\n        // Write your code here.\n        int ans = (int) fastExponentiation(N, R);\n        return ans;\n    }\n\n//    https://www.codingninjas.com/studio/problems/subsequences-of-string_985087\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences("hq");\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '916f5a21-4df3-4e0a-aa77-36d19b474789',
              isFolder: false,
              name: 'InterviewProblems.java',
              code: 'public class InterviewProblems {\n    public static int getCount(int n) {\n        return LearnBitManipulationQuestions.getCount(n);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/flip-bits_8160405\n    public static int flipBits(int A, int B) {\n        // Write your code here.\n        int Xor = A ^ B;\n        return getCount(Xor);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/one-odd-occurring_4606074\n    public static int missingNumber(int n, int[] arr) {\n        // Write your code here.\n        int ans = 0;\n        for (int num : arr) {\n            ans ^= num;\n        }\n        return ans;\n    }\n\n    //    https://www.codingninjas.com/studio/problems/l-to-r-xor_8160412\n    public static int getXOR(int n) {\n        if (n % 4 == 0) return n;\n        if (n % 4 == 1) return 1;\n        if (n % 4 == 2) return n + 1;\n        return 0;\n    }\n\n    public static int findXOR(int L, int R) {\n        // Write your code here.\n        int lXor = getXOR(L - 1);\n        int rXor = getXOR(R);\n        return lXor ^ rXor;\n    }\n\n    public static int[] twoOddNum(int []arr){\n        int xor = 0;\n        for (int j : arr) {\n            xor ^= j;\n        }\n        int pos = 0;\n        while ((xor & 1) == 0) {\n            pos++;\n            xor >>= 1;\n        }\n        int xor1 = 0, xor2 = 0;\n        for (int num : arr) {\n            if (((num >> pos) & 1) == 1) xor1 ^= num;\n            else xor2 ^= num;\n        }\n        return new int[]{Math.max(xor1, xor2), Math.min(xor1, xor2)};\n    }\n\n    public static void main(String[] args) {\n\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '21a76316-a256-4eb5-ac6d-a328dddc9b4c',
              isFolder: false,
              name: 'LearnBitManipulationQuestions.java',
              code: 'public class LearnBitManipulationQuestions {\n    public static int[] bitManipulation(int num, int i) {\n        int[] ans = new int[3];\n        int mask = 1 << (i - 1);\n        // 1. get ith bit\n        ans[0] = (num & mask) != 0 ? 1 : 0;\n        // 2. set ith bit\n        num = num | mask;\n        ans[1] = num;\n        // 3. clear ith bit\n        ans[2] = num & ~mask;\n        return ans;\n    }\n\n    public static boolean isKthBitSet(int n, int k) {\n        int mask = 1 << (k - 1);\n        return (n & mask) != 0;\n    }\n\n    public static String oddEven(int N) {\n        // Write your code here.\n        return (N & 1) == 0 ? "even" : "odd";\n    }\n\n    public static boolean isPowerOfTwo(int n) {\n        // Write your code here.\n        return (n & (n - 1)) == 0;\n    }\n\n    //    Count set bits in range 1 - N\n    public static int getCount(int n) {\n        int count = 0;\n        while (n != 0) {\n            n = (n & (n - 1));\n            count++;\n        }\n        return count;\n    }\n\n    public static int countSetBits(int n) {\n        //Write your code here\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            count += getCount(i);\n        }\n        return count;\n    }\n\n    //    https://www.codingninjas.com/studio/problems/set-the-rightmost-unset-bit_8160456\n    public static int setBits(int N) {\n        // Write your code here\n        int n = N;\n        if ((n & (n + 1)) == 0) return N;\n        int idx = 0;\n        while (n > 0) {\n            if ((n & 1) == 0) break;\n            idx++;\n            n >>= 1;\n        }\n        return N | (1 << idx);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/swap-two-numbers_1380853\n    public static void swapNumber(int[] a, int[] b) {\n        // Write your code here.\n        a[0] = a[0] ^ b[0];\n        b[0] = a[0] ^ b[0];\n        a[0] = a[0] ^ b[0];\n    }\n\n//    https://www.codingninjas.com/studio/problems/flip-bits_8160405\n    public static int flipBits(int A, int B){\n        // Write your code here.\n        int Xor = A^B;\n        return getCount(Xor);\n    }\n\n//    https://www.codingninjas.com/studio/problems/one-odd-occurring_4606074\n    public static int missingNumber(int n, int []arr){\n        // Write your code here.\n        int ans = 0;\n        for (int num : arr) {\n            ans ^= num;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n//        int n = 11;\n//        int i = 2;\n//        int[] ans = bitManipulation(n, i);\n//        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '3e9df283-0e39-4c92-9736-0eb3fdd8d1c3',
              isFolder: false,
              name: 'SieveOfEratosthenes.java',
              code: 'import java.util.*;\npublic class SieveOfEratosthenes {\n    static List<Integer> getPrime(int n) {\n        List<Integer> ans = new ArrayList<>();\n        boolean[] check = new boolean[n+1];\n        check[0] = true;\n        check[1] = true;\n        for (int i = 2; i <= n; i++) {\n            if (!check[i]) {\n                ans.add(i);\n                for (int j = i*2; j <= n; j += i)\n                    check[j] = true;\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int n = 10;\n        System.out.println(getPrime(n));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '5bdf0d23-68b6-4fdf-abe0-22aa73edede1',
              isFolder: true,
              name: 'Dynamic Programming',
              content: [
                {
                  id: '98598ecf-90a8-4243-a504-7c31872ddf1d',
                  isFolder: false,
                  name: 'ClimbingStairs.java',
                  code: 'import java.util.*;\n\npublic class ClimbingStairs {\n    public int solve(int n, int[] arr) {\n        if (n == 0 || n == 1) return 1;\n        if (arr[n] != 0) return arr[n];\n        arr[n] = solve(n - 1, arr) + solve(n - 2, arr);\n        return arr[n];\n    }\n\n    public int climbStairs(int n) {\n        // Memoization\n        int[] dp = new int[n + 1];\n        return solve(n, dp);\n\n        // Top down\n        // int[] dp = new int[n+1];\n        // dp[0] = dp[1] = 1;\n        // for (int i = 2; i <= n; i++) {\n        //     dp[i] = dp[i-1] + dp[i-2];\n        // }\n        // return dp[n];\n\n        // Space optimized\n        // int prev1 = 1, prev2 = 1;\n        // for (int i = 2; i <= n; i++) {\n        //     int temp = prev1 + prev2;\n        //     prev2 = prev1;\n        //     prev1 = temp;\n        // }\n        // return prev1;\n    }\n}',
                  link: 'https://leetcode.com/problems/climbing-stairs/',
                  notes: '',
                  tags: ['1D DP'],
                },
                {
                  id: '2a35a714-cd83-4a13-8ac4-9d6530eecdd4',
                  isFolder: false,
                  name: 'FrogJump.java',
                  code: 'import java.util.*;\n\npublic class FrogJump {\n    public static int solve(int[] H, int step, int[] dp, int n) {\n        if (step == n - 1) return 0;\n        if (dp[step] != -1) return dp[step];\n        int a = Integer.MAX_VALUE;\n        if (step + 1 < n) {\n            a = Math.abs(H[step + 1] - H[step]) + solve(H, step + 1, dp, n);\n        }\n        int b = Integer.MAX_VALUE;\n        if (step + 2 < n) {\n            b = Math.abs(H[step + 2] - H[step]) + solve(H, step + 2, dp, n);\n        }\n        return dp[step] = Math.min(a, b);\n    }\n\n    public static int frogJump(int n, int H[]) {\n        // Write your code here..\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        return solve(H, 0, dp, n);\n//        dp[n] = 0;\n//        dp[n - 1] = Math.abs(H[n - 2] - H[n - 1]);\n//        for (int i = n - 2; i > 0; i--) {\n//            int a = Math.abs(H[i - 1] - H[i]) + dp[i + 1];\n//            int b = Math.abs(H[i - 1] - H[i + 1]) + dp[i + 2];\n//            dp[i] = Math.min(a, b);\n//        }\n//        return dp[1];\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/frog-jump_3621012',
                  notes: '',
                  tags: ['1D DP'],
                },
                {
                  id: '81ec657e-5990-4df5-8229-12b734809924',
                  isFolder: false,
                  name: 'FrogJumpKDistances.java',
                  code: 'import java.util.*;\n\npublic class FrogJumpKDistances {\n    public static int solve(int[] H, int k, int step, int[] dp) {\n        if (step == 0) return 0;\n        if (dp[step] != -1) return dp[step];\n        int result = Integer.MAX_VALUE;\n        for (int j = 1; j <= k; j++) {\n            if (step - j >= 0) {\n                int val = solve(H, k, step - j, dp) + Math.abs(H[step] - H[step - j]);\n                result = Math.min(result, val);\n            }\n        }\n        dp[step] = result;\n        return result;\n    }\n\n    public static int minimizeCost(int n, int k, int[] H) {\n        // Write your code here.\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1);\n        return solve(H, k, n - 1, dp);\n        // dp[0] = 0;\n        // for (int i = 1; i < n; i++) {\n        //     int result = Integer.MAX_VALUE;\n        //     for (int j = 1; j <= k; j++) {\n        //         if (i - j >= 0) {\n        //             int val = dp[i-j] + Math.abs(H[i] - H[i-j]);\n        //             result = Math.min(result, val);\n        //         }\n        //     }\n        //     dp[i] = result;\n        // }\n        // return dp[n-1];\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimal-cost_8180930',
                  notes: '',
                  tags: ['1D DP'],
                },
                {
                  id: '192ac07a-2884-406a-bafa-67f62906a74b',
                  isFolder: false,
                  name: 'HouseRobber.java',
                  code: 'import java.util.*;\n\npublic class HouseRobber {\n    public int solve(int[] nums, int idx, int[] dp) {\n        if (idx >= nums.length) return 0;\n        if (idx == nums.length - 1) return nums[idx];\n        if (dp[idx] != -1) return dp[idx];\n        int pick = nums[idx] + solve(nums, idx + 2, dp);\n        int notPick = solve(nums, idx + 1, dp);\n        return dp[idx] = Math.max(pick, notPick);\n    }\n\n    public int rob(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        // Arrays.fill(dp, -1);\n        // return solve(nums, 0, dp);\n\n//        Tabulation\n        dp[n - 1] = nums[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            int pick = nums[i];\n            if (i < n - 2) {\n                pick += dp[i + 2];\n            }\n            int notPick = dp[i + 1];\n            dp[i] = Math.max(pick, notPick);\n        }\n        return dp[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/house-robber/',
                  notes: '',
                  tags: ['1D DP'],
                },
                {
                  id: '9063d4a3-a131-4d22-8339-0d196dc314a5',
                  isFolder: false,
                  name: 'HouseRobber2.java',
                  code: 'import java.util.*;\n\npublic class HouseRobber2 {\n    public int solve(int[] nums, int idx, int[] dp) {\n        if (idx >= nums.length) return 0;\n        if (dp[idx] != -1) return dp[idx];\n        int pick = nums[idx] + solve(nums, idx + 2, dp);\n        int notPick = solve(nums, idx + 1, dp);\n        return dp[idx] = Math.max(pick, notPick);\n    }\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) return nums[0];\n        int[] dp = new int[n];\n        Arrays.fill(dp, -1);\n        int save = nums[n-1];\n        nums[n-1] = -10000;\n        int max1 = solve(nums, 0, dp);\n        Arrays.fill(dp, -1);\n        nums[n-1] = save;\n        nums[0] = -10000;\n        int max2 = solve(nums, 0, dp);\n        return Math.max(max1, max2);\n    }\n}',
                  link: 'https://leetcode.com/problems/house-robber-ii/',
                  notes: '',
                  tags: ['1D DP'],
                },
                {
                  id: '12a0054e-c6e1-4100-84e7-e259a9efaecd',
                  isFolder: false,
                  name: 'MinimumFallingPathSum.java',
                  code: 'import java.util.*;\n\npublic class MinimumFallingPathSum {\n    public int solve(int[][] matrix, int i, int j, int n, int[][] dp) {\n        if (i >= n) return 0;\n        if (j < 0 || j >= n) return (int)1e8;\n        if (dp[i][j] != (int)1e8) return dp[i][j];\n        int l = solve(matrix, i+1, j-1, n, dp);\n        int m = solve(matrix, i+1, j, n, dp);\n        int r = solve(matrix, i+1, j+1, n, dp);\n        return dp[i][j] = matrix[i][j] + Math.min(Math.min(l, m), r);\n    }\n    public int minFallingPathSum(int[][] matrix) {\n        int minSum = (int)1e8;\n        int n = matrix.length;\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], (int)1e8);\n        }\n        for (int i = 0; i < n; i++) {\n            minSum = Math.min(minSum, solve(matrix, 0, i, n, dp));\n        }\n        return minSum;\n    }\n}',
                  link: 'https://leetcode.com/problems/minimum-falling-path-sum/',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: '6ae70c03-c5c1-4e15-9575-b6f60bb22579',
                  isFolder: false,
                  name: 'MinimumPathSum.java',
                  code: 'import java.util.*;\n\npublic class MinimumPathSum {\n    public int paths(int[][] grid, int i, int j, int n, int m, int[][] dp) {\n        if (i > n || j > m) return (int)1e8;\n        if (i == n && j == m) return grid[i][j];\n        if (dp[i][j] != -1) return dp[i][j];\n        int down = paths(grid, i+1, j, n, m, dp);\n        int right = paths(grid, i, j+1, n, m, dp);\n        return dp[i][j] = grid[i][j] + Math.min(down, right);\n    }\n    public int minPathSum(int[][] grid) {\n        int n = grid.length, m = grid[0].length;\n        int[][] dp = new int[n][m];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return paths(grid, 0, 0, n-1, m-1, dp);\n        dp[n-1][m-1] = grid[n-1][m-1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = grid[i][j];\n                } else {\n                    int down = i > 0 ? dp[i-1][j] : (int)1e8;\n                    int right = j > 0 ? dp[i][j-1] : (int)1e8;\n                    dp[i][j] = grid[i][j] + Math.min(down, right);\n                }\n            }\n        }\n        return dp[n-1][m-1];\n    }\n}',
                  link: 'https://leetcode.com/problems/minimum-path-sum/',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: 'b21bb720-3ac0-4f70-ad7e-628dcd5471e0',
                  isFolder: false,
                  name: 'NinjaAndHisFriends3D_DP.java',
                  code: 'import java.util.*;\n\npublic class NinjaAndHisFriends3D_DP {\n    static int[] dirs = {1, 0, -1};\n\n    public static int solve(int[][] grid, int i, int j1, int j2, int r, int c, int[][][] dp) {\n        if (j1 < 0 || j1 >= c || j2 < 0 || j2 >= c) return (int) -1e8;\n        if (i == r - 1) return j1 == j2 ? grid[i][j1] : grid[i][j1] + grid[i][j2];\n        if (dp[i][j1][j2] != -1) return dp[i][j1][j2];\n        int sum = 0;\n        for (int x : dirs) {\n            for (int y : dirs) {\n                sum = Math.max(sum, solve(grid, i + 1, j1 + x, j2 + y, r, c, dp));\n            }\n        }\n        return dp[i][j1][j2] = grid[i][j1] + sum + (j1 == j2 ? 0 : grid[i][j2]);\n    }\n\n    public static int maximumChocolates(int r, int c, int[][] grid) {\n        // Write your code here.\n        int[][][] dp = new int[r][c][c];\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        return solve(grid, 0, 0, c - 1, r, c, dp);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/chocolate-pickup_3125885',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: '854890fe-32d2-428c-ab20-2add73c09c38',
                  isFolder: false,
                  name: 'NinjasTraining.java',
                  code: 'import java.util.*;\n\npublic class NinjasTraining {\n    public static int solve(int[][] points, int n, int last, int[][] dp) {\n        if (n < 0) return 0;\n        if (dp[n][last] != -1) return dp[n][last];\n        int max = 0;\n        for (int i = 0; i < 3; i++) {\n            if (i != last) {\n                int a = points[n][i] + solve(points, n - 1, i, dp);\n                max = Math.max(max, a);\n            }\n        }\n        return dp[n][last] = max;\n    }\n\n    public static int ninjaTraining(int n, int[][] points) {\n        // Write your code here..\n        int[][] dp = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        int maxMerit = 0;\n        for (int i = 0; i < 3; i++) {\n            maxMerit = Math.max(maxMerit, solve(points, n - 1, i, dp));\n        }\n        return maxMerit;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/ninja%E2%80%99s-training_3621003',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: '78dc3db2-92c8-4c84-9819-222733291b57',
                  isFolder: false,
                  name: 'Triangle.java',
                  code: 'import java.util.*;\n\npublic class Triangle {\n    public int solve(List<List<Integer>> triangle, int i, int j, int[][] dp) {\n        if (i == triangle.size() - 1) return triangle.get(i).get(j);\n        if (dp[i][j] != -1) return dp[i][j];\n        int same = solve(triangle, i+1, j, dp);\n        int next = solve(triangle, i+1, j+1, dp);\n        return dp[i][j]= triangle.get(i).get(j) + Math.min(same, next);\n    }\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int size = triangle.size();\n        int[][] dp = new int[size][size+1];\n        for (int i = 0; i < size; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(triangle, 0, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/triangle/',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: 'b2dfc4d2-8fef-4bac-bba4-86913ed2cfe4',
                  isFolder: false,
                  name: 'UniquePaths.java',
                  code: 'import java.util.*;\n\npublic class UniquePaths {\n    public int paths(int m, int n, int[][] dp) {\n        if (m < 0 || n < 0) return 0;\n        if (m == 0 && n == 0) return 1;\n        if (dp[m][n] != -1) return dp[m][n];\n        return dp[m][n] = paths(m-1, n, dp) + paths(m, n-1, dp);\n    }\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        // for (int i = 0; i < m; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return paths(m-1,n-1,dp);\n        dp[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    int a = i > 0 ? dp[i-1][j] : 0;\n                    int b = j > 0 ? dp[i][j-1] : 0;\n                    dp[i][j] = a + b;\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}',
                  link: 'https://leetcode.com/problems/unique-paths/',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: '0d07d2f4-7526-4ba8-8bf4-235bc3232f70',
                  isFolder: false,
                  name: 'UniquePaths2.java',
                  code: 'import java.util.*;\n\npublic class UniquePaths2 {\n    public int paths(int m, int n, int[][] grid, int[][] dp) {\n        if (m < 0 || n < 0 || grid[m][n] == 1) return 0;\n        if (m == 0 && n == 0) return 1;\n        if (dp[m][n] != -1) return dp[m][n];\n        return dp[m][n] = paths(m-1, n, grid, dp) + paths(m, n-1, grid, dp);\n    }\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        // return paths(m-1, n-1, obstacleGrid, dp);\n        dp[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else if (i == 0 && j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    int a = i > 0 ? dp[i-1][j] : 0;\n                    int b = j > 0 ? dp[i][j-1] : 0;\n                    dp[i][j] = a + b;\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n}',
                  link: 'https://leetcode.com/problems/unique-paths-ii/',
                  notes: '',
                  tags: ['2D-3D DP and DP on Grids'],
                },
                {
                  id: '96cdfca0-1201-494b-b7ec-bb8bdac11a97',
                  isFolder: false,
                  name: 'LargestDivisibleSubset.java',
                  code: 'import java.util.*;\n\npublic class LargestDivisibleSubset {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        int x = nums.length;\n        Arrays.sort(nums);\n        int[] dp = new int[x], hash = new int[x];\n        Arrays.fill(dp, 1);\n        int maxIdx = 0;\n        for (int i = 0; i < x; i++) {\n            hash[i] = i;\n            for (int prev = 0; prev < i; prev++) {\n                if (nums[i] % nums[prev] == 0 && dp[prev] + 1 > dp[i]) {\n                    dp[i] = dp[prev] + 1;\n                    hash[i] = prev;\n                }\n            }\n            if (dp[i] > dp[maxIdx]) {\n                maxIdx = i;\n            }\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        while (hash[maxIdx] != maxIdx) {\n            ans.add(nums[maxIdx]);\n            maxIdx = hash[maxIdx];\n        }\n        ans.add(nums[maxIdx]);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/largest-divisible-subset/',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: '6f847efa-757f-4fbc-8fd8-063f132fe62d',
                  isFolder: false,
                  name: 'LongestBitonicSubsequence.java',
                  code: 'import java.util.*;\n\npublic class LongestBitonicSubsequence {\n    public static int[] lis(int[] arr, int n) {\n        int[] dp = new int[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int prev = 0; prev < i; prev++) {\n                if (arr[prev] < arr[i]) {\n                    dp[i] = Math.max(dp[i], dp[prev] + 1);\n                }\n            }\n        }\n        return dp;\n    }\n\n    public static int longestBitonicSequence(int[] arr, int n) {\n        int[] increasing = lis(arr, n);\n        int[] reversedArr = new int[n];\n        for (int i = 0; i < n; i++) {\n            reversedArr[i] = arr[n - i - 1];\n        }\n        int[] decreasing = lis(reversedArr, n);\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            max = Math.max(increasing[i] + decreasing[n - i - 1] - 1, max);\n        }\n        return max;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/longest-bitonic-sequence_1062688',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: 'afea9c00-b5d6-42b3-8837-c28f4f483161',
                  isFolder: false,
                  name: 'LongestIncreasingSubsequence.java',
                  code: 'import java.util.*;\n\npublic class LongestIncreasingSubsequence {\n    public int solve(int[] nums, int idx, int lastIdx, int[][] dp) {\n        if (idx == nums.length) return 0;\n        if (dp[idx][lastIdx + 1] != -1) return dp[idx][lastIdx + 1];\n        int notPick = solve(nums, idx + 1, lastIdx, dp), pick = 0;\n        if (lastIdx == -1 || nums[idx] > nums[lastIdx]) {\n            pick = 1 + solve(nums, idx + 1, idx, dp);\n        }\n        return dp[idx][lastIdx + 1] = Math.max(pick, notPick);\n    }\n\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n + 1][n + 1];\n\n        // Memoization\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(nums, 0, -1, dp);\n\n        // Tabulation - O(N^2) time and O(N^2) space\n        // for (int idx = n-1; idx >= 0; idx--) {\n        //     for (int lastIdx = idx-1; lastIdx >= -1; lastIdx--) {\n        //         int notPick = dp[idx+1][lastIdx+1], pick = 0;\n        //         if (lastIdx == -1 || nums[idx] > nums[lastIdx]) {\n        //             pick = 1 + dp[idx+1][idx+1];\n        //         }\n        //         dp[idx][lastIdx+1] = Math.max(pick, notPick);\n        //     }\n        // }\n        // return dp[0][0];\n\n        // Different approach - O(N^2) time and O(N) space\n        // int[] dp = new int[n];\n        // Arrays.fill(dp, 1);\n        // int max = 1;\n        // for (int i = 0; i < n; i++) {\n        //     for (int prev = 0; prev < i; prev++) {\n        //         if (nums[prev] < nums[i]) {\n        //             dp[i] = Math.max(dp[prev]+1, dp[i]);\n        //         }\n        //     }\n        //     max = Math.max(max, dp[i]);\n        // }\n        // return max;\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-increasing-subsequence/',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: '157c116b-5cc9-43cf-a804-7015d847cffa',
                  isFolder: false,
                  name: 'LongestIncreasingSubsequenceBS.java',
                  code: 'import java.util.*;\n\npublic class LongestIncreasingSubsequenceBS {\n    public static int bs(List<Integer> arr, int target) {\n        int start = 0, end = arr.size() - 1;\n        int ans = 0;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (target <= arr.get(mid)) {\n                ans = mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        List<Integer> arr = new ArrayList<>();\n        arr.add(nums[0]);\n        for (int i = 1; i < n; i++) {\n            if (arr.get(arr.size() - 1) < nums[i]) {\n                arr.add(nums[i]);\n            } else {\n                int idx = bs(arr, nums[i]);\n                arr.set(idx, nums[i]);\n            }\n        }\n        return arr.size();\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-increasing-subsequence/',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: 'aee9c00a-3c25-48af-8238-1d0c6d4e9829',
                  isFolder: false,
                  name: 'LongestStringChain.java',
                  code: 'import java.util.*;\n\npublic class LongestStringChain {\n    public boolean isPossible(String prev, String curr) {\n        int p = prev.length(), c = curr.length();\n        if (p + 1 != c) return false;\n        int i = 0, j = 0, diff = 0;\n        while (j < c) {\n            if (i < p && prev.charAt(i) == curr.charAt(j)) i++;\n            else diff++;\n            j++;\n            if (diff > 1) return false;\n        }\n        return i == p && j == c;\n    }\n\n    public int longestStrChain(String[] words) {\n        int n = words.length, maxLen = 1;\n        int[] dp = new int[n];\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int prev = 0; prev < i; prev++) {\n                if (isPossible(words[prev], words[i]) && dp[i] < dp[prev] + 1) {\n                    dp[i] = dp[prev] + 1;\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n        return maxLen;\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-string-chain/',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: 'bd50aa02-a412-402b-b992-c70385518cce',
                  isFolder: false,
                  name: 'NumberOfLIS.java',
                  code: 'import java.util.*;\n\npublic class NumberOfLIS {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int[] count = new int[n];\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            count[i] = 1;\n            for (int prev = 0; prev < i; prev++) {\n                if (nums[prev] < nums[i]) {\n                    if (dp[prev] + 1 > dp[i]) {\n                        dp[i] = dp[prev] + 1;\n                        count[i] = count[prev];\n                    } else if (dp[prev] + 1 == dp[i]) {\n                        count[i] += count[prev];\n                    }\n                }\n            }\n            max = Math.max(dp[i], max);\n        }\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[i] == max) {\n                c += count[i];\n            }\n        }\n        return c;\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-longest-increasing-subsequence/',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: 'd89fe1a9-eefd-468d-976e-497abe2b6ad4',
                  isFolder: false,
                  name: 'PrintLIS.java',
                  code: 'import java.util.*;\n\npublic class PrintLIS {\n    public static List<Integer> printingLongestIncreasingSubsequence(int[] arr, int x) {\n        // Write Your Code Here\n        int[] dp = new int[x], hash = new int[x];\n        Arrays.fill(dp, 1);\n        int maxIdx = 0;\n        for (int i = 0; i < x; i++) {\n            hash[i] = i;\n            for (int prev = 0; prev < i; prev++) {\n                if (arr[prev] < arr[i] && dp[prev] + 1 > dp[i]) {\n                    dp[i] = dp[prev] + 1;\n                    hash[i] = prev;\n                }\n            }\n            if (dp[i] > dp[maxIdx]) {\n                maxIdx = i;\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        // int i = maxIdx;\n        while (hash[maxIdx] != maxIdx) {\n            ans.add(0, arr[maxIdx]);\n            maxIdx = hash[maxIdx];\n        }\n        ans.add(0, arr[maxIdx]);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/printing-longest-increasing-subsequence_8360670',
                  notes: '',
                  tags: ['DP on LIS'],
                },
                {
                  id: '4a9b628e-5a36-4f60-9218-c54a50c28ccd',
                  isFolder: false,
                  name: 'BurstBalloons.java',
                  code: '// link: https://leetcode.com/problems/burst-balloons/\n\nimport java.util.*;\n\npublic class BurstBalloons {\n    public int solve(int[] nums, int l, int r, int[][] dp) {\n        if (l > r)\n            return 0;\n        if (dp[l][r] != -1)\n            return dp[l][r];\n        int maxi = 0;\n        for (int k = l; k <= r; k++) {\n            int coins = nums[l - 1] * nums[k] * nums[r + 1];\n            coins += solve(nums, l, k - 1, dp) + solve(nums, k + 1, r, dp);\n            maxi = Math.max(maxi, coins);\n        }\n        return dp[l][r] = maxi;\n    }\n\n    public int maxCoins(int[] nums) {\n        int c = nums.length;\n        int[] moreNums = new int[c + 2];\n\n        moreNums[0] = moreNums[c + 1] = 1;\n        for (int i = 0; i < c; i++) {\n            moreNums[i + 1] = nums[i];\n        }\n        int[][] dp = new int[c + 1][c + 1];\n        for (int i = 0; i < dp.length; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(moreNums, 1, c, dp);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['DP on MCM, Partitions'],
                },
                {
                  id: '816a4c2d-2693-4e96-a28a-1afcc09cc4ef',
                  isFolder: false,
                  name: 'MCM.java',
                  code: 'import java.util.*;\n\npublic class MCM {\n    public static int solve(int[] arr, int i, int j, int[][] dp) {\n        if (i >= j) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        int min = Integer.MAX_VALUE;\n        for (int k = i; k <= j - 1; k++) {\n            int temp = solve(arr, i, k, dp) + solve(arr, k + 1, j, dp) + arr[i - 1] * arr[k] * arr[j];\n            min = Math.min(min, temp);\n        }\n        return dp[i][j] = min;\n    }\n\n    public static int mcm(int[] p) {\n        int n = p.length;\n        int[][] dp = new int[n][n];\n        // for (int i = 0; i < n; i++) {\n        // \tArrays.fill(dp[i], -1);\n        // }\n        for (int i = n - 1; i >= 1; i--) {\n            for (int j = i + 1; j < n; j++) {\n                int min = Integer.MAX_VALUE;\n                for (int k = i; k <= j - 1; k++) {\n                    int temp = dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j];\n                    min = Math.min(min, temp);\n                }\n                dp[i][j] = min;\n            }\n        }\n        return dp[1][n - 1];\n        // return solve(p, 1, n - 1, dp);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/matrix-chain-multiplication_624880',
                  notes: '',
                  tags: ['DP on MCM, Partitions'],
                },
                {
                  id: '3e89a4e2-9ce7-4f79-93a1-368586aa33f8',
                  isFolder: false,
                  name: 'MinimumCostToCutAStick.java',
                  code: 'import java.util.*;\n\npublic class MinimumCostToCutAStick {\n    public int solve(int[] cuts, int i, int j, int[][] dp) {\n        if (i > j) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        int min = (int) 1e8;\n        for (int k = i; k <= j; k++) {\n            int temp = cuts[j + 1] - cuts[i - 1]\n                    + solve(cuts, i, k - 1, dp)\n                    + solve(cuts, k + 1, j, dp);\n            min = Math.min(min, temp);\n        }\n        return dp[i][j] = min;\n    }\n\n    public int minCost(int n, int[] cuts) {\n        int c = cuts.length;\n        int[] moreCuts = new int[c + 2];\n        for (int i = 0; i < c; i++) {\n            moreCuts[i + 1] = cuts[i];\n        }\n        moreCuts[c + 1] = n;\n        Arrays.sort(moreCuts);\n\n        int[][] dp = new int[c + 2][c + 2];\n        // for (int i = 0; i < dp.length; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n\n        // return solve(moreCuts, 1, c, dp);\n\n        for (int i = c; i >= 1; i--) {\n            for (int j = 1; j <= c; j++) {\n                if (i > j) continue;\n                int min = (int) 1e8;\n                for (int k = i; k <= j; k++) {\n                    int temp = moreCuts[j + 1] - moreCuts[i - 1]\n                            + dp[i][k - 1]\n                            + dp[k + 1][j];\n                    min = Math.min(min, temp);\n                }\n                dp[i][j] = min;\n            }\n        }\n        return dp[1][c];\n    }\n\n}',
                  link: 'https://leetcode.com/problems/minimum-cost-to-cut-a-stick/',
                  notes: '',
                  tags: ['DP on MCM, Partitions'],
                },
                {
                  id: '7063b204-def4-4357-8901-b04a8ab198d9',
                  isFolder: false,
                  name: 'PalindromePartitioning2.java',
                  code: 'import java.util.*;\n\npublic class PalindromePartitioning2 {\n    public boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n    public int solve(String s, int i, int n, int[] dp) {\n        if (i == n) return 0;\n        if (dp[i] != -1) return dp[i];\n        int mini = Integer.MAX_VALUE;\n        for (int p = i; p < n; p++) {\n            if (isPalindrome(s, i, p)) {\n                int cost = 1 + solve(s, p+1, n, dp);\n                mini = Math.min(mini, cost);\n            }\n        }\n        return dp[i] = mini;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        int[] dp = new int[n+1];\n        // Arrays.fill(dp, -1);\n        // return solve(s, 0, n, dp) - 1;\n        for (int i = n-1; i >= 0; i--) {\n            int mini = Integer.MAX_VALUE;\n            for (int p = i; p < n; p++) {\n                if (isPalindrome(s, i, p)) {\n                    int cost = 1 + dp[p+1];\n                    mini = Math.min(mini, cost);\n                }\n            }\n            dp[i] = mini;\n        }\n        return dp[0] - 1;\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-partitioning-ii/',
                  notes: '',
                  tags: ['DP on MCM, Partitions'],
                },
                {
                  id: '302c483b-d10d-4350-9d2a-7ae14c44c9b7',
                  isFolder: false,
                  name: 'ParseBooleanExpression.java',
                  code: "import java.util.*;\n\npublic class ParseBooleanExpression {\n    static int mod = 1000000007;\n\n    public static long solve(String exp, int i, int j, int isTrue, int[][][] dp) {\n        if (i > j) return 0;\n        if (i == j) {\n            char ch = exp.charAt(i);\n            if (isTrue == 1) return ch == 'T' ? 1 : 0;\n            return ch == 'F' ? 1 : 0;\n        }\n        if (dp[i][j][isTrue] != -1) return dp[i][j][isTrue];\n        int ways = 0;\n        for (int k = i + 1; k < j; k += 2) {\n            long LT = solve(exp, i, k - 1, 1, dp);\n            long RT = solve(exp, k + 1, j, 1, dp);\n            long LF = solve(exp, i, k - 1, 0, dp);\n            long RF = solve(exp, k + 1, j, 0, dp);\n            char sign = exp.charAt(k);\n            long value = 0;\n            if (sign == '&') {\n                value = isTrue == 1 ? LT*RT : LT*RF + RT*LF + LF*RF;\n            } else if (sign == '|') {\n                value = isTrue == 1 ? LT*RF + RT*LF + LT*RT : LF*RF;\n            } else {\n                value = isTrue == 1 ? LT*RF + LF*RT : LF*RF + RT*LT;\n            }\n            ways = (ways + (int)(value % mod)) % mod;\n        }\n        return dp[i][j][isTrue] = ways;\n    }\n\n    public static int evaluateExp(String exp) {\n        // Write your code here.\n        int n = exp.length();\n        int[][][] dp = new int[n][n][2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        return (int) solve(exp, 0, n - 1, 1, dp);\n    }\n}",
                  link: 'https://www.naukri.com/code360/problems/problem-name-boolean-evaluation_1214650',
                  notes: '',
                  tags: ['DP on MCM, Partitions'],
                },
                {
                  id: '9765876c-659c-474a-ad73-26ee74f5cc85',
                  isFolder: false,
                  name: 'PartitionArrayForMaxSum.java',
                  code: 'import java.util.*;\n\npublic class PartitionArrayForMaxSum {\n    public int solve(int[] arr, int i, int k, int[] dp) {\n        if (i == arr.length) return 0;\n        if (dp[i] != -1) return dp[i];\n        int ans = Integer.MIN_VALUE;\n        int len = 0;\n        int maxi = 0;\n        for (int j = i; j < arr.length; j++) {\n            if (len == k) break;\n            len++;\n            maxi = Math.max(maxi, arr[j]);\n            int sum = len * maxi + solve(arr, j + 1, k, dp);\n            ans = Math.max(ans, sum);\n        }\n        return dp[i] = ans;\n    }\n\n    public int maxSumAfterPartitioning(int[] arr, int k) {\n        int n = arr.length;\n        int[] dp = new int[n + 1];\n        // Arrays.fill(dp, -1);\n        // return solve(arr, 0, k, dp);\n        for (int i = n - 1; i >= 0; i--) {\n            int ans = Integer.MIN_VALUE;\n            int len = 0;\n            int maxi = 0;\n            for (int j = i; j < n; j++) {\n                if (len == k) break;\n                len++;\n                maxi = Math.max(maxi, arr[j]);\n                int sum = len * maxi + dp[j + 1];\n                ans = Math.max(ans, sum);\n            }\n            dp[i] = ans;\n        }\n        return dp[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/partition-array-for-maximum-sum/',
                  notes: '',
                  tags: ['DP on MCM, Partitions'],
                },
                {
                  id: '97b83e81-667e-4909-aec6-c1296fdbf3f1',
                  isFolder: false,
                  name: 'CountSquareSubmatricesWithAll1s.java',
                  code: 'import java.util.*;\n\npublic class CountSquareSubmatricesWithAll1s {\n    public int countSquares(int[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[][] mat = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            mat[i][0] = matrix[i][0];\n        }\n        for (int i = 0; i < m; i++) {\n            mat[0][i] = matrix[0][i];\n        }\n        int ans = 0;\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                if (matrix[i][j] == 1) {\n                    mat[i][j] = 1 + Math.min(Math.min(mat[i - 1][j], mat[i][j - 1]), mat[i - 1][j - 1]);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                ans += mat[i][j];\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/count-square-submatrices-with-all-ones/',
                  notes: '',
                  tags: ['DP on Squares'],
                },
                {
                  id: '470d97c2-beec-4738-93cc-3df6ff166101',
                  isFolder: false,
                  name: 'MaxRectangleAreaWithAll1s.java',
                  code: "import java.util.*;\npublic class MaxRectangleAreaWithAll1s {\n    public static int[] getPSE(char[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n\n    public static int[] getNSE(char[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = n;\n        return ans;\n    }\n\n    public static int largestRectangleArea(char[] heights) {\n        int n = heights.length;\n        int[] nse = getNSE(heights, n), pse = getPSE(heights, n);\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++)\n            maxArea = Math.max(maxArea, (nse[i] - pse[i] - 1) * (heights[i] - '0'));\n        return maxArea;\n    }\n\n    public int maximalRectangle(char[][] M) {\n        int max = largestRectangleArea(M[0]);\n        for (int i = 1; i < M.length; i++) {\n            for (int j = 0; j < M[0].length; j++)\n                if (M[i][j] == '1')\n                    M[i][j] = (char) (M[i][j] + M[i - 1][j] - '0');\n            max = Math.max(max, largestRectangleArea(M[i]));\n        }\n        return max;\n    }\n}",
                  link: 'https://leetcode.com/problems/maximal-rectangle/',
                  notes: '',
                  tags: ['DP on Squares'],
                },
                {
                  id: '59d6cc48-479d-46da-9be8-79a1fad155a8',
                  isFolder: false,
                  name: 'BestTimeToBuySellStocks.java',
                  code: 'import java.util.*;\npublic class BestTimeToBuySellStocks {\n    public int maxProfit(int[] prices) {\n        int minVal = prices[0], maxDiff = 0;\n        for (int i = 1; i < prices.length; i++) {\n            minVal = Math.min(minVal, prices[i]);\n            maxDiff = Math.max(maxDiff, prices[i] - minVal);\n        }\n        return maxDiff;\n    }\n}',
                  link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock/',
                  notes: '',
                  tags: ['DP on Stocks'],
                },
                {
                  id: '6887f8e4-a349-4098-b4ab-4269348f21f5',
                  isFolder: false,
                  name: 'BestTimeToBuySellStocks2.java',
                  code: 'public class BestTimeToBuySellStocks2 {\n    // 0 = sell\n    // 1 = buy\n    public int solve(int[] prices, int i, int last, int[][] dp) {\n        if (i == prices.length) return 0;\n        if (dp[i][last] != -1) return dp[i][last];\n        int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        if (last == 0) {\n            buy = -prices[i] + solve(prices, i+1, 1, dp);\n            notBuy = solve(prices, i+1, 0, dp);\n        } else {\n            sell = prices[i] + solve(prices, i+1, 0, dp);\n            notSell = solve(prices, i+1, 1, dp);\n        }\n        return dp[i][last] = Math.max(buy + sell, notBuy + notSell);\n    }\n\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n+1][2];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(prices, 0, 0, dp);\n\n        for (int i = n-1; i >= 0; i--) {\n            for (int j = 1; j >= 0; j--) {\n                int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n                if (j == 0) {\n                    buy = -prices[i] + dp[i+1][1];\n                    notBuy = dp[i+1][0];\n                } else {\n                    sell = prices[i] + dp[i+1][0];\n                    notSell = dp[i+1][1];\n                }\n                dp[i][j] = Math.max(buy + sell, notBuy + notSell);\n            }\n        }\n        return dp[0][0];\n    }\n}',
                  link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/',
                  notes: '',
                  tags: ['DP on Stocks'],
                },
                {
                  id: '33bfaac3-c795-4fd2-9933-9111c996194f',
                  isFolder: false,
                  name: 'BestTimeToBuySellStocks3.java',
                  code: 'import java.util.*;\n\npublic class BestTimeToBuySellStocks3 {\n    public int solve2(int[] prices, int i, int transaction, int[][] dp) {\n        if (i == prices.length || transaction == 4) return 0;\n        if (dp[i][transaction] != -1) return dp[i][transaction];\n        int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        if ((transaction&1) == 0) {\n            buy = -prices[i] + solve2(prices, i+1, transaction + 1, dp);\n            notBuy = solve2(prices, i+1, transaction, dp);\n        } else {\n            sell = prices[i] + solve2(prices, i+1, transaction + 1, dp);\n            notSell = solve2(prices, i+1, transaction, dp);\n        }\n        return dp[i][transaction] = Math.max(buy + sell, notBuy + notSell);\n    }\n\n    public int solve(int[] prices, int i, int last, int cap, int[][][] dp) {\n        if (i == prices.length || cap == 0) return 0;\n        if (dp[i][last][cap] != -1) return dp[i][last][cap];\n        int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        if (last == 0) {\n            buy = -prices[i] + solve(prices, i+1, 1, cap, dp);\n            notBuy = solve(prices, i+1, 0, cap, dp);\n        } else {\n            sell = prices[i] + solve(prices, i+1, 0, cap - 1, dp);\n            notSell = solve(prices, i+1, 1, cap, dp);\n        }\n        return dp[i][last][cap] = Math.max(buy + sell, notBuy + notSell);\n    }\n\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        // int[][][] dp = new int[n+1][2][3];\n        // for (int i = 0; i < n; i++) {\n        //     for (int j = 0; j < 2; j++) {\n        //         Arrays.fill(dp[i][j], -1);\n        //     }\n        // }\n        // return solve(prices, 0, 0, 2, dp);\n\n        // for (int i = n-1; i >= 0; i--) {\n        //     for (int j = 1; j >= 0; j--) {\n        //         for (int k = 1; k <= 2; k++) {\n        //             int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        //             if (j == 0) {\n        //                 buy = -prices[i] + dp[i+1][1][k];\n        //                 notBuy = dp[i+1][0][k];\n        //             } else {\n        //                 sell = prices[i] + dp[i+1][0][k-1];\n        //                 notSell = dp[i+1][1][k];\n        //             }\n        //             dp[i][j][k] = Math.max(buy + sell, notBuy + notSell);\n        //         }\n        //     }\n        // }\n        // return dp[0][0][2];\n\n        int[][] dp = new int[n+1][5];\n        for (int i = n-1; i >= 0; i--) {\n            for (int transaction = 3; transaction >= 0; transaction--) {\n                int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n                if ((transaction&1) == 0) {\n                    buy = -prices[i] + dp[i+1][transaction + 1];\n                    notBuy = dp[i+1][transaction];\n                } else {\n                    sell = prices[i] + dp[i+1][transaction + 1];\n                    notSell = dp[i+1][transaction];\n                }\n                dp[i][transaction] = Math.max(buy + sell, notBuy + notSell);\n            }\n        }\n        return dp[0][0];\n    }\n}',
                  link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/',
                  notes: '',
                  tags: ['DP on Stocks'],
                },
                {
                  id: 'c4aa732d-3b36-4a57-af14-7382064c620a',
                  isFolder: false,
                  name: 'BestTimeToBuySellStocks4.java',
                  code: 'import java.util.*;\n\npublic class BestTimeToBuySellStocks4 {\n    public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n+1][2*k+1];\n        for (int i = n-1; i >= 0; i--) {\n            for (int transaction = 2*k - 1; transaction >= 0; transaction--) {\n                int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n                if ((transaction&1) == 0) {\n                    buy = -prices[i] + dp[i+1][transaction + 1];\n                    notBuy = dp[i+1][transaction];\n                } else {\n                    sell = prices[i] + dp[i+1][transaction + 1];\n                    notSell = dp[i+1][transaction];\n                }\n                dp[i][transaction] = Math.max(buy + sell, notBuy + notSell);\n            }\n        }\n        return dp[0][0];\n    }\n}',
                  link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/',
                  notes: '',
                  tags: ['DP on Stocks'],
                },
                {
                  id: '8aa6cf4d-26ce-4bce-86d1-63dbc9b8d293',
                  isFolder: false,
                  name: 'BestTimeToBuySellStocksWithCooldown.java',
                  code: 'import java.util.*;\n\npublic class BestTimeToBuySellStocksWithCooldown {\n    public int solve(int[] prices, int i, int last, int[][] dp) {\n        if (i >= prices.length) return 0;\n        if (dp[i][last] != -1) return dp[i][last];\n        int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        if (last == 0) {\n            buy = -prices[i] + solve(prices, i+1, 1, dp);\n            notBuy = solve(prices, i+1, 0, dp);\n        } else {\n            sell = prices[i] + solve(prices, i+2, 0, dp);\n            notSell = solve(prices, i+1, 1, dp);\n        }\n        return dp[i][last] = Math.max(buy + sell, notBuy + notSell);\n    }\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        int[][] dp = new int[n+1][2];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(prices, 0, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/',
                  notes: '',
                  tags: ['DP on Stocks'],
                },
                {
                  id: '0f2ef268-a80d-4f1b-bc78-c552eba21897',
                  isFolder: false,
                  name: 'BestTimeToBuySellStocksWithTransactionFee.java',
                  code: 'import java.util.*;\n\npublic class BestTimeToBuySellStocksWithTransactionFee {\n    public int solve(int[] prices, int i, int last, int[][] dp, int fee) {\n        if (i == prices.length) return 0;\n        if (dp[i][last] != -1) return dp[i][last];\n        int sell = 0, notSell = 0, buy = 0, notBuy = 0;\n        if (last == 0) {\n            buy = -prices[i] + solve(prices, i + 1, 1, dp, fee);\n            notBuy = solve(prices, i + 1, 0, dp, fee);\n        } else {\n            sell = prices[i] - fee + solve(prices, i + 1, 0, dp, fee);\n            notSell = solve(prices, i + 1, 1, dp, fee);\n        }\n        return dp[i][last] = Math.max(buy + sell, notBuy + notSell);\n    }\n\n    public int maxProfit(int[] prices, int fee) {\n        int n = prices.length;\n        // int[][] dp = new int[n+1][2];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(prices, 0, 0, dp, fee);\n        int[][] dp = new int[n + 1][2];\n        for (int i = n - 1; i >= 0; i--) {\n            int buy = -prices[i] + dp[i + 1][1];\n            int notBuy = dp[i + 1][0];\n            dp[i][0] = Math.max(buy, notBuy);\n            int sell = prices[i] - fee + dp[i + 1][0];\n            int notSell = dp[i + 1][1];\n            dp[i][1] = Math.max(sell, notSell);\n        }\n        return dp[0][0];\n    }\n}',
                  link: 'https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/',
                  notes: '',
                  tags: ['DP on Stocks'],
                },
                {
                  id: 'c44735d7-e4d7-4b23-bbb2-fa4bd6d9580c',
                  isFolder: false,
                  name: 'DeletionsToMakeStringsEqual.java',
                  code: 'import java.util.*;\n\npublic class DeletionsToMakeStringsEqual {\n    public int minDistance(String word1, String word2) {\n        int n = word1.length();\n        int m = word2.length();\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return m - dp[n][m] + n - dp[n][m];\n    }\n}',
                  link: 'https://leetcode.com/problems/delete-operation-for-two-strings/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: '21bccb22-eaa6-4d1a-a5f1-94227c6681a9',
                  isFolder: false,
                  name: 'DistinctSubsequences.java',
                  code: 'import java.util.*;\n\npublic class DistinctSubsequences {\n    public int solve(String s, String t, int i, int j, int[][] dp) {\n        if (j == t.length()) return 1;\n        if (i == s.length()) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        int count = solve(s, t, i+1, j, dp);\n        if (s.charAt(i) == t.charAt(j)) {\n            count += solve(s, t, i+1, j+1, dp);\n        }\n        return dp[i][j] = count;\n    }\n\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[s.length()][t.length()];\n        for (int i = 0; i < s.length(); i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(s, t, 0, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/distinct-subsequences/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: 'c30fc1ed-e2e5-474f-9c54-3cbc66838a6f',
                  isFolder: false,
                  name: 'EditDistance.java',
                  code: 'import java.util.*;\n\npublic class EditDistance {\n    public int solve(String w1, String w2, int n, int m, int[][] dp) {\n        if (n < 0) return m + 1;\n        if (m < 0) return n + 1;\n        if (dp[n][m] != -1) return dp[n][m];\n        if (w1.charAt(n) == w2.charAt(m)) {\n            return dp[n][m] = solve(w1, w2, n - 1, m - 1, dp);\n        } else {\n            int insert = solve(w1, w2, n, m - 1, dp);\n            int replace = solve(w1, w2, n - 1, m - 1, dp);\n            int delete = solve(w1, w2, n - 1, m, dp);\n            return dp[n][m] = 1 + Math.min(Math.min(insert, delete), replace);\n        }\n    }\n\n    public int minDistance(String word1, String word2) {\n        int n = word1.length(), m = word2.length();\n        int[][] dp = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(word1, word2, n - 1, m - 1, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/edit-distance/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: 'df96ceba-244e-46c5-93b5-c4b74e91fcae',
                  isFolder: false,
                  name: 'LongestCommonSubsequence.java',
                  code: 'import java.util.*;\n\npublic class LongestCommonSubsequence {\n    public int solve(String text1, String text2, int i1, int i2, int[][] dp) {\n        if (i1 < 0 || i2 < 0) return 0;\n        if (dp[i1][i2] != -1) return dp[i1][i2];\n        if (text1.charAt(i1) == text2.charAt(i2)) {\n            return dp[i1][i2] = 1 + solve(text1, text2, i1 - 1, i2 - 1, dp);\n        }\n        return dp[i1][i2] = Math.max(solve(text1, text2, i1 - 1, i2, dp), solve(text1, text2, i1, i2 - 1, dp));\n    }\n\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n = text1.length(), m = text2.length();\n        int[][] dp = new int[n + 1][m + 1];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(text1, text2, n-1, m-1, dp);\n\n//        Tabulation\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[n][m];\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-common-subsequence/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: '71f74706-0540-40f5-bc70-99b782bf5202',
                  isFolder: false,
                  name: 'LongestCommonSubstring.java',
                  code: 'import java.util.*;\n\npublic class LongestCommonSubstring {\n    public static int lcs(String str1, String str2) {\n        // Write your code here.\n        int n = str1.length();\n        int m = str2.length();\n        int[][] dp = new int[n + 1][m + 1];\n        int max = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                    max = Math.max(max, dp[i][j]);\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        return max;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/longest-common-substring_1235207',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: '0abd69f9-f8b0-46ef-aa5e-e7700768e347',
                  isFolder: false,
                  name: 'LongestPalindromicSubsequence.java',
                  code: 'import java.util.*;\n\npublic class LongestPalindromicSubsequence {\n    public int solve(String s, int i, int j, int[][] dp) {\n        if (i > j) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        if (s.charAt(i) == s.charAt(j)) {\n            return dp[i][j] = (i == j ? 1 : 2) + solve(s, i + 1, j - 1, dp);\n        }\n        return dp[i][j] = Math.max(solve(s, i+1, j, dp), solve(s, i, j-1, dp));\n    }\n    public int longestPalindromeSubseq(String s) {\n//        lcs(s, reversed(s));\n        int n = s.length();\n        if (n <= 1) return n;\n        int[][] dp = new int[n+1][n+1];\n        for (int i = 0; i <= n; i++) Arrays.fill(dp[i], -1);\n        return solve(s, 0, n - 1, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-palindromic-subsequence/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: 'fb8b223a-d6db-4cfc-8e58-e8ba9c520c03',
                  isFolder: false,
                  name: 'MinInsertionsToMakeStringPalindrome.java',
                  code: 'import java.util.*;\n\npublic class MinInsertionsToMakeStringPalindrome {\n    public int minInsertions(String s) {\n        // Basically n - longestPalindromicSubsequence(s);\n        int n = s.length();\n        int[][] dp = new int[n + 1][n + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s.charAt(i - 1) == s.charAt(n - j)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return n - dp[n][n];\n    }\n}',
                  link: 'https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: 'e216fd98-2715-448f-bb23-823c7a9d36b9',
                  isFolder: false,
                  name: 'PrintLongestCommonSubsequence.java',
                  code: 'import java.util.*;\n\npublic class PrintLongestCommonSubsequence {\n    public static String solve(int i1, int i2, String s1, String s2, String[][] dp) {\n        if (i1 < 0 || i2 < 0)\n            return "";\n        if (dp[i1][i2] != null) return dp[i1][i2];\n        if (s1.charAt(i1) == s2.charAt(i2)) {\n            return dp[i1][i2] = s1.charAt(i1) + solve(i1 - 1, i2 - 1, s1, s2, dp);\n        }\n        String a = solve(i1 - 1, i2, s1, s2, dp);\n        String b = solve(i1, i2 - 1, s1, s2, dp);\n        if (a.length() >= b.length()) return dp[i1][i2] = a;\n        return dp[i1][i2] = b;\n    }\n\n    public static String findLCS(int n, int m, String s1, String s2) {\n        // Write your code here.\n        // String[][] dp = new String[n][m];\n        // return solve(n-1, m-1, s1, s2, dp);\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                dp[i][j] = s1.charAt(i) == s2.charAt(j)\n                        ? 1 + dp[i - 1][j - 1]\n                        : Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        char[] str = new char[dp[n][m]];\n        int idx = str.length - 1;\n        int i = n, j = m;\n        while (i > 0 && j > 0) {\n            char ch1 = s1.charAt(i - 1);\n            char ch2 = s2.charAt(j - 1);\n            if (ch1 == ch2) {\n                str[idx--] = ch1;\n                i--;\n                j--;\n            } else if (dp[i - 1][j] >= dp[i][j - 1]) i--;\n            else j--;\n        }\n        return new String(str);\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/print-longest-common-subsequence_8416383',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: 'bb631847-34fb-4f5e-bc6f-0158c1c474de',
                  isFolder: false,
                  name: 'ShortestCommonSupersequence.java',
                  code: 'import java.util.*;\n\npublic class ShortestCommonSupersequence {\n    public void lcs(String s1, String s2, int n, int m, int[][] dp) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n    }\n\n    public String shortestCommonSupersequence(String s1, String s2) {\n        int n = s1.length(), m = s2.length();\n        int[][] dp = new int[n + 1][m + 1];\n        lcs(s1, s2, n, m, dp);\n        StringBuilder sb = new StringBuilder();\n        while (n > 0 && m > 0) {\n            char a = s1.charAt(n - 1);\n            char b = s2.charAt(m - 1);\n            if (a == b) {\n                sb.append(a);\n                n--;\n                m--;\n            } else if (dp[n - 1][m] >= dp[n][m - 1]) {\n                sb.append(a);\n                n--;\n            } else {\n                sb.append(b);\n                m--;\n            }\n        }\n\n        while (n > 0) {\n            sb.append(s1.charAt(--n));\n        }\n\n        while (m > 0) {\n            sb.append(s2.charAt(--m));\n        }\n        return sb.reverse().toString();\n    }\n}',
                  link: 'https://leetcode.com/problems/shortest-common-supersequence/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: '522b9a3d-46c7-45b8-b1a5-fb645c8d40b1',
                  isFolder: false,
                  name: 'WildcardMatching.java',
                  code: "import java.util.*;\n\npublic class WildcardMatching {\n    public boolean solve(String s, String p, int n, int m, int[][] dp) {\n        if (n < 0 && m < 0) return true;\n        if (n >= 0 && m < 0) return false;\n        if (n < 0 && m >= 0) {\n            for (int i = 0; i <= m; i++) {\n                if (p.charAt(i) != '*') return false;\n            }\n            return true;\n        }\n        if (dp[n][m] != -1) return dp[n][m] == 1;\n        boolean ans = false;\n        if (s.charAt(n) == p.charAt(m) || p.charAt(m) == '?') {\n            ans = solve(s, p, n - 1, m - 1, dp);\n        } else if (p.charAt(m) == '*') {\n            ans = solve(s, p, n, m - 1, dp) || solve(s, p, n - 1, m, dp);\n        }\n        dp[n][m] = ans ? 1 : 0;\n        return ans;\n    }\n\n    public boolean isMatch(String s, String p) {\n        int n = s.length(), m = p.length();\n        int[][] dp = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(s, p, n - 1, m - 1, dp);\n    }\n}",
                  link: 'https://leetcode.com/problems/wildcard-matching/',
                  notes: '',
                  tags: ['DP on Strings'],
                },
                {
                  id: 'd9f3b99d-57ba-4d8c-90fe-f6523e64a3b2',
                  isFolder: false,
                  name: 'CoinChange.java',
                  code: 'import java.util.*;\n\npublic class CoinChange {\n    public int solve(int[] coins, int amount, int idx, int[][] dp) {\n        if (amount == 0) return 0;\n        if (idx == 0) {\n            if (amount % coins[idx] == 0) return amount / coins[idx];\n            return 10001;\n        }\n        if (dp[idx][amount] != -1) return dp[idx][amount];\n        int notPick = solve(coins, amount, idx - 1, dp), pick = 10001;\n        if (coins[idx] <= amount) {\n            pick = 1 + solve(coins, amount - coins[idx], idx, dp);\n        }\n        return dp[idx][amount] = Math.min(pick, notPick);\n    }\n\n    public int coinChange(int[] coins, int amount) {\n        // int n = coins.length;\n        // int[][] dp = new int[n][amount + 1];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // int ans = solve(coins, amount, n - 1, dp);\n        // return ans > 10000 ? -1 : ans;\n        int n = coins.length;\n        int[][] dp = new int[n][amount + 1];\n        for (int i = 0; i <= amount; i++) {\n            dp[0][i] = (i % coins[0]) == 0 ? i / coins[0] : 10001;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j <= amount; j++) {\n                int notPick = dp[i - 1][j], pick = 10001;\n                if (coins[i] <= j) {\n                    pick = 1 + dp[i][j - coins[i]];\n                }\n                dp[i][j] = Math.min(pick, notPick);\n            }\n        }\n        return dp[n - 1][amount] > 10000 ? -1 : dp[n - 1][amount];\n    }\n}',
                  link: 'https://leetcode.com/problems/coin-change/',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '0e68aa98-a83b-4913-9fe6-715a0921ba2c',
                  isFolder: false,
                  name: 'CoinChange2.java',
                  code: 'import java.util.*;\n\npublic class CoinChange2 {\n    public int solve(int[] coins, int amount, int idx, int[][] dp) {\n        if (idx == 0) {\n            if (amount % coins[idx] == 0) return 1;\n            return 0;\n        }\n        if (dp[idx][amount] != -1) return dp[idx][amount];\n        int notPick = solve(coins, amount, idx - 1, dp);\n        int pick = 0;\n        if (coins[idx] <= amount) {\n            pick = solve(coins, amount - coins[idx], idx, dp);\n        }\n        return dp[idx][amount] = pick + notPick;\n    }\n    public int change(int amount, int[] coins) {\n        int n = coins.length;\n        int[][] dp = new int[n][amount + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(coins, amount, n - 1, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/coin-change-ii/',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '2d384805-aa14-48f2-835a-425ae63ce9ab',
                  isFolder: false,
                  name: 'CountPartitionsWithGivenDifference.java',
                  code: 'import java.util.*;\n\npublic class CountPartitionsWithGivenDifference {\n    static int mod = (int) 1e9+7;\n    public static int solve(int[] arr, int i, int sum, int[][] dp) {\n        if (i == 0) {\n            if (sum == 0 && arr[i] == 0) return 2;\n            if (sum == 0 || sum == arr[i]) return 1;\n            return 0;\n        }\n        if (dp[i][sum] != -1) return dp[i][sum];\n        int np = solve(arr, i-1, sum, dp);\n        int p = arr[i] <= sum ? solve(arr, i - 1, sum - arr[i], dp) : 0;\n        return dp[i][sum] = (p + np)%mod;\n    }\n\n    public static int countPartitions(int n, int d, int[] arr) {\n        // Write your code here.\n        int total = 0;\n        for (int i : arr) {\n            total += i;\n        }\n        int[][] dp = new int[n][((total + d)/2) + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        if (total + d < 0 || (total+d) % 2 != 0) return 0;\n        return solve(arr, n-1, (total+d)/2, dp);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/partitions-with-given-difference_3751628',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: 'e4e0d1f0-a558-4450-9107-e3b1a477f3bf',
                  isFolder: false,
                  name: 'CountSubsetsWithSumK.java',
                  code: 'import java.util.*;\n\npublic class CountSubsetsWithSumK {\n    static int mod = (int) 1e9 + 7;\n\n    public static int solve(int[] arr, int n, int k, int i, int[][] dp) {\n        if (i == n - 1) {\n//            Zero Case\n            if (k == 0 && arr[i] == 0) return 2;\n            if (k == 0 || k == arr[i]) return 1;\n            return 0;\n        }\n        if (dp[i][k] != -1) return dp[i][k];\n        int pick = 0, notpick = 0;\n        if (arr[i] <= k) {\n            pick = solve(arr, n, k - arr[i], i + 1, dp);\n        }\n        notpick = solve(arr, n, k, i + 1, dp);\n        return dp[i][k] = (pick + notpick) % mod;\n    }\n\n    public static int findWays(int[] num, int tar) {\n        // Write your code here\n        int n = num.length;\n        int[][] dp = new int[n][tar + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(num, n, tar, 0, dp);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/count-subsets-with-sum-k_3952532',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '5d488254-d9a4-44bd-ba4f-b5c354916cbc',
                  isFolder: false,
                  name: 'Knapsack01.java',
                  code: 'import java.util.*;\n\npublic class Knapsack01 {\n    static int solve(int[] weight, int[] value, int n, int maxWeight, int[][] dp) {\n        if (maxWeight == 0) return 0;\n        if (n == 0) {\n            if (maxWeight >= weight[n]) return value[n];\n            return 0;\n        }\n        if (dp[n][maxWeight] != -1) return dp[n][maxWeight];\n        int np = solve(weight, value, n - 1, maxWeight, dp);\n        int p = 0;\n        if (weight[n] <= maxWeight) {\n            p = value[n] + solve(weight, value, n - 1, maxWeight - weight[n], dp);\n        }\n        return dp[n][maxWeight] = Math.max(np, p);\n    }\n\n    static int knapsack(int[] weight, int[] value, int n, int maxWeight) {\n        int[][] dp = new int[n][maxWeight + 1];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(weight, value, n-1, maxWeight, dp);\n        // BASE CASE\n        for (int i = 0; i <= maxWeight; i++) {\n            if (weight[0] <= i) {\n                dp[0][i] = value[0];\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= maxWeight; j++) {\n                int np = dp[i - 1][j];\n                int p = 0;\n                if (weight[i] <= j) {\n                    p = value[i] + dp[i - 1][j - weight[i]];\n                }\n                dp[i][j] = Math.max(np, p);\n            }\n        }\n        return dp[n - 1][maxWeight];\n    }\n\n}',
                  link: 'https://www.codingninjas.com/studio/problems/0-1-knapsack_920542',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: 'faeb527f-bfd3-4ff5-b391-4d2f642b1899',
                  isFolder: false,
                  name: 'PartitionEqualSubsetSum.java',
                  code: 'import java.util.*;\n\npublic class PartitionEqualSubsetSum {\n    public static boolean solve(int[] arr, int n, int k, int i, int[][] dp) {\n        if (k == 0) return true;\n        if (i == n || k < 0) return false;\n        if (dp[i][k] != -1) return dp[i][k] == 1;\n        boolean pick = false, notpick = solve(arr, n, k, i + 1, dp);\n        if (arr[i] <= k) {\n            pick = solve(arr, n, k - arr[i], i + 1, dp);\n        }\n        dp[i][k] = (pick || notpick) ? 1 : 0;\n        return pick || notpick;\n    }\n\n    public boolean canPartition(int[] nums) {\n        int n = nums.length, sum = 0;\n        if (n <= 1) return false;\n        for (int i : nums) {\n            sum += i;\n        }\n        if ((sum & 1) == 1) return false;\n        sum = sum / 2;\n        int[][] dp = new int[n][sum + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(nums, n, sum, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/partition-equal-subset-sum/',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '37b3d2e8-897a-480f-b282-a1e3af3b3908',
                  isFolder: false,
                  name: 'PartitionSetInto2SubsetsWithMinDifference.java',
                  code: 'import java.util.*;\n\npublic class PartitionSetInto2SubsetsWithMinDifference {\n    public static int minSubsetSumDifference(int[] nums, int n) {\n        // Write your code here.\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n        }\n        boolean[][] dp = new boolean[n][sum + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        if (nums[0] <= sum) {\n            dp[0][nums[0]] = true;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                boolean notPick = dp[i - 1][j], pick = false;\n                if (nums[i] <= j) {\n                    pick = dp[i - 1][j - nums[i]];\n                }\n                dp[i][j] = pick || notPick;\n            }\n        }\n        int min = (int) 1e8;\n        for (int i = 0; i <= sum / 2; i++) {\n            if (dp[n - 1][i]) {\n                min = Math.min(min, Math.abs(sum - i - i));\n            }\n        }\n        return min;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum._842494',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: 'e5f10688-5be5-4c4f-85eb-5b682c939e47',
                  isFolder: false,
                  name: 'RodCuttingProblem.java',
                  code: 'import java.util.*;\n\npublic class RodCuttingProblem {\n    public static int solve(int[] price, int n, int size, int[] dp) {\n        if (size > n) return (int) -1e8;\n        if (size == n) return 0;\n        if (dp[size] != -1) return dp[size];\n        int maxPick = 0;\n        for (int i = 1; i <= price.length - size; i++) {\n            int pick = price[i - 1] + solve(price, n, size + i, dp);\n            maxPick = Math.max(maxPick, pick);\n        }\n        return dp[size] = maxPick;\n    }\n    public static int cutRod(int[] price, int n) {\n        // Write your code here.\n        int[] dp = new int[n+1];\n        Arrays.fill(dp, -1);\n        return solve(price, n, 0, dp);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/rod-cutting-problem_800284',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '35367410-58e2-4931-ba22-534aa436bd35',
                  isFolder: false,
                  name: 'SubsetSumEqualToK.java',
                  code: 'import java.util.*;\n\npublic class SubsetSumEqualToK {\n    public static boolean solve(int[] arr, int n, int i, int k, int[][] dp) {\n        if (k == 0) return true;\n        if (i == n) return false;\n        if (dp[i][k] != -1) return dp[i][k] == 1;\n        boolean pick = false;\n        if (arr[i] <= k) {\n            pick = solve(arr, n, i + 1, k - arr[i], dp);\n        }\n        boolean notPick = solve(arr, n, i + 1, k, dp);\n        dp[i][k] = (pick || notPick) ? 1 : 0;\n        return pick || notPick;\n    }\n\n    public static boolean subsetSumToK(int n, int k, int arr[]) {\n        // Write your code here.\n//        MEMOIZATION\n        // int[][] dp = new int[n][k+1];\n        // for (int i = 0; i < n; i++) {\n        //     Arrays.fill(dp[i], -1);\n        // }\n        // return solve(arr, n, 0, k, dp);\n\n//        TABULATION\n        boolean[][] dp = new boolean[n][k + 1];\n        // BASE CASE\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        if (arr[0] <= k) {\n            dp[0][arr[0]] = true;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j <= k; j++) {\n                boolean notPick = dp[i - 1][j], pick = false;\n                if (arr[i] <= j) {\n                    pick = dp[i - 1][j - arr[i]];\n                }\n                dp[i][j] = pick || notPick;\n            }\n        }\n        return dp[n - 1][k];\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/subset-sum-equal-to-k_1550954',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '29bcda25-ed78-44b6-9758-736be4a7fa12',
                  isFolder: false,
                  name: 'TargetSum.java',
                  code: 'import java.util.*;\n\npublic class TargetSum {\n    public static int solve(int[] arr, int i, int sum, int[][] dp) {\n        if (i == 0) {\n            if (sum == 0 && arr[i] == 0) return 2;\n            if (sum == 0 || sum == arr[i]) return 1;\n            return 0;\n        }\n        if (dp[i][sum] != -1) return dp[i][sum];\n        int np = solve(arr, i-1, sum, dp);\n        int p = arr[i] <= sum ? solve(arr, i - 1, sum - arr[i], dp) : 0;\n        return dp[i][sum] = p + np;\n    }\n\n    public static int countPartitions(int n, int d, int[] arr) {\n        // Write your code here.\n        int total = 0;\n        for (int i : arr) {\n            total += i;\n        }\n        if (total + d < 0 || (total+d) % 2 != 0) return 0;\n        int[][] dp = new int[n][((total + d)/2) + 1];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(arr, n-1, (total+d)/2, dp);\n    }\n\n    // public int solve(int[] nums, int idx, int target, HashMap<String, Integer> hm) {\n    //     if (idx < 0) {\n    //         if (target == 0) return 1;\n    //         return 0;\n    //     }\n    //     String key = idx + "," + target;\n    //     if (hm.containsKey(key)) return hm.get(key);\n    //     int np = solve(nums, idx - 1, target - nums[idx], hm);\n    //     int p = solve(nums, idx - 1, target + nums[idx], hm);\n    //     hm.put(key, np + p);\n    //     return np + p;\n    // }\n\n    public int findTargetSumWays(int[] nums, int target) {\n        int n = nums.length;\n        // HashMap<String, Integer> hm = new HashMap<>();\n        // return solve(nums, n-1, target, hm);\n        return countPartitions(n, target, nums);\n    }\n}',
                  link: 'https://leetcode.com/problems/target-sum/',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
                {
                  id: '6d27c873-0625-4000-941a-0dc7eec15dd7',
                  isFolder: false,
                  name: 'UnboundedKnapsack.java',
                  code: 'import java.util.*;\n\npublic class UnboundedKnapsack {\n    public static int solve(int idx, int w, int[] profit, int[] weight, int[][] dp) {\n        if (idx == 0) {\n            int times = w / weight[idx];\n            if (times > 0) return times * profit[0];\n            return 0;\n        }\n        if (dp[idx][w] != -1) return dp[idx][w];\n        int pick = 0;\n        if (weight[idx] <= w) {\n            pick = profit[idx] + solve(idx, w - weight[idx], profit, weight, dp);\n        }\n        int notPick = solve(idx-1, w, profit, weight, dp);\n        return dp[idx][w] = Math.max(pick, notPick);\n    }\n    public static int unboundedKnapsack(int n, int w, int[] profit, int[] weight) {\n        // Write your code here.\n        int[][] dp = new int[n][w+1];\n        // for (int i = 0; i < n; i++) Arrays.fill(dp[i], -1);\n        // return solve(n-1, w, profit, weight, dp);\n        // BASE CASE\n        for (int i = 0; i <= w; i++) {\n            if (i >= weight[0]) {\n                int times = i / weight[0];\n                dp[0][i] = times * profit[0];\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j <= w; j++) {\n                int pick = 0;\n                if (weight[i] <= j) {\n                    pick = profit[i] + dp[i][j-weight[i]];\n                }\n                int notPick = dp[i-1][j];\n                dp[i][j] = Math.max(pick, notPick);\n            }\n        }\n        return dp[n-1][w];\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/unbounded-knapsack_1215029',
                  notes: '',
                  tags: ['DP on Subsequences'],
                },
              ],
            },
            {
              id: '8f9d5d54-d07d-4616-9bc9-4a5f5e2ca24e',
              isFolder: true,
              name: 'Graphs',
              content: [
                {
                  id: 'c53db335-f4f1-4ecd-80b3-bfff48ab58ee',
                  isFolder: false,
                  name: 'Graph.java',
                  code: 'import java.util.*;\n\npublic class Graph {\n    static class Edge {\n        int source, destination;\n\n        Edge(int s, int d) {\n            this.source = s;\n            this.destination = d;\n        }\n\n        @Override\n        public String toString() {\n            return "Edge{ src=" + source + ", dest=" + destination + \'}\';\n        }\n    }\n\n    static int getNeighbours(List<Edge> adjListItem) {\n        System.out.print("Neighbours: ");\n        for (Edge e : adjListItem) {\n            System.out.print(e.destination + " ");\n        }\n        return adjListItem.size();\n    }\n\n    static void buildGraph(List<Edge>[] adjList) {\n        for (int i = 0; i < adjList.length; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n        adjList[0].add(new Edge(0, 1));\n        adjList[0].add(new Edge(0, 2));\n\n        adjList[1].add(new Edge(1, 0));\n        adjList[1].add(new Edge(1, 3));\n\n        adjList[2].add(new Edge(2, 0));\n        adjList[2].add(new Edge(2, 4));\n\n        adjList[3].add(new Edge(3, 1));\n        adjList[3].add(new Edge(3, 4));\n\n        adjList[4].add(new Edge(4, 2));\n        adjList[4].add(new Edge(4, 5));\n\n        adjList[5].add(new Edge(5, 3));\n        adjList[5].add(new Edge(5, 4));\n        adjList[5].add(new Edge(5, 6));\n\n        adjList[6].add(new Edge(6, 5));\n    }\n\n    static void bfs(List<Edge>[] adjList) {\n        boolean[] visited = new boolean[adjList.length];\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n    static void bfsDisjoint(List<Edge>[] adjList, boolean[] visited, int start) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(start);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n\n    static void dfs(List<Edge>[] adjList, boolean[] visited, int curr) {\n        System.out.print(curr + " ");\n        visited[curr] = true;\n        for (int i = 0; i < adjList[curr].size(); i++) {\n            int dist = adjList[curr].get(i).destination;\n            if (!visited[dist]) {\n                dfs(adjList, visited, dist);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 7;\n        List<Edge>[] adjList = new List[V];\n        buildGraph(adjList);\n        for (int i = 0; i < adjList.length; i++) {\n            System.out.println(i + ": " + adjList[i]);\n        }\n//        Print neighbour information\n//        int len = getNeighbours(adjList[2]);\n//        System.out.println("\\n2 has " + len + " neighbours");\n\n//        BFS\n//        bfs(adjList);\n//        boolean[] visited = new boolean[adjList.length];\n//        for (int i = 0; i < visited.length; i++) {\n//            if (!visited[i]) {\n//                bfsDisjoint(adjList, visited, i);\n//            }\n//        }\n\n//        DFS\n        boolean[] visited = new boolean[adjList.length];\n        dfs(adjList, visited, 0);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '167116d1-28bc-4890-9b25-a5497cbada08',
                  isFolder: false,
                  name: 'AccountsMerge.java',
                  code: 'import java.util.*;\n\npublic class AccountsMerge {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        int n = accounts.size();\n        DisjointSet ds = new DisjointSet(n);\n        HashMap<String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            List<String> account = accounts.get(i);\n            for (int j = 1; j < account.size(); j++) {\n                String email = account.get(j);\n                if (!hm.containsKey(email)) hm.put(email, i);\n                else ds.unionByRank(i, hm.get(email));\n            }\n        }\n        List<List<String>> temp = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            temp.add(new ArrayList<>());\n        }\n        for (Map.Entry m : hm.entrySet()) {\n            int idx = ds.find((int)m.getValue());\n            String email = (String) m.getKey();\n            temp.get(idx).add(email);\n        }\n        List<List<String>> ans = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            List<String> ls = temp.get(i);\n            if (!ls.isEmpty()) {\n                Collections.sort(ls);\n                ls.add(0, accounts.get(i).get(0));\n                ans.add(ls);\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/accounts-merge/',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: 'a5806a72-e491-4f9a-8214-4c0373e64fc2',
                  isFolder: false,
                  name: 'DisjointSet.java',
                  code: '// Link:\nimport java.util.*;\n\npublic class DisjointSet {\n    int[] parent;\n    int[] rank;\n    int[] size;\n\n    DisjointSet(int n) {\n        this.parent = new int[n];\n        this.rank = new int[n];\n        this.size = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    public int find(int num) {\n        if (num == parent[num]) return num;\n        parent[num] = find(parent[num]);\n        return parent[num];\n    }\n\n    public void unionByRank(int u, int v) {\n        int ultParentU = find(u), ultParentV = find(v);\n        if (ultParentU == ultParentV) return;\n        if (rank[ultParentU] > rank[ultParentV]) {\n            parent[ultParentV] = ultParentU;\n        } else if (rank[ultParentU] < rank[ultParentV]) {\n            parent[ultParentU] = ultParentV;\n        } else {\n            parent[ultParentV] = ultParentU;\n            rank[ultParentU]++;\n        }\n    }\n\n    public void unionBySize(int u, int v) {\n        int ultParentU = find(u);\n        int ultParentV = find(v);\n        if (ultParentU == ultParentV) return;\n        if (size[ultParentU] > size[ultParentV]) {\n            parent[ultParentV] = ultParentU;\n            size[ultParentU] += size[ultParentV];\n        } else {\n            parent[ultParentU] = ultParentV;\n            size[ultParentV] += size[ultParentU];\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: 'e39dc1c8-5364-4175-8407-6a4f5d8da23f',
                  isFolder: false,
                  name: 'MakingALargeIsland.java',
                  code: 'import java.util.*;\n\npublic class MakingALargeIsland {\n    public static boolean isInBounds(int r, int c, int n) {\n        return r >= 0 && c >= 0 && r < n && c < n;\n    }\n    public int largestIsland(int[][] grid) {\n        int n = grid.length;\n        DisjointSet ds = new DisjointSet(n * n);\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) continue;\n                int node1 = i * n + j;\n                for (int d = 0; d < 4; d++) {\n                    int r = i + dirs[d][0];\n                    int c = j + dirs[d][1];\n                    if (isInBounds(r, c, n) && grid[r][c] == 1) {\n                        ds.unionBySize(node1, r * n + c);\n                    }\n                }\n            }\n        }\n        int maxSize = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) continue;\n                HashSet<Integer> hs = new HashSet<>();\n                int size = 1;\n                for (int d = 0; d < 4; d++) {\n                    int r = i + dirs[d][0];\n                    int c = j + dirs[d][1];\n                    if (isInBounds(r, c, n) && grid[r][c] == 1) {\n                        int parent = ds.find(r * n + c);\n                        if (!hs.contains(parent)) {\n                            hs.add(parent);\n                            size += ds.size[parent];\n                        }\n                    }\n                }\n                maxSize = Math.max(maxSize, size);\n            }\n        }\n        if (maxSize == 0) {\n            for (int i = 0; i < ds.size.length; i++) {\n                maxSize = Math.max(ds.size[ds.find(i)], maxSize);\n            }\n        }\n        return maxSize;\n    }\n}',
                  link: 'https://leetcode.com/problems/making-a-large-island/',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: 'babfa06f-3a5a-4e94-8ad7-c630783c2abf',
                  isFolder: false,
                  name: 'MostStonesRemoved.java',
                  code: 'import java.util.*;\n\npublic class MostStonesRemoved {\n    public int removeStones(int[][] stones) {\n        int r = 0, c = 0;\n//        Getting max row and max column\n        for (int[] stone : stones) {\n            r = Math.max(r, stone[0]);\n            c = Math.max(c, stone[1]);\n        }\n        DisjointSet ds = new DisjointSet(r+c+2);\n        Set<Integer> hs = new HashSet<>(); // For not visiting the already visited\n        for (int[] stone : stones) {\n            int row = stone[0];\n            int col = stone[1] + r + 1;\n            ds.unionByRank(row, col);\n            hs.add(row);\n            hs.add(col);\n        }\n        int total = 0;\n        for(int i : hs) {\n            if (ds.find(i) == i) total++;\n        }\n        return stones.length - total;\n    }\n}',
                  link: 'https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: '8d2fd261-6abd-481e-b90e-8e4aac39e42f',
                  isFolder: false,
                  name: 'MSTKruskals.java',
                  code: 'import java.util.*;\n\npublic class MSTKruskals {\n    static int spanningTree(int V, int E, int[][] edges){\n        // Code Here.\n        Arrays.sort(edges, (a,b) -> a[2] - b[2]);\n        DisjointSet ds = new DisjointSet(V);\n        int wt = 0;\n        for (int i = 0; i < E; i++) {\n            if (ds.find(edges[i][0]) != ds.find(edges[i][1])) {\n                ds.unionBySize(edges[i][0], edges[i][1]);\n                wt += edges[i][2];\n            }\n        }\n        return wt;\n\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-spanning-tree_631769',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: '6e2fe73b-fe60-468b-8afd-d2ba1aceec8f',
                  isFolder: false,
                  name: 'MSTPrims.java',
                  code: 'import java.util.*;\npublic class MSTPrims {\n    static class Pair {\n        int node, wt;\n        Pair(int n, int w){\n            this.node = n;\n            this.wt = w;\n        }\n    }\n    static class MSTNode {\n        int wt, node, parent;\n        MSTNode (int w, int n, int p) {\n            this.wt = w;\n            this.node = n;\n            this.parent = p;\n        }\n    }\n\n    public static int minimumSpanningTree(ArrayList<ArrayList<Integer>> edges, int n) {\n        //Your code goes here\n        List<List<Pair>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (ArrayList<Integer> edge: edges) {\n            int x = edge.get(0);\n            int y = edge.get(1);\n            int z = edge.get(2);\n            adj.get(x).add(new Pair(y, z));\n            adj.get(y).add(new Pair(x, z));\n        }\n        int sum = 0;\n        boolean[] visited = new boolean[n];\n        PriorityQueue<MSTNode> pq = new PriorityQueue<>((a,b) -> a.wt - b.wt);\n        pq.add(new MSTNode(0, 0, -1));\n        while (!pq.isEmpty()) {\n            MSTNode node = pq.poll();\n            if (visited[node.node]) continue;\n            visited[node.node] = true;\n            if (node.parent != -1) {\n                sum += node.wt;\n            }\n            List<Pair> list = adj.get(node.node);\n            for (Pair p: list) {\n                if (!visited[p.node]) {\n                    pq.add(new MSTNode(p.wt, p.node, node.node));\n                }\n            }\n        }\n        return sum;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-spanning-tree_631769',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: '3a7587e2-8a13-435c-b861-e22dd4d67c28',
                  isFolder: false,
                  name: 'NumberOfIslands2.java',
                  code: 'import java.util.*;\n\npublic class NumberOfIslands2 {\n    public static boolean isInBounds(int r, int c, int n, int m) {\n        return r >= 0 && c >= 0 && r < n && c < m;\n    }\n    public static int[] numberOfIslandII(int n, int m, int[][] queries, int q) {\n        // Write your code here.\n        DisjointSet ds = new DisjointSet(n * m);\n        boolean[][] visited = new boolean[n][m];\n        int count = 0;\n        int[] ans = new int[q];\n        int idx = 0;\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n        for (int[] query : queries) {\n            int row = query[0];\n            int col = query[1];\n            if (!visited[row][col]) {\n                visited[row][col] = true;\n                count++;\n                int node1 = row*m + col;\n                for (int d = 0; d < 4; d++) {\n                    int r = row + dirs[d][0], c = col + dirs[d][1];\n                    if (isInBounds(r,c,n,m) && visited[r][c]) {\n                        int node2 = r*m + c;\n                        if (ds.find(node1) != ds.find(node2)) {\n                            count--;\n                            ds.unionByRank(node1, node2);\n                        }\n                    }\n                }\n            }\n            ans[idx++] = count;\n        }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/largest-island_840701',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: 'b464bf96-5e53-48a6-9a28-b1afc226c955',
                  isFolder: false,
                  name: 'NumberOfOperationsToMakeNetworkConnected.java',
                  code: 'import java.util.*;\n\npublic class NumberOfOperationsToMakeNetworkConnected {\n    public int makeConnected(int n, int[][] connections) {\n        DisjointSet ds = new DisjointSet(n);\n        int extra = 0;\n        for (int[] connection : connections) {\n            int x = ds.find(connection[0]);\n            int y = ds.find(connection[1]);\n            if (x != y)\n                ds.unionByRank(connection[0], connection[1]);\n            else\n                extra++;\n        }\n        int disconnected = 0;\n        for (int i = 0; i < n; i++) {\n            if (ds.parent[i] == i)\n                disconnected++;\n        }\n        int req = disconnected - 1;\n        return extra >= req ? req : -1;\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-operations-to-make-network-connected/',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: '279e1c08-aa0a-46c5-8562-c6ef9ad2b4fd',
                  isFolder: false,
                  name: 'SwimInRisingWater.java',
                  code: 'import java.util.*;\n\npublic class SwimInRisingWater {\n    static class Pair {\n        int row, col, wt;\n        Pair(int r, int c, int w) {\n            this.row = r;\n            this.col = c;\n            this.wt = w;\n        }\n    }\n\n    public boolean isInBounds(int r, int c, int n) {\n        return r >= 0 && c >= 0 && r < n && c < n;\n    }\n    public int swimInWater(int[][] grid) {\n        // Ans = shortest path ka max value\n        int n = grid.length;\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.wt - b.wt);\n        pq.add(new Pair(0,0,grid[0][0]));\n        boolean[][] visited = new boolean[n][n];\n        int max = 0;\n        int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            visited[p.row][p.col] = true;\n            max = Math.max(max, p.wt);\n            if (p.row == n-1 && p.col == n-1) return max;\n            for (int d = 0; d < 4; d++) {\n                int r = p.row + dirs[d][0], c = p.col + dirs[d][1];\n                if (isInBounds(r,c,n) && !visited[r][c]) {\n                    pq.add(new Pair(r,c,grid[r][c]));\n                    visited[r][c] = true;\n                }\n            }\n        }\n        return max;\n    }\n}',
                  link: 'https://leetcode.com/problems/swim-in-rising-water/',
                  notes: '',
                  tags: ['MST and DisjointSet Problems'],
                },
                {
                  id: 'af8e881e-266e-4886-b2c9-94e57c5f5c4b',
                  isFolder: false,
                  name: 'ArticulationPoint.java',
                  code: 'import java.util.*;\n\npublic class ArticulationPoint {\n    int t = 1;\n    public void dfs(ArrayList<ArrayList<Integer>> adj, boolean[] visited, int curr, int[] time, int[] low, boolean[] ap, int parent) {\n        visited[curr] = true;\n        time[curr] = low[curr] = t++;\n        List<Integer> list = adj.get(curr);\n        int child = 0;\n        for (int ele : list) {\n            if (ele == parent) continue;\n            if (!visited[ele]) {\n                dfs(adj, visited, ele, time, low, ap, curr);\n                low[curr] = Math.min(low[ele], low[curr]);\n                if (low[ele] >= time[curr] && parent != -1) {\n                    ap[curr] = true;\n                }\n                child++;\n            } else {\n                low[curr] = Math.min(low[curr], time[ele]);\n            }\n        }\n        if (child > 1 && parent == -1) {\n            ap[curr] = true;\n        }\n    }\n    //Function to return Breadth First Traversal of given graph.\n    public ArrayList<Integer> articulationPoints(int V, ArrayList<ArrayList<Integer>> adj) {\n        // Code here\n        t = 1;\n        int[] time = new int[V];\n        int[] low = new int[V];\n        boolean[] ap = new boolean[V];\n        boolean[] visited = new boolean[V];\n        for (int i = 0; i < V; i++) if (!visited[i]) dfs(adj, visited, i, time, low, ap, -1);\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < V; i++) if (ap[i]) ans.add(i);\n        if (ans.isEmpty()) ans.add(-1);\n        return ans;\n    }\n}',
                  link: 'https://www.geeksforgeeks.org/problems/articulation-point-1/1',
                  notes: '',
                  tags: ['Other Problems'],
                },
                {
                  id: '6f6f437a-7048-4728-a294-b390be2006d1',
                  isFolder: false,
                  name: 'BridgesInAGraph.java',
                  code: 'import java.util.*;\n\npublic class BridgesInAGraph {\n    static int t = 0;\n    public static void dfs(List<List<Integer>> adj, int parent, boolean[] visited, int[] time, int[] low, int curr, List<List<Integer>> ans) {\n        visited[curr] = true;\n        time[curr] = low[curr] = t++;\n        List<Integer> list = adj.get(curr);\n        for (int ele : list) {\n            if (ele == parent) continue;\n            if (!visited[ele]) {\n                dfs(adj, curr, visited, time, low, ele, ans);\n                low[curr] = Math.min(low[curr], low[ele]);\n                if (low[ele] > time[curr]) {\n                    ans.add(new ArrayList<>(Arrays.asList(ele, curr)));\n                }\n            } else {\n                low[curr] = Math.min(low[curr], low[ele]);\n            }\n        }\n    }\n    public static List<List<Integer>> findBridges(int[][] edges, int v, int e) {\n        // Write your code here!\n        List<List<Integer>> adj = new ArrayList<>();\n        t = 0;\n        for (int i = 0; i < v; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int x = edge[0];\n            int y = edge[1];\n            adj.get(x).add(y);\n            adj.get(y).add(x);\n        }\n        boolean[] visited = new boolean[v];\n        List<List<Integer>> ans = new ArrayList<>();\n        int[] time = new int[v];\n        int[] low = new int[v];\n        for (int i = 0; i < v; i++) {\n            if (!visited[i]) {\n                dfs(adj, -1, visited, time, low, i, ans);\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/bridges-in-a-graph_893026',
                  notes: '',
                  tags: ['Other Problems'],
                },
                {
                  id: '54f9951b-5d21-4b2a-a32c-fd51ddd32c0f',
                  isFolder: false,
                  name: 'KosarajusAlgorithm.java',
                  code: 'import java.util.*;\n\npublic class KosarajusAlgorithm {\n    public static void dfs(List<List<Integer>> adj, boolean[] visited, int curr) {\n        visited[curr] = false;\n        List<Integer> list = adj.get(curr);\n        for (int ele : list) {\n            if (visited[ele]) {\n                dfs(adj, visited, ele);\n            }\n        }\n    }\n\n    public static void dfs(List<List<Integer>> adj, boolean[] visited, int curr, Stack<Integer> st) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (int ele : list) {\n            if (!visited[ele]) {\n                dfs(adj, visited, ele, st);\n            }\n        }\n        st.push(curr);\n    }\n\n    //Function to find number of strongly connected components in the graph.\n    public static int kosaraju(int V, List<List<Integer>> adj) {\n        //code here\n        Stack<Integer> st = new Stack<>();\n        boolean[] visited = new boolean[V];\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                dfs(adj, visited, i, st);\n            }\n        }\n        List<List<Integer>> adjR = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            adjR.add(new ArrayList<>());\n        }\n        for (int i = 0; i < V; i++) {\n            List<Integer> list = adj.get(i);\n            for (int ele : list) {\n                adjR.get(ele).add(i);\n            }\n        }\n        int count = 0;\n        while (!st.isEmpty()) {\n            int curr = st.pop();\n            if (visited[curr]) {\n                dfs(adjR, visited, curr);\n                count++;\n            }\n        }\n        return count;\n    }\n    public static int stronglyConnectedComponents(int v, ArrayList<ArrayList<Integer>> edges) {\n        // Write your code here.\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < v; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (ArrayList<Integer> edge : edges) {\n            int x = edge.get(0);\n            int y = edge.get(1);\n            adj.get(x).add(y);\n        }\n        return kosaraju(v, adj);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/count-strongly-connected-components-kosaraju-s-algorithm_1171151',
                  notes: '',
                  tags: ['Other Problems'],
                },
                {
                  id: '6c0f32fb-040a-4864-9128-3875b651f3ab',
                  isFolder: false,
                  name: 'BipartiteGraph.java',
                  code: 'import java.util.*;\n\npublic class BipartiteGraph {\n    public boolean dfs(int[][] graph, int[] visited, int curr, int color) {\n        visited[curr] = color;\n        for (int i = 0; i < graph[curr].length; i++) {\n            if (visited[graph[curr][i]] == 0) {\n                if (!dfs(graph, visited, graph[curr][i], color == 5 ? 10 : 5)) return false;\n            } else if (visited[curr] == visited[graph[curr][i]]) return false;\n        }\n        return true;\n    }\n\n    public boolean bfs(int[][] graph, int[] visited, int curr) {\n        boolean flip = false;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(curr);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            int color = flip ? 5 : 10;\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                visited[node] = color;\n                for (int j = 0; j < graph[node].length; j++) {\n                    if (visited[graph[node][j]] == 0) {\n                        q.add(graph[node][j]);\n                    } else if (visited[node] == visited[graph[node][j]]) {\n                        return false;\n                    }\n                }\n            }\n            flip = !flip;\n        }\n        return true;\n    }\n    public boolean isBipartite(int[][] graph) {\n        int V = graph.length;\n        int[] visited = new int[V];\n        for (int i = 0; i < V; i++) {\n            if (visited[i] == 0) {\n                // if (!bfs(graph, visited, i)) return false;\n                if (!dfs(graph, visited, i, 5)) return false;\n            }\n        }\n        return true;\n    }\n}',
                  link: 'https://leetcode.com/problems/is-graph-bipartite/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '9b9461c0-7425-420a-ae4b-665594d49eb6',
                  isFolder: false,
                  name: 'CycleDetectionDirectedGraphDFS.java',
                  code: 'import java.util.*;\n\npublic class CycleDetectionDirectedGraphDFS {\n    public static boolean dfsCyclic(List<List<Integer>> adj, boolean[] visited, int curr, boolean[] dfsVisited) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        dfsVisited[curr] = true;\n        for (int ele : list) {\n            if (!visited[ele]) {\n                if (dfsCyclic(adj, visited, ele, dfsVisited)) return true;\n            } else if (dfsVisited[ele]) return true;\n        }\n        dfsVisited[curr] = false;\n        return false;\n    }\n    public static Boolean isCyclic(int[][] edges, int v, int e) {\n        // Write your code here.\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < v; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < e; i++) {\n            adj.get(edges[i][0]).add(edges[i][1]);\n        }\n        boolean[] visited = new boolean[v];\n        boolean[] dfsVisited = new boolean[v];\n        for (int i = 0; i < v; i++) {\n            if (!visited[i]) {\n                if (dfsCyclic(adj, visited, i, dfsVisited)) return true;\n            }\n        }\n        return false;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/detect-cycle-in-a-directed-graph-_920545',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '21e19450-54fa-4827-86ca-2e6dd38dcd00',
                  isFolder: false,
                  name: 'CycleDetectionUndirectedGraph.java',
                  code: 'import java.util.*;\npublic class CycleDetectionUndirectedGraph {\n    boolean bfsCyclic(List<List<Integer>> adj, boolean[] visited, int curr) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(curr);\n        int[] parents = new int[visited.length];\n        parents[curr] = -1;\n        while (!q.isEmpty()) {\n            int node = q.poll();\n            visited[node] = true;\n            List<Integer> list = adj.get(node);\n            for (int ele : list) {\n                if (!visited[ele]) {\n                    q.add(ele);\n                    parents[ele] = node;\n                } else if (parents[node] != ele) return true;\n            }\n        }\n        return false;\n    }\n    boolean dfsCyclic(List<List<Integer>> adj, boolean[] visited, int curr, int parent) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (int ele : list) {\n            if (!visited[ele]) {\n                if (dfsCyclic(adj, visited, ele, curr)) return true;\n            }\n            else if (parent != ele) return true;\n        }\n        return false;\n    }\n    boolean detectCycle(int V, List<List<Integer>> adj) {\n        // Write your code here.\n        boolean[] visited = new boolean[V];\n        for (int i = 0; i < V; i++) {\n            if (!visited[i] && dfsCyclic(adj, visited, i, -1)) return true;\n//            if (!visited[i] && bfsCyclic(adj, visited, i)) return true;\n        }\n        return false;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/detect-cycle-in-an-undirected-graph-_758967',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'b247512f-68a6-4bdb-82b9-8dd7e082fde3',
                  isFolder: false,
                  name: 'DistinctIslands.java',
                  code: 'import java.util.*;\npublic class DistinctIslands {\n    static void dfs(int[][] mat, int i, int j, List<List<Integer>> ans, int ogI, int ogJ) {\n        if (i < 0 || j < 0 || i >= mat.length || j >= mat[0].length || mat[i][j] != 1) return;\n        ans.add(new ArrayList<>(Arrays.asList(i - ogI, j - ogJ)));\n        mat[i][j] = 2;\n        dfs(mat, i, j+1, ans, ogI, ogJ);\n        dfs(mat, i+1, j, ans, ogI, ogJ);\n        dfs(mat, i, j-1, ans, ogI, ogJ);\n        dfs(mat, i-1, j, ans, ogI, ogJ);\n    }\n    public static int distinctIsland(int [][] mat, int m, int n) {\n        //write your code here\n        Set<List<List<Integer>>> hs = new HashSet<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    List<List<Integer>> ans = new ArrayList<>();\n                    dfs(mat, i, j, ans, i, j);\n                    hs.add(ans);\n                }\n            }\n        }\n        return hs.size();\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/distinct-islands_630460',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'b2f73ffb-848c-4ee6-82a3-d1c81cc267a0',
                  isFolder: false,
                  name: 'FloodFill.java',
                  code: 'import java.util.*;\npublic class FloodFill {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n    static boolean checkInBounds (int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n        int m = image.length;\n        int n = image[0].length;\n        int startColor = image[sr][sc];\n        int[][] directions = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n        boolean[][] visited = new boolean[m][n];\n        Queue<Pair> q = new LinkedList<>();\n        q.add(new Pair(sr, sc));\n        image[sr][sc] = color;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                visited[p.row][p.col] = true;\n                for (int[] direction : directions) {\n                    int r = p.row + direction[0];\n                    int c = p.col + direction[1];\n                    if (checkInBounds(r, c, m, n) && !visited[r][c] && image[r][c] == startColor) {\n                        image[r][c] = color;\n                        q.add(new Pair(r, c));\n                    }\n                }\n            }\n        }\n        return image;\n    }\n}',
                  link: 'https://leetcode.com/problems/flood-fill/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '2711f366-f2c6-447c-bbb8-2840efbb956d',
                  isFolder: false,
                  name: 'Matrix01.java',
                  code: 'import java.util.*;\npublic class Matrix01 {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n    public boolean isInBound(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int[][] updateMatrix(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[][] ans = new int[m][n]; // for good practice\n        Queue<Pair> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    ans[i][j] = -1;\n                } else {\n                    q.add(new Pair(i,j));\n                }\n            }\n        }\n        int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                for (int j = 0; j < 4; j++) {\n                    int r = p.row + dirs[j][0];\n                    int c = p.col + dirs[j][1];\n                    if (isInBound(r,c,m,n) && ans[r][c] == -1) {\n                        ans[r][c] = ans[p.row][p.col] + 1;\n                        q.add(new Pair(r,c));\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/01-matrix/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'e77be2fe-e39e-4f59-954a-e3132e8d26b9',
                  isFolder: false,
                  name: 'NumberOfEnclaves.java',
                  code: 'public class NumberOfEnclaves {\n    void dfs(int[][] grid, int i, int j) {\n        if (i < 0  || i >= grid.length  || j < 0  || j >= grid[0].length || grid[i][j] != 1) return;\n        grid[i][j] = 2;\n        dfs(grid, i, j + 1);\n        dfs(grid, i + 1, j);\n        dfs(grid, i, j - 1);\n        dfs(grid, i - 1, j);\n    }\n    public int numEnclaves(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 1) dfs(grid, i, 0);\n            if (grid[i][n-1] == 1) dfs(grid, i, n - 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[0][i] == 1) dfs(grid, 0, i);\n            if (grid[m - 1][i] == 1) dfs(grid, m-1, i);\n        }\n        int count = 0;\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                if(grid[i][j] == 1) count++;\n\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-enclaves/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '665e64b0-1f87-4152-ab77-33d353828448',
                  isFolder: false,
                  name: 'NumberOfProvinces.java',
                  code: 'public class NumberOfProvinces {\n    public static void dfs(int[][] isConnected, boolean[] visited, int curr) {\n        visited[curr] = true;\n        for (int i = 0; i < isConnected[curr].length; i++) {\n            if (isConnected[curr][i] == 1) {\n                if (!visited[i])\n                    dfs(isConnected, visited, i);\n            }\n        }\n    }\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                count++;\n                dfs(isConnected, visited, i);\n            }\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-provinces/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '726be035-1767-4ef2-88a2-565c2a96fdbe',
                  isFolder: false,
                  name: 'RottingOranges.java',
                  code: 'import java.util.*;\npublic class RottingOranges {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            row = r;\n            col = c;\n        }\n    }\n    public boolean isInBound(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int orangesRotting(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<Pair> q = new LinkedList<>();\n        int fresh = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) q.add(new Pair(i, j));\n                else if (grid[i][j] == 1) fresh++;\n            }\n        }\n        if (fresh == 0) return 0;\n        // if (fresh > 0 && q.isEmpty()) return -1;\n        boolean[][] visited = new boolean[m][n];\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                visited[p.row][p.col] = true;\n                for (int d = 0; d < 4; d++) {\n                    int r = directions[d][0] + p.row;\n                    int c = directions[d][1] + p.col;\n                    if (isInBound(r,c,m,n) && !visited[r][c] && grid[r][c] == 1) {\n                        grid[r][c] = 2;\n                        q.add(new Pair(r, c));\n                        fresh--;\n                    }\n                }\n            }\n            if (!q.isEmpty()) count++;\n        }\n        return fresh == 0 ? count : -1;\n    }\n}',
                  link: 'https://leetcode.com/problems/rotting-oranges/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'e98dc216-76aa-4965-9675-5f0f62ea6770',
                  isFolder: false,
                  name: 'SurroundedRegions.java',
                  code: "public class SurroundedRegions {\n    void dfs(char[][] board, int i, int j) {\n        if (i < 0\n                || i >= board.length\n                || j < 0\n                || j >= board[0].length\n                || board[i][j] != 'O') return;\n        board[i][j] = 'A';\n        dfs(board, i, j + 1);\n        dfs(board, i + 1, j);\n        dfs(board, i, j - 1);\n        dfs(board, i - 1, j);\n    }\n    public void solve(char[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n        for (int i = 0; i < n; i++) {\n            if (board[0][i] == 'O') dfs(board, 0, i);\n            if (board[m - 1][i] == 'O') dfs(board, m-1, i);\n        }\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') dfs(board, i, 0);\n            if (board[i][n-1] == 'O') dfs(board, i, n - 1);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(board[i][j] == 'O')\n                    board[i][j] = 'X';\n                else if(board[i][j] == 'A')\n                    board[i][j] = 'O';\n            }\n        }\n    }\n}",
                  link: 'https://leetcode.com/problems/surrounded-regions/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '90e7a378-20ec-4c41-a323-409ef9fb4aea',
                  isFolder: false,
                  name: 'WordLadder1.java',
                  code: "import java.util.*;\n\npublic class WordLadder1 {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> hs = new HashSet<>(wordList);\n        Queue<String> q = new LinkedList<>();\n        q.add(beginWord);\n        hs.remove(beginWord);\n        int count = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                String s = q.poll();\n                if (s.equals(endWord)) return count;\n                for (int l = 0; l < s.length(); l++) {\n                    char old = s.charAt(l);\n                    char[] replaceArray = s.toCharArray();\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\n                        replaceArray[l] = ch;\n                        String str = new String(replaceArray);\n                        if (hs.contains(str)) {\n                            q.add(str);\n                            hs.remove(str);\n                        }\n                    }\n                    replaceArray[l] = old;\n                }\n            }\n            count++;\n        }\n        return 0;\n    }\n}",
                  link: 'https://leetcode.com/problems/word-ladder/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'e3bddbce-dcc5-4a50-a46e-97d64b361d86',
                  isFolder: false,
                  name: 'WordLadder2.java',
                  code: "import java.util.*;\n\npublic class WordLadder2 {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> ans = new ArrayList<>();\n        List<String> removeList = new ArrayList<>();\n        HashSet<String> hs = new HashSet<>(wordList);\n        Queue<List<String>> q = new LinkedList<>();\n        q.add(new ArrayList<>(Collections.singletonList(beginWord)));\n        removeList.add(beginWord);\n        while (!q.isEmpty() && ans.isEmpty()) {\n            int size = q.size();\n            removeList.forEach(hs::remove);\n            for (int i = 0; i < size; i++) {\n                List<String> temp = q.poll();\n                String last = temp.getLast();\n                for (int s = 0; s < last.length(); s++) {\n                    char[] arr = last.toCharArray();\n                    char old = arr[s];\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\n                        arr[s] = ch;\n                        String str = new String(arr);\n                        if (hs.contains(str)) {\n                            List<String> newList = new ArrayList<>(temp);\n                            newList.add(str);\n                            if (str.equals(endWord)) ans.add(newList);\n                            else q.add(newList);\n                            removeList.add(str);\n                        }\n                    }\n                    arr[s] = old;\n                }\n            }\n        }\n        return ans;\n    }\n}",
                  link: 'https://leetcode.com/problems/word-ladder-ii/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'f1996756-6324-4977-97e5-6f86f63bc7f9',
                  isFolder: false,
                  name: 'BellmanFordAlgorithm.java',
                  code: 'import java.util.*;\n\npublic class BellmanFordAlgorithm {\n    static int[] bellman_ford(int V, ArrayList<ArrayList<Integer>> edges, int S) {\n        // Write your code here\n        int[] distance = new int[V];\n        Arrays.fill(distance, (int) 1e8);\n        distance[S] = 0;\n        for (int j = 0; j < V - 1; j++) {\n            for (ArrayList<Integer> list : edges) {\n                int x = list.get(0);\n                int y = list.get(1);\n                int z = list.get(2);\n                if (distance[x] != 1e8 && distance[x] + z < distance[y]) {\n                    distance[y] = distance[x] + z;\n                }\n            }\n        }\n        for (ArrayList<Integer> list : edges) {\n            int x = list.get(0);\n            int y = list.get(1);\n            int z = list.get(2);\n            if (distance[x] != 1e8 && distance[x] + z < distance[y]) {\n                return new int[]{-1};\n            }\n        }\n\n        return distance;\n    }\n}',
                  link: 'https://www.geeksforgeeks.org/problems/distance-from-the-source-bellman-ford-algorithm/1',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'beab79b5-cf9c-40c3-b309-f7a4ba7ace84',
                  isFolder: false,
                  name: 'CheapestFlightsWithKStops.java',
                  code: 'import java.util.*;\n\npublic class CheapestFlightsWithKStops {\n    static class Pair {\n        int node, cost;\n\n        Pair(int n, int c) {\n            this.node = n;\n            this.cost = c;\n        }\n    }\n\n    static class Triplet {\n        int stops, node, cost;\n\n        Triplet(int s, int n, int c) {\n            this.stops = s;\n            this.node = n;\n            this.cost = c;\n        }\n    }\n\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        List<List<Pair>> adj = new ArrayList<>();\n        int[] distance = new int[n];\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n            distance[i] = Integer.MAX_VALUE;\n        }\n        for (int[] flight : flights) {\n            int x = flight[0];\n            int y = flight[1];\n            int z = flight[2];\n            adj.get(x).add(new Pair(y, z));\n        }\n        distance[src] = 0;\n        PriorityQueue<Triplet> pq = new PriorityQueue<>((a,b) -> a.stops - b.stops);\n        pq.add(new Triplet(0,src,0));\n        while (!pq.isEmpty()) {\n            Triplet t = pq.poll();\n            List<Pair> list = adj.get(t.node);\n            if (t.stops > k) continue;\n            for (Pair p : list) {\n                int cost = p.cost + t.cost;\n                if (cost < distance[p.node]) {\n                    distance[p.node] = cost;\n                    pq.add(new Triplet(t.stops+1, p.node, cost));\n                }\n            }\n        }\n        return distance[dst] == Integer.MAX_VALUE ? -1 : distance[dst];\n    }\n}',
                  link: 'https://leetcode.com/problems/cheapest-flights-within-k-stops/',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: '318b4289-2407-43cf-bcb6-4516069891b2',
                  isFolder: false,
                  name: 'DijkstrasAlgorithm.java',
                  code: 'import java.util.*;\n\npublic class DijkstrasAlgorithm {\n    static class Pair {\n        int node, weight;\n        Pair(int n, int w) {\n            this.node = n;\n            this.weight = w;\n        }\n    }\n    public static List<Integer> dijkstra(int[][] edge,int vertices, int edges,int source){\n        // Write your code here.\n        List<List<Pair>> adj = new ArrayList<>();\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < vertices; i++) {\n            adj.add(new ArrayList<>());\n            ans.add(Integer.MAX_VALUE);\n        }\n        for (int i = 0; i < edges; i++) {\n            int x = edge[i][0];\n            int y = edge[i][1];\n            int z = edge[i][2];\n            adj.get(x).add(new Pair(y, z));\n            adj.get(y).add(new Pair(x, z));\n        }\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.node == b.node ? a.weight - b.weight : a.node - b.node);\n        pq.add(new Pair(source, 0));\n        ans.set(source, 0);\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            List<Pair> list = adj.get(p.node);\n            for (Pair ele : list) {\n                int wt = ele.weight+p.weight;\n                if (wt < ans.get(ele.node)) {\n                    ans.set(ele.node, wt);\n                    pq.add(new Pair(ele.node, wt));\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: "https://www.codingninjas.com/studio/problems/dijkstra's-shortest-path_985358",
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'd299e88a-840e-436a-8678-c2b680a39cd3',
                  isFolder: false,
                  name: 'FindCityWithSmallestNumberOfNeighborsAtThresholdDistance.java',
                  code: 'import java.util.*;\n\npublic class FindCityWithSmallestNumberOfNeighborsAtThresholdDistance {\n    static class Pair {\n        int node, distance;\n        Pair (int n, int d) {\n            this.node = n;\n            this.distance = d;\n        }\n    }\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        int[][] matrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j) {\n                    matrix[i][j] = (int)1e9;\n                }\n            }\n        }\n        for (int[] edge : edges) {\n            matrix[edge[0]][edge[1]] = edge[2];\n            matrix[edge[1]][edge[0]] = edge[2];\n        }\n        for (int via = 0; via < n; via++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    matrix[i][j] = Math.min(matrix[i][j], matrix[i][via] + matrix[via][j]);\n                }\n            }\n        }\n        int city = -1;\n        int maxCount = n+1;\n        for (int i = 0; i < n; i++) {\n            int count = 0;\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] <= distanceThreshold) {\n                    count++;\n                }\n            }\n            if (count <= maxCount) {\n                maxCount = count;\n                city = i;\n            }\n        }\n        return city;\n\n    }\n}',
                  link: 'https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: '91bf3248-f9c8-4e12-ab77-438cc87142c0',
                  isFolder: false,
                  name: 'FloydWarshallAlgorithm.java',
                  code: 'import java.util.*;\n\npublic class FloydWarshallAlgorithm {\n    static int floydWarshall(int n, int m, int src, int dest, ArrayList<ArrayList<Integer>> edges) {\n        // Write your code here.\n        int[][] matrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j) {\n                    matrix[i][j] = (int)1e9;\n                }\n            }\n        }\n        for (ArrayList<Integer> edge : edges) {\n            matrix[edge.get(0)-1][edge.get(1)-1] = edge.get(2);\n        }\n        for (int via = 0; via < n; via++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (matrix[i][via] + matrix[via][j] < matrix[i][j]) {\n                        matrix[i][j] = matrix[i][via] + matrix[via][j];\n                    }\n                }\n            }\n        }\n        return matrix[src-1][dest-1];\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/floyd-warshall_2041979',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'da01702f-4b93-4781-8bb9-fbabc6f23c52',
                  isFolder: false,
                  name: 'MinimumOperationsMultiplicationToReachEnd.java',
                  code: 'import java.util.*;\n\npublic class MinimumOperationsMultiplicationToReachEnd {\n    static class Pair {\n        int val, steps;\n        Pair(int v, int s) {\n            this.val = v;\n            this.steps = s;\n        }\n    }\n    public static int minimumOperations(int n, int start, int end, int []arr) {\n        // Write your code here\n        int mod = 1000;\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.steps - b.steps);\n        HashSet<Integer> hs = new HashSet<>();\n        pq.add(new Pair(start, 0));\n        hs.add(start);\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            if (p.val == end) return p.steps;\n            for (int num : arr) {\n                int val = (p.val*num)%mod;\n                if (!hs.contains(val)) {\n                    pq.add(new Pair(val, p.steps+1));\n                    hs.add(val);\n                }\n            }\n        }\n        return -1;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-operations_8360665',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: '3a906cef-ae81-467c-a0a3-55c969352628',
                  isFolder: false,
                  name: 'NetworkDelayTime.java',
                  code: 'import java.util.*;\n\npublic class NetworkDelayTime {\n    static class Pair {\n        int node, cost;\n        Pair(int n, int c) {\n            this.node = n;\n            this.cost = c;\n        }\n    }\n\n    public int networkDelayTime(int[][] times, int n, int k) {\n        List<List<Pair>> adj = new ArrayList<>();\n        int[] dist = new int[n];\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n            dist[i] = Integer.MAX_VALUE;\n        }\n        for (int[] time : times) {\n            int x = time[0] - 1;\n            int y = time[1] - 1;\n            int z = time[2];\n            adj.get(x).add(new Pair(y, z));\n        }\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.cost - b.cost);\n        pq.add(new Pair(k - 1, 0));\n        dist[k - 1] = 0;\n        int sum = 0;\n        while (!pq.isEmpty()) {\n            Pair node = pq.poll();\n            List<Pair> list = adj.get(node.node);\n            for (Pair p : list) {\n                int cost = p.cost + node.cost;\n                if (cost < dist[p.node]) {\n                    dist[p.node] = cost;\n                    pq.add(new Pair(p.node, cost));\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (dist[i] == Integer.MAX_VALUE) return -1;\n            sum = Math.max(sum, dist[i]);\n        }\n        return sum;\n    }\n}',
                  link: 'https://leetcode.com/problems/network-delay-time/',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'f5185936-71ef-40cd-b877-14fecae10211',
                  isFolder: false,
                  name: 'NumberOfWaysToArriveAtDestination.java',
                  code: 'import java.util.*;\n\npublic class NumberOfWaysToArriveAtDestination {\n    static class Pair {\n        long node, distance;\n\n        Pair(long n, long d) {\n            this.node = n;\n            this.distance = d;\n        }\n    }\n\n    public int countPaths(int n, int[][] roads) {\n        List<List<Pair>> adj = new ArrayList<>();\n        long[] ways = new long[n];\n        long[] distance = new long[n];\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n            distance[i] = Long.MAX_VALUE;\n        }\n        for (int[] road : roads) {\n            int x = road[0];\n            int y = road[1];\n            int z = road[2];\n            adj.get(x).add(new Pair(y, z));\n            adj.get(y).add(new Pair(x, z));\n        }\n        int mod = (int) (1e9 + 7);\n        ways[0] = 1;\n        distance[0] = 0;\n        PriorityQueue<Pair> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a.distance));\n        pq.add(new Pair(0, 0));\n        while (!pq.isEmpty()) {\n            Pair node = pq.poll();\n            List<Pair> list = adj.get((int) node.node);\n            for (Pair p : list) {\n                long dist = p.distance + node.distance;\n                if (dist < distance[(int) p.node]) {\n                    distance[(int) p.node] = dist;\n                    ways[(int) p.node] = ways[(int) node.node] % mod;\n                    pq.add(new Pair(p.node, dist));\n                } else if (dist == distance[(int) p.node]) {\n                    ways[(int) p.node] += ways[(int) node.node] % mod;\n                }\n            }\n        }\n        return (int) (ways[n - 1] % mod);\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'e2f5463c-2c2d-40ff-9054-05574bba7e3d',
                  isFolder: false,
                  name: 'PathWithMinimumEffort.java',
                  code: 'import java.util.*;\n\npublic class PathWithMinimumEffort {\n    static class Pair {\n        int row, col, diff;\n\n        Pair(int d, int r, int c) {\n            this.diff = d;\n            this.row = r;\n            this.col = c;\n        }\n    }\n\n    boolean isInBounds(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n\n    public int minimumEffortPath(int[][] heights) {\n        int m = heights.length, n = heights[0].length;\n        int[][] minEffort = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(minEffort[i], Integer.MAX_VALUE);\n        }\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.diff - b.diff);\n        pq.add(new Pair(0, 0, 0));\n        minEffort[0][0] = 0;\n        int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            if (p.row == m - 1 && p.col == n - 1) return p.diff;\n            for (int[] dir : dirs) {\n                int r = p.row + dir[0];\n                int c = p.col + dir[1];\n                if (isInBounds(r, c, m, n)) {\n                    int diff = Math.max(p.diff, Math.abs(heights[p.row][p.col] - heights[r][c]));\n                    if (diff < minEffort[r][c]) {\n                        minEffort[r][c] = diff;\n                        pq.add(new Pair(diff, r, c));\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}',
                  link: 'https://leetcode.com/problems/path-with-minimum-effort/',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'd183bf58-3d15-4f6c-8ad8-9d774a12580c',
                  isFolder: false,
                  name: 'ShortestPathBinaryMatrix.java',
                  code: 'import java.util.*;\n\npublic class ShortestPathBinaryMatrix {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n    boolean isInBounds(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int shortestPathBinaryMatrix(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        if (grid[0][0] == 1 || grid[m-1][n-1] == 1) return -1;\n        int count = 1;\n        Queue<Pair> q = new LinkedList<>();\n        int[][] dirs = {{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1}};\n        q.add(new Pair(0, 0));\n        grid[0][0] = 2;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                if (p.row == m-1 && p.col == n-1) return count;\n                for (int d = 0; d < 8; d++) {\n                    int r = p.row + dirs[d][0];\n                    int c = p.col + dirs[d][1];\n                    if (isInBounds(r,c,m,n) && grid[r][c] == 0) {\n                        q.add(new Pair(r,c));\n                        grid[r][c] = 2;\n                    }\n                }\n            }\n            count++;\n        }\n        return grid[m-1][n-1] != 2 ? -1 : count;\n    }\n}',
                  link: 'https://leetcode.com/problems/shortest-path-in-binary-matrix/',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: 'b4f392c8-63c5-49f4-9b14-6ac578962651',
                  isFolder: false,
                  name: 'ShortestPathDAG.java',
                  code: "import java.util.*;\n\npublic class ShortestPathDAG {\n    public static class Pair {\n        int value, weight;\n\n        Pair(int v, int w) {\n            this.value = v;\n            this.weight = w;\n        }\n    }\n\n    public static void dfs(List<List<Pair>> adj, boolean[] visited, Stack<Integer> st, int curr) {\n        visited[curr] = true;\n        List<Pair> list = adj.get(curr);\n        for (Pair ele : list) {\n            if (!visited[ele.value]) {\n                dfs(adj, visited, st, ele.value);\n            }\n        }\n        st.push(curr);\n    }\n\n    public static Stack<Integer> toposort(List<List<Pair>> adj, int n) {\n        Stack<Integer> st = new Stack<>();\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(adj, visited, st, i);\n            }\n        }\n        return st;\n    }\n\n    public static int[] shortestPathInDAG(int n, int m, int[][] edges) {\n        // Write your code here\n        // EDGES to Adjacency List O(E+V) for this, But Dijkstra's algo can also be used (O(E + VLogV))\n        List<List<Pair>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            adj.get(edge[0]).add(new Pair(edge[1], edge[2]));\n        }\n\n        Stack<Integer> st = toposort(adj, adj.size());\n        int[] ans = new int[n];\n        Arrays.fill(ans, 167890);\n        ans[0] = 0;\n        while (!st.isEmpty()) {\n            int node = st.pop();\n            List<Pair> list = adj.get(node);\n            for (Pair ele : list) {\n                int val = ans[node] + ele.weight;\n                if (val < ans[ele.value]) {\n                    ans[ele.value] = val;\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (ans[i] == 167890) {\n                ans[i] = -1;\n            }\n        }\n        return ans;\n    }\n}",
                  link: 'https://www.codingninjas.com/codestudio/problems/shortest-path-in-dag_8381897',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: '7b69f4b5-c006-4909-9ad4-c5fd9a0b93e8',
                  isFolder: false,
                  name: 'SingleSourceShortestPathUndirectedGraph.java',
                  code: 'import java.util.*;\npublic class SingleSourceShortestPathUndirectedGraph {\n    public static int[] shortestPath(int n, int [][]edges, int src) {\n        // Write your code here.\n        List<List<Integer>> adj = new ArrayList<>();\n        int[] dist = new int[n];\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n            dist[i] = -1;\n        }\n        for (int[] edge : edges) {\n            adj.get(edge[0]).add(edge[1]);\n            adj.get(edge[1]).add(edge[0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        q.add(src);\n        dist[src] = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                List<Integer> list = adj.get(node);\n                for (int ele : list) {\n                    if (dist[ele] == -1) {\n                        dist[ele] = dist[node] + 1;\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/single-source-shortest-path_8416371',
                  notes: '',
                  tags: ['Shortest Path Algorithms and Problems'],
                },
                {
                  id: '0318fcd0-2c4f-48db-b60d-87dbde5b283f',
                  isFolder: false,
                  name: 'AlienDictionary.java',
                  code: 'import java.util.*;\n\npublic class AlienDictionary {\n    public static void bfs(List<List<Integer>> adj, char[] strs, int[] indegree) {\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                strs[count++] = (char) (node + \'a\');\n                List<Integer> list = adj.get(node);\n                for (int ele : list) {\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n    }\n    public static void topologicalSort(List<List<Integer>> adj, int v, char[] strs) {\n        // Write your code here!\n        int[] indegree = new int[v];\n        for (int i = 0; i < v; i++) {\n            List<Integer> list = adj.get(i);\n            for (Integer node : list) {\n                indegree[node]++;\n            }\n        }\n//        List<Integer> ans = new ArrayList<>();\n        bfs(adj, strs, indegree);\n    }\n    public static String getAlienLanguage(String []dictionary, int k) {\n        // Write your code here.\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < dictionary.length - 1; i++) {\n            String str1 = dictionary[i];\n            String str2 = dictionary[i + 1];\n            int len = Math.min(str1.length(), str2.length());\n            for (int j = 0; j < len; j++) {\n                char s1 = str1.charAt(j);\n                char s2 = str2.charAt(j);\n                if (s1 != s2) {\n                    adj.get(s1 - \'a\').add(s2 - \'a\');\n                    break;\n                }\n            }\n        }\n        System.out.println(adj);\n        char[] strs = new char[k];\n        topologicalSort(adj, k, strs);\n        return new String(strs);\n    }\n\n    public static void main(String[] args) {\n        String[] arr = {"caa", "aaa", "aab"};\n        String ans = getAlienLanguage(arr, 3);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/alien-dictionary_630423',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: '08e0e91c-0815-40f3-8b2d-c401da38bdb3',
                  isFolder: false,
                  name: 'CourseSchedule.java',
                  code: 'import java.util.*;\n\npublic class CourseSchedule {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] prerequisite : prerequisites) {\n            indegree[prerequisite[0]]++;\n            adj.get(prerequisite[1]).add(prerequisite[0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                count++;\n                for (int j = 0; j < adj.get(node).size(); j++) {\n                    int ele = adj.get(node).get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count == numCourses;\n    }\n}',
                  link: 'https://leetcode.com/problems/course-schedule/',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: '245c3714-023f-4860-ad24-78ec7774b189',
                  isFolder: false,
                  name: 'CourseSchedule2.java',
                  code: 'import java.util.*;\n\npublic class CourseSchedule2 {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] prerequisite : prerequisites) {\n            indegree[prerequisite[0]]++;\n            adj.get(prerequisite[1]).add(prerequisite[0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int[] ans = new int[numCourses];\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans[count++] = node;\n                for (int j = 0; j < adj.get(node).size(); j++) {\n                    int ele = adj.get(node).get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count == numCourses ? ans : new int[]{};\n    }\n}',
                  link: 'https://leetcode.com/problems/course-schedule-ii/',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: 'd585e45a-963f-431d-b88d-5e72f174408f',
                  isFolder: false,
                  name: 'CycleInDetectionDirectedGraphBFS.java',
                  code: 'import java.util.*;\n\npublic class CycleInDetectionDirectedGraphBFS {\n    public static boolean detectCycleInDirectedGraph(int n, ArrayList<ArrayList<Integer>> edges) {\n        // Write your code here.\n        int e = edges.size();\n        int[] indegree = new int[n];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)  {\n            adj.add(new ArrayList<>());\n        }\n        for(int i = 0; i < e; i++){\n            List<Integer> list = edges.get(i);\n            int x = list.get(0) - 1;\n            int y = list.get(1) - 1;\n            adj.get(x).add(y);\n            indegree[y]++;\n        }\n        Queue<Integer> q = new LinkedList<>();\n        int count = 0;\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                count++;\n                List<Integer> list = adj.get(node);\n                for (int j = 0; j < list.size(); j++) {\n                    int ele = list.get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count != n;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/detect-cycle-in-a-directed-graph_1062626',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: '0aeb4c25-e0aa-4150-9809-935f271bf900',
                  isFolder: false,
                  name: 'FindEventualSafeStates.java',
                  code: 'import java.util.*;\n\npublic class FindEventualSafeStates {\n    public boolean dfs(int[][] graph, boolean[] visited, int[] dfsVisited, int curr) {\n        visited[curr] = true;\n        dfsVisited[curr] = 1;\n        for (int i = 0; i < graph[curr].length; i++) {\n            if (!visited[graph[curr][i]]) {\n                if (!dfs(graph, visited, dfsVisited, graph[curr][i])) return false;\n            } else if (dfsVisited[graph[curr][i]] == 1) return false;\n        }\n        dfsVisited[curr] = 0;\n        return true;\n    }\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        // DFS\n        // boolean[] visited = new boolean[graph.length];\n        // int[] dfsVisited = new int[graph.length];\n        // for (int i = 0; i < graph.length; i++) {\n        //     if (!visited[i]) {\n        //         dfs(graph, visited, dfsVisited, i);\n        //     }\n        // }\n        // List<Integer> ans = new ArrayList<>();\n        // for (int i = 0; i < graph.length; i++) {\n        //     if (dfsVisited[i] == 0) {\n        //         ans.add(i);\n        //     }\n        // }\n        // return ans;\n\n\n        // BFS\n        List<List<Integer>> adjRev = new ArrayList<>();\n        int V = graph.length;\n        int[] indegree = new int[V];\n        for (int i = 0; i < V; i++) {\n            adjRev.add(new ArrayList<>());\n        }\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < graph[i].length; j++) {\n                indegree[i]++;\n                adjRev.get(graph[i][j]).add(i);\n            }\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < V; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans.add(node);\n                List<Integer> list = adjRev.get(node);\n                for (int ele : list) {\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        Collections.sort(ans);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/find-eventual-safe-states/',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: 'df5650f5-c3f4-4d95-ae4e-664f52736c33',
                  isFolder: false,
                  name: 'TopologicalSort.java',
                  code: 'import java.util.*;\n\npublic class TopologicalSort {\n    public static void bfs(List<List<Integer>> adj, List<Integer> ans, int[] indegree) {\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans.add(node);\n                List<Integer> list = adj.get(node);\n                for (int ele : list) {\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void dfs(List<List<Integer>> adj, boolean[] visited, int curr, Stack<Integer> st) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (Integer it : adj.get(curr)) {\n            if (!visited[it]) {\n                dfs(adj, visited, it, st);\n            }\n        }\n        st.push(curr);\n    }\n\n    public static List<Integer> topologicalSort(int[][] edges, int e, int v) {\n        // Write your code here!\n        int[] indegree = new int[v];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < v; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < e; i++) {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            adj.get(x).add(y);\n            indegree[edges[i][1]]++;\n        }\n//        Stack<Integer> st = new Stack<>();\n//        boolean[] visited = new boolean[v];\n        List<Integer> ans = new ArrayList<>();\n        bfs(adj, ans, indegree);\n//        for (int i = 0; i < v; i++) {\n//            if (!visited[i]) {\n//                dfs(adj, visited, i, st);\n//            }\n//        }\n//         while (!st.isEmpty()) {\n//             ans.add(st.pop());\n//         }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/topological-sorting_973003',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
              ],
            },
            {
              id: 'a6a730ac-a74c-46b0-a236-4dbbb5760d4f',
              isFolder: true,
              name: 'Greedy Algorithms',
              content: [
                {
                  id: '6bf4c47e-d29f-4e2d-a7d3-61fbda9fd68b',
                  isFolder: false,
                  name: 'AssignCookies.java',
                  code: 'import java.util.*;\npublic class AssignCookies {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0, j = 0;\n        int count = 0;\n        while (j < s.length && i < g.length) {\n            if (s[j] >= g[i]) {\n                count++;\n                i++;\n            }\n            j++;\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/assign-cookies/',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: 'b890bdbf-ceb3-4688-9377-b8ab5fe26418',
                  isFolder: false,
                  name: 'FractionalKnapsack.java',
                  code: 'import java.util.*;\npublic class FractionalKnapsack {\n    static class Item {\n        int value, weight;\n        Item(int x, int y) {\n            this.value = x;\n            this.weight = y;\n        }\n    }\n    static class Pair {\n        Item item;\n        double ratio;\n        Pair(Item a, double r) {\n            this.item = a;\n            this.ratio = r;\n        }\n    }\n    //Function to get the maximum total value in the knapsack.\n    static double fractionalKnapsack(int W, Item[] arr, int n) {\n        // Your code here\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Double.compare(b.ratio, a.ratio));\n        for (int i = 0; i < n; i++)\n            pq.add(new Pair(arr[i], (double) arr[i].value / arr[i].weight));\n        double result = 0;\n        while (W > 0 && !pq.isEmpty()) {\n            Pair p = pq.poll();\n            if (p.item.weight <= W) {\n                W -= p.item.weight;\n                result += p.item.value;\n            } else {\n                result += p.ratio * W;\n                break;\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Item[] items = new Item[3];\n        items[0] = new Item(60,10);\n        items[1] = new Item(100, 20);\n        items[2] = new Item(120, 30);\n        double ans = fractionalKnapsack(50, items, 3);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://practice.geeksforgeeks.org/problems/fractional-knapsack-1587115620/1',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: '0ed588e8-caf0-48b2-9e77-c6ab13a4bd02',
                  isFolder: false,
                  name: 'LemonadeChange.java',
                  code: 'public class LemonadeChange {\n    public boolean lemonadeChange(int[] bills) {\n        int ten = 0, five = 0;\n        for (int bill : bills) {\n            if (bill == 5) five++;\n            else if (bill == 10) {\n                ten++;\n                if (five >= 1) five--;\n                else return false;\n            } else if (bill == 20) {\n                if (ten >= 1 && five >= 1) {\n                    ten--;\n                    five--;\n                }\n                else if (five >= 3)\n                    five -= 3;\n                else return false;\n            }\n        }\n        return true;\n    }\n}',
                  link: 'https://leetcode.com/problems/lemonade-change/',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: 'efc36506-7e39-4208-9cb7-a81b563c4718',
                  isFolder: false,
                  name: 'MinNumberOfCoins.java',
                  code: 'import java.util.*;\npublic class MinNumberOfCoins {\n    public static List<Integer> MinimumCoins(int V) {\n        // Write your code here.\n        int[] arr = { 1000, 500, 100, 50, 20, 10, 5, 2, 1 };\n        List<Integer> result = new ArrayList<>();\n        int i = 0;\n        while (V > 0 && i < arr.length) {\n            if (arr[i] <= V) {\n                result.add(arr[i]);\n                V -= arr[i];\n                continue;\n            }\n            i++;\n        }\n        return result;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-minimum-number-of-coins_975277',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: 'e474bd89-7528-4aa4-9fea-8c92db636603',
                  isFolder: false,
                  name: 'ValidParenthesisString.java',
                  code: "public class ValidParenthesisString {\n    public boolean checkValidString(String s) {\n        int leftMin = 0, leftMax = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') {\n                leftMin++;\n                leftMax++;\n            } else if (ch == ')') {\n                leftMin--;\n                leftMax--;\n            } else {\n                leftMin--;\n                leftMax++;\n            }\n            if (leftMax < 0) return false;\n            if (leftMin < 0) leftMin = 0;\n        }\n        return leftMin == 0;\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-parenthesis-string/',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: '7e84c85a-7c6c-4576-84b9-b65c7afe50ee',
                  isFolder: false,
                  name: 'Candy.java',
                  code: 'import java.util.*;\n\npublic class Candy {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        if (n == 1) return 1;\n        int[] result = new int[n];\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i-1]) {\n                result[i] = result[i-1] + 1;\n            }\n        }\n        for (int i = n-2; i >= 0; i--) {\n            if (ratings[i] > ratings[i+1]) {\n                result[i] = Math.max(result[i], result[i+1] + 1);\n            }\n        }\n        System.out.println(Arrays.toString(result));\n        int count = n;\n        for (int x : result) {\n            count += x;\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/candy/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'e77c12cb-4e3b-4fb2-9512-52f51659219e',
                  isFolder: false,
                  name: 'InsertInterval.java',
                  code: 'import java.util.*;\n\npublic class InsertInterval {\n\n    public static int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> list = new ArrayList<>();\n        for (int[] interval: intervals) {\n            if (newInterval == null || interval[1] < newInterval[0]) {\n                list.add(interval);\n            } else if (interval[0] > newInterval[1]) {\n                list.add(newInterval);\n                list.add(interval);\n                newInterval = null;\n            } else {\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\n            }\n        }\n        if (newInterval != null) list.add(newInterval);\n        return list.toArray(new int[list.size()][]);\n    }\n\n    public static void main(String[] args) {\n        int[][] intervals = {{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}};\n        int[] newInterval = {4, 8};\n        int[][] ans = insert(intervals, newInterval);\n        for (int[] a : ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/insert-interval/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '79e7d7f0-24df-4511-a3ff-8ce11b02c88c',
                  isFolder: false,
                  name: 'JobSequencingProblem.java',
                  code: "import java.util.Arrays;\n\npublic class JobSequencingProblem {\n//    In coding ninja's platform the jobs are given in  2D array form the concept remains the same\n    static class Job {\n        int id, profit, deadline;\n\n        Job(int x, int y, int z) {\n            this.id = x;\n            this.deadline = y;\n            this.profit = z;\n        }\n    }\n\n    static int[] JobScheduling(Job[] arr, int n) {\n        Arrays.sort(arr, (a,b) -> (b.profit - a.profit));\n        int maxi = 0;\n        for (int i = 0; i < n; i++) {\n            maxi = Math.max(maxi, arr[i].deadline);\n        }\n        int[] result = new int[maxi + 1];\n        int totalProfit = 0, totalJobs = 0;\n        for (int i = 0; i < n; i++) {\n            for (int idx = arr[i].deadline; idx > 0; idx--) {\n                if (result[idx] == 0) {\n                    result[idx] = arr[i].profit;\n                    totalJobs++;\n                    totalProfit += arr[i].profit;\n                    break;\n                }\n            }\n        }\n        return new int[] {totalJobs, totalProfit};\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/job-sequencing-problem_1169460',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '89e814e4-8f10-405b-9442-d7e750f21300',
                  isFolder: false,
                  name: 'JumpGame.java',
                  code: 'public class JumpGame {\n    public boolean canJump(int[] nums) {\n        int goal = nums.length - 1;\n        for (int i = nums.length - 2; i >= 0; i--)\n            if (goal <= (nums[i] + i))\n                goal = i;\n        return goal == 0;\n    }\n}',
                  link: 'https://leetcode.com/problems/jump-game/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'b584c515-1915-497b-8eea-ba4f0f20fd0e',
                  isFolder: false,
                  name: 'JumpGame2.java',
                  code: 'public class JumpGame2 {\n    public int jump(int[] nums) {\n        int count = 0;\n        int l = 0, r = 0;\n        while (r < nums.length - 1) {\n            int max = 0;\n            for (int i = l; i <= r; i++) {\n                max = Math.max(max, i + nums[i]);\n            }\n            l = r + 1;\n            r = max;\n            count++;\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/jump-game-ii/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'f23cef64-e25d-4212-a5a4-546522eb17d5',
                  isFolder: false,
                  name: 'MergeIntervals.java',
                  code: 'import java.util.*;\npublic class MergeIntervals {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        int start = intervals[0][0], end = intervals[0][1];\n        List<int[]> list = new ArrayList<>();\n        for (int[] interval : intervals) {\n            if (interval[0] <= end) {\n                end = Math.max(end, interval[1]);\n            } else {\n                list.add(new int[] {start, end});\n                start = interval[0];\n                end = interval[1];\n            }\n        }\n        list.add(new int[] {start, end});\n        return list.toArray(new int[list.size()][]);\n    }\n}',
                  link: 'https://leetcode.com/problems/merge-intervals/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '83114bf2-d79b-4a05-9f9a-e5674be3aff9',
                  isFolder: false,
                  name: 'MinimumPlatforms.java',
                  code: 'import java.util.*;\n\npublic class MinimumPlatforms {\n\n    public static int calculateMinPlatforms(int[] arr, int[] dep, int n) {\n        // Write your code here.\n        Arrays.sort(arr);\n        Arrays.sort(dep);\n        int max = 0, platforms = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            if (arr[i] <= dep[j]) {\n                i++;\n                platforms++;\n            } else {\n                j++;\n                platforms--;\n            }\n            max = Math.max(max, platforms);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {900, 940, 950, 1100, 1500, 1800};\n        int[] dep = {910, 1200, 1120, 1130, 1900, 2000};\n        int ans = calculateMinPlatforms(arr, dep, arr.length);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-number-of-platforms_799400',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'be44aaf8-10a3-459a-b910-f00db1da3b14',
                  isFolder: false,
                  name: 'NMeetingsInARoom.java',
                  code: 'import java.util.*;\npublic class NMeetingsInARoom {\n    public static class Pair {\n        int start, end;\n        Pair (int s, int e) {\n            this.start = s;\n            this.end = e;\n        }\n    }\n    public static int maxMeetings(int start[], int end[], int n) {\n        // add your code here\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.end - b.end);\n        for (int i = 0; i < n; i++) pq.add(new Pair(start[i], end[i]));\n        int endTime = 0, count = 0;\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            if (p.start > endTime) {\n                count++;\n                endTime = p.end;\n            }\n        }\n        return count;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/maximum-meetings_1062658',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '3b2f789a-5309-4a2c-b27f-99df0f23f8cd',
                  isFolder: false,
                  name: 'NonOverlappingIntervals.java',
                  code: 'import java.util.*;\n\npublic class NonOverlappingIntervals {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        int count = 0;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.length; i++) {\n            int[] interval = intervals[i];\n            if (end <= interval[0]) {\n                end = interval[1];\n            } else {\n                count++;\n                end = Math.min(end, interval[1]);\n            }\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/non-overlapping-intervals/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '0d51235c-5542-4132-a015-f090f97745b5',
                  isFolder: false,
                  name: 'SJF.java',
                  code: 'import java.util.*;\n\npublic class SJF {\n    static class Job {\n        int at, bt;\n        Job(int a, int b) {\n            this.at = a;\n            this.bt = b;\n        }\n        @Override\n        public String toString() {\n            return \'{\' + "at=" + at + " bt=" + bt + \'}\';\n        }\n    }\n\n    public static float sjf(int n, int[] arrivalTime, int[] burstTime) {\n        // Write your code here.\n        Job[] jobs = new Job[n];\n        for (int i = 0; i < n; i++) {\n            jobs[i] = new Job(arrivalTime[i], burstTime[i]);\n        }\n        Arrays.sort(jobs, (a, b) -> a.at - b.at);\n        List<Job> list = new ArrayList<>();\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> a.bt - b.bt);\n        int currTime = 0,  i = 0;\n        while (i < n || !pq.isEmpty()) {\n            while (i < n && currTime >= jobs[i].at) pq.add(jobs[i++]);\n            if (pq.isEmpty()) {\n                currTime = jobs[i].at;\n                continue;\n            }\n            Job j = pq.poll();\n            list.add(j);\n            currTime += j.bt;\n        }\n        int xTime = list.get(0).at, ct = 0;\n        for (int j = 0; j < n; j++) {\n            Job job = list.get(j);\n            xTime += ct - job.at;\n            if (ct < job.at)\n                ct = job.at;\n            ct += job.bt;\n        }\n        return (float) xTime / n;\n    }\n\n    public static void main(String[] args) {\n        int[] arrivalTime = {1,1};\n        int[] burstTime = {3,4};\n//        int[] arrivalTime = {0, 5, 26, 0, 17, 13, 6, 2, 24};\n//        int[] burstTime = {22, 15, 21, 11, 14, 10, 27, 18, 24};\n        float ans = sjf(arrivalTime.length, arrivalTime, burstTime);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sjf_1172165',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
              ],
            },
            {
              id: '1d0a671b-e350-493f-ac65-af213c7b9a52',
              isFolder: true,
              name: 'Heaps',
              content: [
                {
                  id: '9700aa0c-4327-42e2-aa85-2918dc38ef38',
                  isFolder: false,
                  name: 'ConnectNRopesWithMinCost.java',
                  code: 'import java.util.*;\n\npublic class ConnectNRopesWithMinCost {\n    static int minCost(int[] arr, int n) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i : arr) pq.add(i);\n        int cost = 0;\n        while (pq.size() != 1) {\n            int sum = pq.poll() + pq.poll();\n            cost += sum;\n            pq.add(sum);\n        }\n        return cost;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/connect-n-ropes-with-minimum-cost_625783',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'ec518ba6-1712-4eb2-b4b5-40c2d27940d3',
                  isFolder: false,
                  name: 'DesignTwitter.java',
                  code: "import java.util.*;\n\npublic class DesignTwitter {\n    static class Tweet {\n        int userId;\n        int tweetId;\n        int tweetFrequency;\n\n        Tweet(int uId, int tId, int f) {\n            this.userId = uId;\n            this.tweetId = tId;\n            this.tweetFrequency = f;\n        }\n    }\n\n    static class Twitter {\n\n        HashMap<Integer, HashSet<Integer>> followMap;\n        int frequency = 0;\n        PriorityQueue<Tweet> pq;\n\n        public Twitter() {\n            followMap = new HashMap<>();\n            pq = new PriorityQueue<>((a, b) -> b.tweetFrequency - a.tweetFrequency);\n        }\n\n        public void postTweet(int userId, int tweetId) {\n            pq.add(new Tweet(userId, tweetId, frequency));\n            frequency++;\n        }\n\n        public List<Integer> getNewsFeed(int userId) {\n            Deque<Tweet> q = new ArrayDeque<>();\n            List<Integer> op = new ArrayList<>();\n            int count = 10;\n            while (count > 0 && !pq.isEmpty()) {\n                Tweet t = pq.poll();\n                q.add(t);\n                if (\n                        userId == t.userId ||\n                                (followMap.containsKey(userId) && followMap.get(userId).contains(t.userId))\n                ) {\n                    count--;\n                    op.add(t.tweetId);\n                }\n            }\n            while (!q.isEmpty()) pq.add(q.poll());\n            System.out.println(followMap);\n            return op;\n        }\n\n        public void follow(int followerId, int followeeId) {\n            if (!followMap.containsKey(followerId)) {\n                followMap.put(followerId, new HashSet<>());\n            }\n            followMap.get(followerId).add(followeeId);\n        }\n\n        public void unfollow(int followerId, int followeeId) {\n            if (followMap.containsKey(followerId)) {\n                followMap.get(followerId).remove(followeeId);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Twitter twitter = new Twitter();\n        twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\n        System.out.println(twitter.getNewsFeed(1));  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\n        twitter.follow(1, 2);    // User 1 follows user 2.\n        twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\n        System.out.println(twitter.getNewsFeed(1));  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\n        twitter.unfollow(1, 2);  // User 1 unfollows user 2.\n        System.out.println(twitter.getNewsFeed(1));  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n    }\n}",
                  link: 'https://leetcode.com/problems/design-twitter/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '48b8f255-02cf-42d0-9761-4792ff5a734c',
                  isFolder: false,
                  name: 'FindMedianFromDataStream.java',
                  code: 'import java.util.*;\n\npublic class FindMedianFromDataStream {\n    static class MedianFinder {\n        PriorityQueue<Integer> maxHeap;\n        PriorityQueue<Integer> minHeap;\n        public MedianFinder() {\n            maxHeap = new PriorityQueue<>((a,b) -> b - a);\n            minHeap = new PriorityQueue<>();\n        }\n\n        public void addNum(int num) {\n            if (num < findMedian()) maxHeap.add(num);\n            else minHeap.add(num);\n            if (minHeap.size() - maxHeap.size() > 1) maxHeap.add(minHeap.poll());\n            else if (maxHeap.size() - minHeap.size() > 1) minHeap.add(maxHeap.poll());\n        }\n\n        public double findMedian() {\n            if (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;\n            if (minHeap.size() == maxHeap.size())\n                return (minHeap.peek() + maxHeap.peek())/2.0;\n            if (minHeap.size() > maxHeap.size())\n                return minHeap.peek();\n            return maxHeap.peek();\n        }\n    }\n\n    public static void main(String[] args) {\n        MedianFinder medianFinder = new MedianFinder();\n        medianFinder.addNum(1);    // arr = [1]\n        medianFinder.addNum(2);    // arr = [1, 2]\n        System.out.println(medianFinder.findMedian()); // return 1.5 (i.e., (1 + 2) / 2)\n        medianFinder.addNum(3);    // arr[1, 2, 3]\n        System.out.println(medianFinder.findMedian()); // return 2.0\n    }\n}',
                  link: 'https://leetcode.com/problems/find-median-from-data-stream/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'aebf297a-ac7f-4b4d-b1d4-c97adc06df38',
                  isFolder: false,
                  name: 'KthLargest.java',
                  code: 'import java.util.*;\n\nclass KthLargest {\n    PriorityQueue<Integer> pq;\n    int size;\n\n    public KthLargest(int k, int[] nums) {\n        pq = new PriorityQueue<>();\n        size = k;\n        for (int num : nums) {\n            pq.add(num);\n            if (pq.size() > k) pq.poll();\n        }\n    }\n\n    public int add(int val) {\n        pq.add(val);\n        if (pq.size() > size) pq.poll();\n        return pq.peek();\n    }\n}',
                  link: 'https://leetcode.com/problems/kth-largest-element-in-a-stream/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'fddea436-9884-41fe-bea8-1828bf47fee6',
                  isFolder: false,
                  name: 'MaximumSumCombination.java',
                  code: '// link: https://practice.geeksforgeeks.org/problems/maximum-sum-combination/1\n\nimport java.util.*;\n\npublic class MaximumSumCombination {\n    static List<Integer> maxCombinations(int N, int c, int a[], int b[]) {\n        List<Integer> al = new ArrayList<Integer>();\n        Arrays.sort(a);\n        Arrays.sort(b);\n        int n = N-1;\n        PriorityQueue<Pair> pq = new PriorityQueue<>((p,q) -> q.v - p.v);\n        pq.add(new Pair(a[n] + b[n], n, n));\n        Set<String> set = new HashSet<>();\n        set.add(n + " " + n);\n\n        while (!pq.isEmpty()) {\n            Pair cur = pq.poll();\n            al.add(cur.v);\n            if (al.size() == c) break;\n            int x = cur.x, y = cur.y;\n            if (x-1 >= 0 && !set.contains((x-1) + " " + y)) {\n                pq.add(new Pair(a[x-1] + b[y], x-1, y));\n                set.add((x-1) + " " + y);\n            }\n            if (y-1 >= 0 && !set.contains(x + " " + (y-1))) {\n                pq.add(new Pair(a[x] + b[y-1], x, y-1));\n                set.add(x + " " + (y-1));\n            }\n        }\n        return al;\n    }\n    static class Pair {\n        int v, x, y;\n        Pair(int v, int x, int y) {\n            this.v = v;\n            this.x = x;\n            this.y = y;\n        }\n        // public int compareTo(Pair p) { return p.v - this.v; }\n    }\n\n    public static void main(String[] args) {\n        int[] A = {9, 9, 10, 6, 1, 6, 4};\n        int[] B = {5, 3, 4, 2, 10, 4, 9};\n        int k = 4;\n        List<Integer> ans = maxCombinations(A.length, k, A, B);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'b95c0e6f-4ecf-46a3-9c82-037bf3cef2a9',
                  isFolder: false,
                  name: 'TopKFrequentElements.java',
                  code: 'import java.util.*;\n\npublic class TopKFrequentElements {\n    static class Pair {\n        int key, freq;\n        Pair(int k, int f) {\n            this.key = k;\n            this.freq = f;\n        }\n    }\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.freq - b.freq);\n        for (Map.Entry<Integer, Integer> m : map.entrySet()) {\n            pq.add(new Pair(m.getKey(), m.getValue()));\n            if (pq.size() > k) pq.poll();\n        }\n        int[] ans = new int[k];\n        for (int i = 0; i < k; i++) {\n            ans[i] = pq.poll().key;\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/top-k-frequent-elements/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'a9ea6069-aedd-42ad-9089-4b47d2dac73e',
                  isFolder: false,
                  name: 'MaxHeap.java',
                  code: 'import java.util.*;\n\npublic class MaxHeap {\n    public static void swap(List<Integer> heap, int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n\n    //    MAX HEAP push: SWAP if PARENT < CHILD\n    public static void push(List<Integer> heap, int value) {\n        heap.add(value);\n        int i = heap.size() - 1;\n        while (heap.get((i - 1) / 2) < heap.get(i)) {\n            swap(heap, i, (i - 1) / 2);\n            i = (i - 1) / 2;\n        }\n    }\n\n    public static int pop(List<Integer> heap) {\n        if (heap.isEmpty()) return -1;\n        if (heap.size() == 1) return heap.remove(0);\n        int val = heap.get(0);\n        heap.set(0, heap.get(heap.size() - 1));\n        heap.remove(heap.size() - 1);\n        int i = 0;\n        while (2 * i + 1 < heap.size()) {\n            int lIdx = 2*i + 1;\n            int rIdx = 2*i + 2;\n            int leftChild = heap.get(lIdx);\n            if (rIdx < heap.size() && heap.get(rIdx) >= leftChild && heap.get(rIdx) > heap.get(i)) {\n                swap(heap, rIdx, i);\n                i = rIdx;\n            } else if (leftChild > heap.get(i)) {\n                swap(heap, lIdx, i);\n                i = lIdx;\n            } else break;\n        }\n        return val;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> heap = new ArrayList<>();\n\n        System.out.println(pop(heap));\n        push(heap, 76);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        push(heap, 62);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        push(heap, 58);\n        push(heap, 8);\n        push(heap, 4);\n        push(heap, 52);\n        System.out.println(pop(heap));\n        push(heap, 74);\n        System.out.println(pop(heap));\n        System.out.println(heap);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'a889fd0c-f2a6-456e-b148-ccd07455e182',
                  isFolder: false,
                  name: 'MinHeap.java',
                  code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MinHeap {\n    public static void swap(List<Integer> heap, int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n\n    //    MAX HEAP push: SWAP if PARENT < CHILD\n    public static void push(List<Integer> heap, int value) {\n        heap.add(value);\n        int i = heap.size() - 1;\n        while (heap.get((i - 1) / 2) > heap.get(i)) {\n            swap(heap, i, (i - 1) / 2);\n            i = (i - 1) / 2;\n        }\n    }\n\n    public static void percolateDownMinHeap(List<Integer> heap, int i) {\n        while (2 * i + 1 < heap.size()) {\n            int lIdx = 2*i + 1;\n            int rIdx = 2*i + 2;\n            int leftChild = heap.get(lIdx);\n            if (rIdx < heap.size() && heap.get(rIdx) <= leftChild && heap.get(rIdx) < heap.get(i)) {\n                swap(heap, rIdx, i);\n                i = rIdx;\n            } else if (leftChild < heap.get(i)) {\n                swap(heap, lIdx, i);\n                i = lIdx;\n            } else break;\n        }\n    }\n    public static int pop(List<Integer> heap) {\n        if (heap.isEmpty()) return -1;\n        if (heap.size() == 1) return heap.remove(0);\n        int val = heap.get(0);\n        heap.set(0, heap.get(heap.size() - 1));\n        heap.remove(heap.size() - 1);\n        percolateDownMinHeap(heap, 0);\n        return val;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> heap = new ArrayList<>();\n        push(heap, 50);\n        push(heap, 10);\n        push(heap, 70);\n        push(heap, 20);\n        push(heap, 30);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(heap);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '4f12a2d3-cef7-46f9-80b9-f22664a26a4b',
                  isFolder: false,
                  name: 'HandOfStraights.java',
                  code: 'import java.util.*;\n\npublic class HandOfStraights {\n    public static boolean isNStraightHand(int[] hand, int groupSize) {\n        if (hand.length < groupSize || hand.length % groupSize != 0) return false;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int j : hand) hm.put(j, hm.getOrDefault(j, 0) + 1);\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (Map.Entry<Integer, Integer> m : hm.entrySet()) pq.add(m.getKey());\n\n        while (!pq.isEmpty()) {\n            int first = pq.peek();\n            for (int i = first; i < first + groupSize; i++) {\n                if (hm.containsKey(i)) {\n                    int count = hm.get(i) - 1;\n                    hm.put(i, count);\n                    if (count == 0) {\n                        if (i != pq.peek()) return false;\n                        pq.poll();\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] hand = {1,2,3,6,2,3,4,7,8};\n        int groupSize = 3;\n        System.out.println(isNStraightHand(hand, groupSize));\n\n    }\n}',
                  link: 'https://leetcode.com/problems/hand-of-straights/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '3649b9ba-68a3-4307-b5f5-497818236e21',
                  isFolder: false,
                  name: 'KthLargestElement.java',
                  code: 'import java.util.*;\npublic class KthLargestElement {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int num : nums) {\n            pq.add(num);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        return pq.poll();\n    }\n}',
                  link: 'https://leetcode.com/problems/kth-largest-element-in-an-array/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '86e1a7cd-b853-4f9a-95ed-3ab853c4eaab',
                  isFolder: false,
                  name: 'KthSmallestElement.java',
                  code: 'import java.util.*;\npublic class KthSmallestElement {\n    public static int kthSmallest(int[] arr, int l, int r, int k) {\n        //Your code here\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for (int i = l; i <= r; i++) {\n            pq.add(arr[i]);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        return pq.poll();\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '6f35b3e4-3e7c-4900-ab12-e87ad48c77ac',
                  isFolder: false,
                  name: 'MergeKElements.java',
                  code: 'public class MergeKElements {\n    public static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n    public ListNode merge(ListNode a, ListNode b) {\n        ListNode temp = new ListNode(0);\n        ListNode curr = temp;\n        while (a != null && b != null) {\n            if (a.val <= b.val) {\n                curr.next = a;\n                a = a.next;\n            } else {\n                curr.next = b;\n                b = b.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = a != null ? a : b;\n        return temp.next;\n    }\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += 2*interval)\n                lists[i] = merge(lists[i], lists[i + interval]);\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
                  link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'd71763af-2bd8-4598-a8fd-5386a89a0bfc',
                  isFolder: false,
                  name: 'MergeKSortedLists.java',
                  code: 'public class MergeKSortedLists {\n     public class ListNode {\n         int val;\n         ListNode next;\n\n         ListNode() {\n         }\n\n         ListNode(int val) {\n             this.val = val;\n         }\n\n         ListNode(int val, ListNode next) {\n             this.val = val;\n             this.next = next;\n         }\n     }\n    public ListNode merge(ListNode a, ListNode b) {\n        ListNode temp = new ListNode(0);\n        ListNode curr = temp;\n        while (a != null && b != null) {\n            if (a.val <= b.val) {\n                curr.next = a;\n                a = a.next;\n            } else {\n                curr.next = b;\n                b = b.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = a != null ? a : b;\n        return temp.next;\n    }\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += 2*interval)\n                lists[i] = merge(lists[i], lists[i + interval]);\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
                  link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '749ad691-e5c4-4ef4-bebd-2fd2f62085da',
                  isFolder: false,
                  name: 'NearlySorted.java',
                  code: 'import java.util.*;\npublic class NearlySorted {\n    public static int[] nearlySorted(int[] arr, int n, int k) {\n        // Write your code here.\n        int[] ans = new int[n];\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        int idx = 0;\n        for (int i = 0; i < arr.length; i++) {\n            pq.add(arr[i]);\n            if (pq.size() > k) {\n                ans[idx++] = pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            ans[idx++] = pq.poll();\n        }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/nearly-sorted_982937',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'a79ab2b4-c34d-4d24-b0ae-887bfff39a7d',
                  isFolder: false,
                  name: 'ReplaceEachElementWithItsRank.java',
                  code: 'import java.util.*;\npublic class ReplaceEachElementWithItsRank {\n    public static List<Integer> replaceWithRank(List<Integer> arr, int n) {\n        // Write your code here\n        List<Integer> ans = new ArrayList<>(arr);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        Collections.sort(arr);\n        int rank = 1;\n        for (int element : arr)\n            if (!map.containsKey(element)) map.put(element, rank++);\n        for (int i = 0; i < arr.size(); i++)\n            ans.set(i, map.get(ans.get(i)));\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/replace-each-element-of-array-with-its-corresponding-rank_975384',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '2c033b6a-b952-409f-8176-5f8a40692769',
                  isFolder: false,
                  name: 'TaskScheduler.java',
                  code: "import java.util.*;\n\npublic class TaskScheduler {\n    static class Pair {\n        int val, time;\n        Pair(int v, int t) {\n            this.val = v;\n            this.time = t;\n        }\n    }\n    public static int leastInterval(char[] tasks, int n) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int task : tasks)\n            hm.put(task, hm.getOrDefault(task, 0) + 1);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for (Map.Entry<Integer, Integer> m: hm.entrySet())\n            pq.add(m.getValue());\n        Queue<Pair> q = new LinkedList<>();\n        int time = 0;\n        while (!pq.isEmpty() || !q.isEmpty()) {\n            time++;\n            if (!pq.isEmpty()) {\n                int val = pq.poll() - 1;\n                if (val > 0) q.add(new Pair(val, time + n));\n            }\n            if (!q.isEmpty() && q.peek().time <= time)\n                pq.add(q.poll().val);\n        }\n        return time;\n\n    }\n\n    public static void main(String[] args) {\n        char[] tasks = {'A', 'A', 'A', 'B', 'B', 'B'};\n        int n = 2;\n        int ans = leastInterval(tasks, n);\n        System.out.println(ans);\n    }\n}",
                  link: 'https://leetcode.com/problems/task-scheduler/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
              ],
            },
            {
              id: 'a93f4471-0a3a-447d-9882-a8a892b1960a',
              isFolder: true,
              name: 'LinkedList',
              content: [
                {
                  id: 'b2821957-9352-436c-a16c-a47b91f31c31',
                  isFolder: false,
                  name: 'CopyListWithRandomPointer.java',
                  code: 'public class CopyListWithRandomPointer {\n    class Node {\n        int val;\n        Node next;\n        Node random;\n        public Node(int val) {\n            this.val = val;\n            this.next = null;\n            this.random = null;\n        }\n    }\n    public Node copyRandomList(Node head) {\n        // Optimised solution\n        if (head == null) return null;\n        // Step 1: Create a new linked list in between the nodes of current LL\n        Node curr = head;\n        while (curr != null) {\n            Node newNode = new Node(curr.val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            curr = newNode.next;\n        }\n        // Step 2: Assign random pointers to the deep copy\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n        // Step 3: Separate both the linked list and return Head\n        Node copy = head.next;\n        Node temp = copy;\n        curr = head;\n        while (temp != null) {\n            curr.next = temp.next;\n            curr = curr.next;\n            if (curr == null) break;\n            temp.next = curr.next;\n            temp = temp.next;\n        }\n        // curr.next = null;\n        return copy;\n    }\n}',
                  link: 'https://leetcode.com/problems/copy-list-with-random-pointer',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '46191f58-2320-43bb-be6d-bab7a7ee4afe',
                  isFolder: false,
                  name: 'FlattenLL.java',
                  code: 'public class FlattenLL {\n    public class Node {\n        public int data;\n        public Node next;\n        public Node child;\n\n        Node()\n        {\n            this.data = 0;\n            this.next = null;\n            this.child = null;\n        }\n        Node(int data)\n        {\n            this.data = data;\n            this.next = null;\n            this.child = null;\n        }\n        Node(int data, Node next, Node child)\n        {\n            this.data = data;\n            this.next = next;\n            this.child = child;\n        }\n    }\n\n    public static Node merge(Node left, Node right) {\n        Node temp = new Node(0);\n        Node tHead = temp;\n        while (left != null && right != null) {\n            if (left.data <= right.data) {\n                temp.child = left;\n                left = left.child;\n            } else {\n                temp.child = right;\n                right = right.child;\n            }\n            temp = temp.child;\n        }\n        if (left != null)\n            temp.child = left;\n        else\n            temp.child = right;\n        return tHead.child;\n    }\n    public static Node flatList(Node head) {\n        if (head == null || head.next == null) return head;\n        head.next = flatList(head.next);\n        head = merge(head, head.next);\n        return head;\n    }\n    public static Node flattenLinkedList(Node head) {\n        //Write your code here\n        return flatList(head);\n    }\n\n}',
                  link: 'https://www.codingninjas.com/studio/problems/flatten-a-linked-list_1112655',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: 'f6c1cab3-a91a-4d0d-ab20-5be990bd9f4d',
                  isFolder: false,
                  name: 'ReverseNodesInKGroups.java',
                  code: 'public class ReverseNodesInKGroups {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = head;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head, start = head, prev = head;\n        ListNode newHead = new ListNode(0, head);\n        ListNode temp = newHead;\n\n        while (curr != null) {\n            for (int i = 1; i <= k; i++) {\n                if (curr.next == null && i < k) return newHead.next;\n                prev = curr;\n                curr = curr.next;\n            }\n            prev.next = null;\n            temp.next = revLL(start);\n            start.next = curr;\n            temp = start;\n            start = curr;\n        }\n        return newHead.next;\n    }\n}',
                  link: 'https://leetcode.com/problems/reverse-nodes-in-k-group/',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '0dcfb6a3-2dd9-475a-8338-d23343a170dc',
                  isFolder: false,
                  name: 'RotateList.java',
                  code: 'public class RotateList {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        int length = 1;\n        ListNode end = head;\n        while (end.next != null) {\n            length++;\n            end = end.next;\n        }\n        k = k%length;\n        if (k == 0) return head;\n        ListNode prev = null;\n        ListNode start = head;\n        for (int i = 0; i <length - k; i++) {\n            prev = start;\n            start = start.next;\n        }\n        prev.next = null;\n        end.next = head;\n        head = start;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/rotate-list/',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: 'ce87dade-fa83-4507-9cf0-777dff7b59e2',
                  isFolder: false,
                  name: 'AddOneToNumberLL.java',
                  code: 'public class AddOneToNumberLL {\n    public static Node revLL(Node head) {\n\t\tNode prev = null;\n\t\tNode curr = head, next = head;\n\t\twhile (curr != null) {\n\t\t\tnext = curr.next;\n\t\t\tcurr.next = prev;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\treturn prev;\n\t}\n\n\tpublic static Node addNode(Node head) {\n\t\t// Write your code here.\n\t\thead = revLL(head);\n\t\tNode curr = head;\n\t\tint carry = 1;\n\t\twhile (curr.next != null) {\n\t\t\tcarry = curr.data + carry;\n\t\t\tcurr.data = carry % 10;\n\t\t\tcarry = carry / 10;\n\t\t\tif (carry == 0) break;\n\t\t\tcurr = curr.next;\n\t\t}\n\t\tif (carry != 0) {\n\t\t\tcurr.next = new Node(carry);\n\t\t}\n\t\thead = revLL(head);\n\t\treturn head;\n\t}\n}',
                  link: 'https://www.codingninjas.com/studio/problems/add-one-to-a-number-represented-as-linked-list_920557',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '5ea077b7-977f-4f5e-86e2-c392292cb37b',
                  isFolder: false,
                  name: 'AddTwoNumbersLL.java',
                  code: 'public class AddTwoNumbersLL {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode sum = new ListNode(0);\n        ListNode sumHead = sum;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int d1 = l1 != null ? l1.val : 0;\n            int d2 = l2 != null ? l2.val : 0;\n            carry += d1 + d2;\n            sum.next = new ListNode(carry%10);\n            sum = sum.next;\n            carry /= 10;\n            l1 = l1 != null ? l1.next : null;\n            l2 = l2 != null ? l2.next : null;\n        }\n        return sumHead.next;\n    }\n}',
                  link: 'https://leetcode.com/problems/add-two-numbers/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '7214de70-9371-4377-a895-3cd3c496ffc4',
                  isFolder: false,
                  name: 'DeleteMiddleNode.java',
                  code: 'public class DeleteMiddleNode {\n    public ListNode deleteMiddle(ListNode head) {\n        if (head.next == null) return null;\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = slow.next;\n        slow.next = null;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'cf49a0df-6811-4609-b0b7-02045d46db43',
                  isFolder: false,
                  name: 'IntersectionOfTwoLinkedLists.java',
                  code: 'public class IntersectionOfTwoLinkedLists {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode d1 = headA;\n        ListNode d2 = headB;\n        while (d1 != d2) {\n            d1 = d1 == null ? headB : d1.next;\n            d2 = d2 == null ? headA : d2.next;\n        }\n        return d1;\n    }\n}',
                  link: 'https://leetcode.com/problems/intersection-of-two-linked-lists/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '5b3a3824-e034-46f6-aaf3-abe3e0dce1bd',
                  isFolder: false,
                  name: 'LengthOfLoopInLL.java',
                  code: 'public class LengthOfLoopInLL {\n\n    public static int lengthOfLoop(Node head) {\n        // Write your code here\n        if (head == null || head.next == null) {\n            return 0;\n        }\n        int len = 1;\n        Node s = head, f = head, s2 = head;\n        while (f != null && f.next != null) {\n            s = s.next;\n            f = f.next.next;\n            if (f == s) {\n                while (s != s2) {\n                    s = s.next;\n                    s2 = s2.next;\n                }\n                s = s.next;\n                while (s != s2) {\n                    s = s.next;\n                    len++;\n                }\n            }\n        }\n        return len;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-length-of-loop_8160455',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '0532c0c2-b0f7-493f-9702-73ffc83f4a46',
                  isFolder: false,
                  name: 'ListNode.java',
                  code: 'public class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '424e27d4-7809-4dc9-a161-7a15d5f47f67',
                  isFolder: false,
                  name: 'Node.java',
                  code: 'public class Node {\n    public int data;\n    public Node next;\n\n    Node() {\n        this.data = 0;\n        this.next = null;\n    }\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    Node(int data, Node next) {\n        this.data = data;\n        this.next = next;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '27d58447-cbe1-4cb2-8450-ab441047f163',
                  isFolder: false,
                  name: 'OddEvenLinkedList.java',
                  code: 'public class OddEvenLinkedList {\n    public static ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenhead = even;\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        odd.next = evenhead;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/odd-even-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'b335f165-5d71-4dff-aaed-5d340de0c36a',
                  isFolder: false,
                  name: 'PalindromeLinkedList.java',
                  code: '// Definition for singly-linked list.\nclass PalindromeLinkedList {\n    public static ListNode revLL(ListNode head) {\n        ListNode curr = head, prev = null, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n        ListNode slow = head, curr = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        slow = revLL(slow);\n        while (slow != null) {\n            if (slow.val != curr.val) return false;\n            slow = slow.next;\n            curr = curr.next;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println("Hello");\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '404a68d9-3a67-48e9-aebb-048d80697361',
                  isFolder: false,
                  name: 'RemoveNthNodeFromLastOfLL.java',
                  code: 'public class RemoveNthNodeFromLastOfLL {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode curr = head;\n        int l = 1;\n        while (curr.next != null) {\n            curr = curr.next;\n            l++;\n        }\n        int len = l - n;\n        if (len == 0) {\n            head = head.next;\n        } else {\n            curr = head;\n            while (len != 1) {\n                len--;\n                curr = curr.next;\n            }\n            curr.next = curr.next.next;\n        }\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '0e948a0c-13ab-42f9-8c22-c9e195a36940',
                  isFolder: false,
                  name: 'Sort012LinkedList.java',
                  code: 'public class Sort012LinkedList {\n    public static Node sortList(Node head) {\n        // Write your code here\n        Node zeroHead = new Node(0), onesHead = new Node(0), twosHead = new Node(0);\n        Node zero = zeroHead, ones = onesHead, twos = twosHead;\n        Node curr = head;\n        while (curr != null) {\n            if (curr.data == 0) {\n                zero.next = curr;\n                zero = zero.next;\n            } else if (curr.data == 1) {\n                ones.next = curr;\n                ones = ones.next;\n            } else {\n                twos.next = curr;\n                twos = twos.next;\n            }\n            curr = curr.next;\n        }\n        twos.next = null;\n        ones.next = twosHead.next;\n        zero.next = onesHead.next;\n        return zeroHead.next;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sort-linked-list-of-0s-1s-2s_1071937',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '458db805-89a1-4826-b80d-3e4e2b8b2a33',
                  isFolder: false,
                  name: 'SortLinkedList.java',
                  code: 'public class SortLinkedList {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode(0);\n        ListNode tHead = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null)\n            temp.next = left;\n        else\n            temp.next = right;\n        return tHead.next;\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode s = head, f = head.next;\n        while (f != null && f.next != null) {\n            s = s.next;\n            f = f.next.next;\n        }\n        ListNode head2 = s.next;\n        s.next = null;\n        head = mergeSort(head);\n        head2 = mergeSort(head2);\n        return merge(head, head2);\n    }\n    public ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n}',
                  link: 'https://leetcode.com/problems/sort-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '37d16802-8d67-4cd9-a617-6e774598c9e8',
                  isFolder: false,
                  name: 'DeleteAllCommonOccurances.java',
                  code: 'public class DeleteAllCommonOccurances {\n    public static Node deleteAllOccurrences(Node head, int k) {\n        // Write your code here.\n        while (head != null && head.data == k) {\n            head = head.next;\n        }\n        if (head == null) return null;\n        Node start = head, curr = head.next;\n        while (curr != null) {\n            if (curr.data != k) {\n                start.next = curr;\n                curr.prev = start;\n                start = curr;\n            }\n            curr = curr.next;\n        }\n        start.next = null;\n        return head;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/delete-all-occurrences-of-a-given-key-in-a-doubly-linked-list_8160461',
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: '0d45dc76-9749-4dc4-932e-13e4b7e7c09a',
                  isFolder: false,
                  name: 'Node.java',
                  code: 'public class Node {\n    public int data;\n    public Node next;\n    public Node prev;\n\n    Node() {\n        this.data = 0;\n        this.next = null;\n        this.prev = null;\n    }\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n    }\n\n    Node(int data, Node next, Node prev) {\n        this.data = data;\n        this.next = next;\n        this.prev = prev;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: 'b2a3591d-7426-426b-ba73-219da2c1b826',
                  isFolder: false,
                  name: 'PairWithGivenSum.java',
                  code: 'import java.util.*;\n\npublic class PairWithGivenSum {\n    public static List<List<Integer>> findPairs (Node head, int k) {\n        Node start = head, end = head;\n        while (end.next != null && end.data + start.data <= k) {\n            end = end.next;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n        while (start != null && end != null && start.data < end.data) {\n            int s = start.data + end.data;\n            if (s > k)\n                end = end.prev;\n            else if (s < k)\n                start = start.next;\n            else {\n                output.add(new ArrayList<>(Arrays.asList(start.data, end.data)));\n                start = start.next;\n                end = end.prev;\n            }\n        }\n        return output;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-pairs-with-given-sum-in-doubly-linked-list_1164172',
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: 'fa0717b2-1537-4fbe-9232-26d2f1442417',
                  isFolder: false,
                  name: 'RemoveDuplicatesSortedDLL.java',
                  code: '//  Link: https://www.codingninjas.com/studio/problems/remove-duplicates-from-a-sorted-doubly-linked-list_2420283\n\npublic class RemoveDuplicatesSortedDLL {\n    public static Node uniqueSortedList(Node head) {\n        // Write your code here.\n        if (head == null || head.next == null) return head;\n        Node start = head;\n        Node curr = head.next;\n        while (curr != null) {\n            if (start.data != curr.data) {\n                start.next = curr;\n                start = start.next;\n            }\n            curr = curr.next;\n        }\n        start.next = null;\n        return head;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
              ],
            },
            {
              id: '43f4950b-06c7-4f0e-85df-f947283d0ed8',
              isFolder: false,
              name: 'Patterns.java',
              code: '// !ignore\nimport java.util.Scanner;\n\npublic class Patterns {\n    public static void printBlockPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printTriangleNumberPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(j + 1);\n            System.out.println();\n        }\n    }\n\n    public static void printTriangleNumberPattern2(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(i + 1);\n            System.out.println();\n        }\n    }\n\n    public static void printDownTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = n; j > i; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDownTriangleNumberPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++)\n                System.out.print(j + 1 - i);\n            System.out.println();\n        }\n    }\n\n    public static void printEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i - 1; j++)\n                System.out.print(" ");\n            for (int j = 0; j < 2 * i + 1; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDownEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++)\n                System.out.print(" ");\n            for (int j = 0; j < 2 * (n - i) - 1; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDiamondPattern(int n) {\n        printEQTrianglePattern(n);\n        printDownEQTrianglePattern(n);\n    }\n\n    public static void printHalfDiamondPattern(int n) {\n        printTrianglePattern(n);\n        printDownTrianglePattern(n - 1);\n    }\n\n    public static void print01TrianglePattern(int n) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                System.out.print((i + j) % 2 == 0 ? 1 : 0);\n            }\n            System.out.println();\n        }\n    }\n\n    public static void printHalfButterflyNumberPattern(int n) {\n        for (int i = 1; i <= n; i++) {\n//            Num\n            for (int j = 1; j <= i; j++)\n                System.out.print(j + " ");\n//            Space\n            for (int k = 0; k < (n - i) * 2; k++)\n                System.out.print("  ");\n//            Num\n            for (int j = i; j > 0; j--)\n                System.out.print(j + " ");\n            System.out.println();\n        }\n    }\n\n    public static void printNumberTrianglePattern(int n) {\n        int start = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(start++ + " ");\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (j + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printDownAlphabetTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i; j++)\n                System.out.print((char) (j + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetTrianglePattern2(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (i + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n//            Space\n            for (int j = n; j > i; j--) {\n                System.out.print(" ");\n            }\n//            Num\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (j + 65));\n//            Num\n            for (int j = i; j > 0; j--)\n                System.out.print((char) (j + 64));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetReverseTrianglePattern(int n) {\n        for (int i = n; i > 0; i--) {\n//            Num\n            for (int j = n - i; j >= 0; j--)\n                System.out.print((char) (n - j - 1 + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printInnerDiamondPattern(int n) {\n        for (int i = n; i > 0; i--) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < n - i; j++)\n                System.out.print("  ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < n - i; j++)\n                System.out.print("  ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printButterflyPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            for (int j = 0; j < n - i - 1; j++)\n                System.out.print("  ");\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n        for (int i = n - 1; i > 0; i--) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < 2 * (n - i); j++)\n                System.out.print(" ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printEmptyRectPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == n - 1 || j == 0 || j == n-1) {\n                    System.out.print("*");\n                } else {\n                    System.out.print(" ");\n                }\n            }\n            System.out.println();\n        }\n    }\n    public static void printNumberRectPattern(int n) {\n        for (int i = 0; i < 2*n -1; i++) {\n            for (int j = 0;  j < 2*n -1; j++) {\n                int down = 2*n -2 - i;\n                int right = 2*n -2 - j;\n                System.out.print(n - Math.min(Math.min(i, down), Math.min(j, right)));\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n//        printBlockPattern(n);\n//        printTrianglePattern(n);\n//        printTriangleNumberPattern(n);\n//        printTriangleNumberPattern2(n);\n//        printDownTrianglePattern(n);\n//        printDownTriangleNumberPattern(n);\n//        printEQTrianglePattern(n);\n//        printDownEQTrianglePattern(n);\n//        printDiamondPattern(n);\n//        printHalfDiamondPattern(n);\n//        print01TrianglePattern(n);\n//        printHalfButterflyNumberPattern(n);\n//        printNumberTrianglePattern(n);\n//        printAlphabetTrianglePattern(n);\n//        printDownAlphabetTrianglePattern(n);\n//        printAlphabetTrianglePattern2(n);\n//        printAlphabetEQTrianglePattern(n);\n//        printAlphabetReverseTrianglePattern(n);\n//        printInnerDiamondPattern(n);\n//        printButterflyPattern(n);\n        printEmptyRectPattern(n);\n//        printNumberRectPattern(n);\n        sc.close();\n    }\n}',
              link: null,
              notes: '',
              tags: ['Pattern'],
            },
            {
              id: '7af98099-e20a-4da7-8372-f98fa2c784c4',
              isFolder: true,
              name: 'Recursion',
              content: [
                {
                  id: '057907e4-ee0c-470c-a5ca-3054ffc81418',
                  isFolder: false,
                  name: 'CountGoodNumbers.java',
                  code: 'public class CountGoodNumbers {\n    public static long power(long num, long n) {\n        if (n == 0) return 1;\n        if (n == 1) return num;\n        long r = power(num, n/2);\n        if (n%2 == 0) return (r*r)%1000000007;\n        return (r*r*num)%1000000007;\n    }\n    public int countGoodNumbers(long n) {\n        long primePower = power(4, n/2);\n        long evenPower = power(5, n/2);\n        if (n%2 == 1)\n            evenPower *= 5;\n        return (int)((evenPower * primePower)%1000000007);\n    }\n}',
                  link: 'https://leetcode.com/problems/count-good-numbers/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '4572fd75-5b6c-496d-9606-9051bdf05515',
                  isFolder: false,
                  name: 'Pow.java',
                  code: 'public class Pow {\n    public static double fastExpo(double x, int n) {\n        if (n == 0) return 1;\n        if (n == 1) return x;\n        double r = fastExpo(x, n/2);\n        return n%2 == 0 ? r*r : r*x*r;\n    }\n    public double myPow(double x, int n) {\n        // if (n == 0) return 1;\n        // double ans = x;\n        // for (int i = 2; i <= Math.abs(n); i++)\n        //     ans = ans * x;\n        // if (n < 0) {\n        //     ans = 1/ans;\n        // }\n        // return ans;\n        boolean isNegative = n < 0;\n        n = Math.abs(n);\n        double fast = fastExpo(x, n);\n        return isNegative ? 1/fast : fast;\n    }\n}',
                  link: 'https://leetcode.com/problems/powx-n/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'bfc09c18-f2eb-4c27-ae6c-fa73c8895307',
                  isFolder: false,
                  name: 'RecursiveATOI.java',
                  code: "public class RecursiveATOI {\n    public static int solve(char[] arr, int i, double num, boolean isNegative, boolean signed) {\n        if (i >= arr.length || signed && ((arr[i] == '+' || arr[i] == '-') || !Character.isDigit(arr[i]))) {\n            num = isNegative ? -num : num;\n            if (num > Integer.MAX_VALUE)\n                num = Integer.MAX_VALUE;\n            else if (num < Integer.MIN_VALUE)\n                num = Integer.MIN_VALUE;\n            return (int) num;\n        }\n        if (arr[i] == '+' || arr[i] == '-') {\n            isNegative = arr[i] == '-';\n            signed = true;\n        } else if (arr[i] - '0' >= 0 && arr[i] - '0' <= 9) {\n            num = num * 10 + (arr[i] - '0');\n            signed = true;\n        } else if (Character.isDigit(arr[i]) && arr[i] != ' ') {\n            i = arr.length;\n        }\n        i++;\n        return solve(arr, i, num, isNegative, signed);\n    }\n\n    public static int myAtoi(String s) {\n        char[] arr = s.toCharArray();\n        return solve(arr, 0, 0, false, false);\n    }\n\n    public static void main(String[] args) {\n        String s = \"  -0012a42\";\n        System.out.println(myAtoi(s));\n    }\n}",
                  link: 'https://leetcode.com/problems/string-to-integer-atoi/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'a1a16287-d909-4762-a167-4ddf9947688a',
                  isFolder: false,
                  name: 'ReverseStack.java',
                  code: 'import java.util.Stack;\n\npublic class ReverseStack {\n    public static void insertElement(int element, Stack<Integer> s) {\n        if (s.isEmpty()) {\n            s.push(element);\n        } else {\n            int top = s.pop();\n            insertElement(element, s);\n            s.push(top);\n        }\n    }\n    public static void reverseStack(Stack<Integer> s) {\n        if (s.isEmpty()) return;\n        int element = s.pop();\n        reverseStack(s);\n        insertElement(element, s);\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> s = new Stack<>();\n        s.push(30);\n        s.push(-5);\n        s.push(18);\n        s.push(14);\n        s.push(-3);\n\n        System.out.println("Stack elements before sorting: ");\n        SortStack.printStack(s);\n        reverseStack(s);\n        System.out.println(" \\n\\nStack elements after sorting:");\n        SortStack.printStack(s);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/reverse-stack-using-recursion_631875',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'ed0c3d8b-a838-43ef-bae6-fb3adeb380c5',
                  isFolder: false,
                  name: 'SortStack.java',
                  code: 'import java.util.*;\n\npublic class SortStack {\n    static void insertElement(int element, Stack<Integer> s) {\n        if (s.isEmpty() || s.peek() <= element) {\n            s.push(element);\n        } else {\n            int top = s.pop();\n            insertElement(element, s);\n            s.push(top);\n        }\n    }\n\n    static void sortStack(Stack<Integer> s) {\n        if (s.isEmpty()) return;\n        int element = s.pop();\n        sortStack(s);\n        insertElement(element, s);\n    }\n\n    // Utility Method to print contents of stack\n    static void printStack(Stack<Integer> s) {\n        ListIterator<Integer> lt = s.listIterator();\n        // forwarding\n        while (lt.hasNext())\n            lt.next();\n        // printing from top to bottom\n        while (lt.hasPrevious())\n            System.out.print(lt.previous() + " ");\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> s = new Stack<>();\n        s.push(30);\n        s.push(-5);\n        s.push(18);\n        s.push(14);\n        s.push(-3);\n\n        System.out.println("Stack elements before sorting: ");\n        printStack(s);\n        sortStack(s);\n        System.out.println(" \\n\\nStack elements after sorting:");\n        printStack(s);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sort-stack_1229505',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'f1d617c3-280a-4fb9-aeed-61635c45d0af',
                  isFolder: false,
                  name: 'CombinationSum.java',
                  code: 'import java.util.*;\n\npublic class CombinationSum {\n    public static void solve(int[] arr, int target, List<List<Integer>> ans, List<Integer> temp, int idx) {\n        if (arr.length == idx) {\n            if (target == 0) ans.add(new ArrayList<>(temp));\n            return;\n        }\n        if (arr[idx] <= target) {\n            temp.add(arr[idx]);\n            solve(arr, target - arr[idx], ans, temp, idx);\n            temp.remove(temp.size() - 1);\n        }\n        solve(arr, target, ans, temp, idx + 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13,3,2,17};\n        int target = 14;\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, target, ans, new ArrayList<>(), 0);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'bda1383f-f3ed-46bd-85da-836797418749',
                  isFolder: false,
                  name: 'CombinationSum2.java',
                  code: 'import java.util.*;\npublic class CombinationSum2 {\n    public static void solve(int[] arr, int k, int sum, int idx, HashSet<List<Integer>> hs, List<Integer> temp) {\n        if (sum > k || arr.length == idx) return;\n        if (sum == k) {\n            List<Integer> list = new ArrayList<>(temp);\n            Collections.sort(list);\n            hs.add(list);\n            return;\n        }\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i] == arr[i-1]) continue;\n            if (arr[i] > k) return;\n            temp.add(arr[i]);\n            solve(arr, k, sum + arr[i], idx + 1, hs, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public static List<List<Integer>> combinationSum2(int[] arr, int target) {\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n        HashSet<List<Integer>> hs = new HashSet<>();\n        solve(arr, target, 0, 0, hs, new ArrayList<>());\n        return new ArrayList<>(hs);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10,1,2,7,6,1,5};\n        int target = 8;\n        System.out.println(combinationSum2(arr, target));\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum-ii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '58a0d74f-1156-416a-ad4d-e027df120bbd',
                  isFolder: false,
                  name: 'CombinationSum3.java',
                  code: 'import java.util.*;\n\npublic class CombinationSum3 {\n    public static void solve(int k, int n, HashSet<Integer> hs, List<List<Integer>> ans, List<Integer> temp, int idx,\n            HashSet<List<Integer>> ansHs) {\n        if (n < 0)\n            return;\n        if (n == 0) {\n            if (temp.size() == k)\n                ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i <= 9; i++) {\n            if (i > n)\n                return;\n            temp.add(i);\n            solve(k, n - i, hs, ans, temp, i + 1, ansHs);\n            temp.remove(temp.size() - 1);\n        }\n    }\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> ans = new ArrayList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        solve(k, n, hs, ans, new ArrayList<>(), 1, new HashSet<>());\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum-iii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '21f84eb5-50f7-4932-bb3c-06aaeede4ab6',
                  isFolder: false,
                  name: 'GenerateAllBinaryStrings.java',
                  code: 'import java.util.*;\n\npublic class GenerateAllBinaryStrings {\n    public static void getAllStrings(int n, List<String> ans, StringBuilder sb, boolean hadOne) {\n        if (n == 0) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (hadOne) {\n            sb.append(0);\n            getAllStrings(n - 1, ans, sb, false);\n            sb.deleteCharAt(sb.length() - 1);\n        } else {\n            sb.append(0);\n            getAllStrings(n - 1, ans, sb, false);\n            sb.deleteCharAt(sb.length() - 1);\n            sb.append(1);\n            getAllStrings(n - 1, ans, sb, true);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n\n    public static List<String> generateString(int n) {\n        // Write your code here.\n        List<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getAllStrings(n, ans, sb, false);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        List<String> ans = generateString(n);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/-binary-strings-with-no-consecutive-1s._893001',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '922754dc-d925-4d1a-9dd4-f271240b53c3',
                  isFolder: false,
                  name: 'GenerateParentheses.java',
                  code: 'import java.util.*;\n\npublic class GenerateParentheses {\n    public static void solve(int n, List<String> ans, StringBuilder sb, int closeCount, int openCount) {\n        if (openCount == n && closeCount == n) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (openCount < n) {\n            sb.append("(");\n            solve(n, ans, sb, closeCount, openCount + 1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        if (closeCount < openCount) {\n            sb.append(")");\n            solve(n, ans, sb, closeCount + 1, openCount);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n    public static List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        solve(n, ans, sb, 0, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        int n = 3;\n        System.out.println(generateParenthesis(n));\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/generate-all-parenthesis_920445',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'a5b3f48a-eaf0-41c3-b06f-fb3261a7f183',
                  isFolder: false,
                  name: 'MoreSubsequences.java',
                  code: '// Link: https://www.codingninjas.com/studio/problems/more-subsequence_8842355\nimport java.util.*;\npublic class MoreSubsequences {\n    public static void solve(String s, StringBuilder sb, HashSet<String> ans, int idx) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        solve(s, sb, ans, idx + 1);\n\n        sb.append(s.charAt(idx));\n        solve(s, sb, ans, idx + 1);\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    public static int generateSubsequences(String s) {\n        // Write your code here\n        HashSet<String> ans = new HashSet<>();\n        solve(s, new StringBuilder(), ans, 0);\n        return ans.size();\n    }\n\n    public static String moreSubsequence(int n, int m, String a, String b) {\n        // Write your code here\n        return generateSubsequences(a) >= generateSubsequences(b) ? a : b;\n    }\n\n    public static void main(String[] args) {\n        String ans = moreSubsequence(9, 9, "cbfbdhcac", "bcbcfbeag");\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '3f2ff5f1-c94c-4b47-9110-a4358501ce4e',
                  isFolder: false,
                  name: 'PhoneKeypadCombination.java',
                  code: 'import java.util.*;\n\npublic class PhoneKeypadCombination {\n   public List<String> letterCombinations(String s) {\n        List<String> ans = new ArrayList<>();\n        if (s.length() == 0) return ans;\n        String[] mappings = {"", "", "abc","def", "ghi", "jkl","mno", "pqrs", "tuv","wxyz"};\n        solve(s, 0, ans, new StringBuilder(), mappings);\n        return ans;\n    }\n    void solve(String s, int idx, List<String> ans, StringBuilder sb, String[] mappings) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        char ch = s.charAt(idx);\n        String map = mappings[ch - \'0\'];\n        for (int i = 0; i < map.length(); i++) {\n            sb.append(map.charAt(i));\n            solve(s, idx + 1, ans, sb, mappings);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'd01a980a-5061-4e6c-984a-a0a8218d17a5',
                  isFolder: false,
                  name: 'SubarraysWithKSum.java',
                  code: 'import java.util.*;\n\npublic class SubarraysWithKSum {\n    public static void solve(int[] arr, long k, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        if (idx == arr.length) {\n            if (k == 0) ans.add(new ArrayList<>(temp));\n            return;\n        }\n        temp.add(arr[idx]);\n        solve(arr, k - arr[idx], idx + 1, ans, temp);\n        temp.remove(temp.size() - 1);\n        solve(arr, k, idx + 1, ans, temp);\n    }\n\n//    Count total subsequences\n    public static int solveCount(int[] arr, long k, int sum, int idx) {\n        if (sum > k || idx == arr.length && sum != k) return 0;\n        if (sum == k) return 1;\n        return solveCount(arr, k, sum + arr[idx], idx + 1) + solveCount(arr, k, sum, idx + 1);\n    }\n\n    public static void subArraysWithSumK(int[] arr, long k) {\n        // Write your code here\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(arr);\n        solve(arr, k, 0, ans, new ArrayList<>());\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 1, 1, 1};\n        long k = 3;\n        subArraysWithSumK(arr, k);\n    }\n}',
                  link: "https://www.codingninjas.com/studio/problems/subarrays-with-sum-%E2%80%98k'_6922076",
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '582909e9-627e-4c01-851e-8df5b8a237f5',
                  isFolder: false,
                  name: 'SubsetSum.java',
                  code: '//  Link: https://www.codingninjas.com/studio/problems/subset-sum_3843086\n\nimport java.util.ArrayList;\n\npublic class SubsetSum {\n    public static void solve(int[] arr, int idx, int sum, ArrayList<Integer> ans) {\n        if (idx == arr.length) {\n            ans.add(sum);\n            return;\n        }\n        // Exclude\n        solve(arr, idx + 1, sum, ans);\n        // Include\n        solve(arr, idx + 1, sum + arr[idx], ans);\n    }\n    public static ArrayList<Integer> subsetSum(int nums[]) {\n        // Write your code here..\n        ArrayList<Integer> ans = new ArrayList<>();\n        solve(nums, 0, 0, ans);\n        ans.sort(null);\n        return ans;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '4f7c8416-8f82-41db-9582-f10a4db4fae8',
                  isFolder: false,
                  name: 'SubsetSum2.java',
                  code: 'import java.util.*;\npublic class SubsetSum2 {\n    public static void solve(int[] arr, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        ans.add(new ArrayList<>(temp));\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i - 1] == arr[i]) continue;\n            temp.add(arr[i]);\n            solve(arr, i + 1, ans, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(nums, 0, ans, new ArrayList<>());\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/subsets-ii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'dfe2bccb-b273-4bb0-94f8-c1bcaf00d10a',
                  isFolder: false,
                  name: 'ExpressionAddOperators.java',
                  code: 'import java.util.*;\n\npublic class ExpressionAddOperators {\n    public static List<String> addOperators(String num, int target) {\n        List<String> ans = new ArrayList<>();\n        if (num == null || num.length() == 0) return ans;\n        solve(target, num, ans, "", 0, 0, 0);\n        return ans;\n    }\n\n    static void solve(int target, String num, List<String> ans, String path, int idx, long res, long prev) {\n        if (idx == num.length()) {\n            if (res == target) ans.add(path);\n            return;\n        }\n        for (int i = idx; i < num.length(); i++) {\n            if (i != idx && num.charAt(idx) == \'0\') break;\n            long curr = Long.parseLong(num.substring(idx, i+1));\n            if (idx == 0)\n                solve(target, num, ans, path + curr, i + 1, curr, curr);\n            else {\n                solve(target, num, ans, path + "+" + curr, i + 1, res + curr, curr);\n                solve(target, num, ans, path + "-" + curr, i + 1, res - curr, -curr);\n                solve(target, num, ans, path + "*" + curr, i + 1, res - prev + prev * curr, prev * curr);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String num = "232";\n        int target = 8;\n        System.out.println(addOperators(num, target));\n    }\n}',
                  link: 'https://leetcode.com/problems/expression-add-operators/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '9cd50226-a398-451c-b5c3-6991997a1acc',
                  isFolder: false,
                  name: 'MNodesColoring.java',
                  code: 'public class MNodesColoring {\n    public static boolean isPossible(int[][] mat, int node, int n, int[] colors, int color) {\n        for (int i = 0; i < n; i++) {\n            if (mat[node][i] == 1 && color == colors[i]) return false;\n        }\n        return true;\n    }\n    public static boolean solve(int[][] mat, int m, int node, int n, int[] colors) {\n        if (node == n) return true;\n        for (int i = 1; i <= m; i++) {\n            if (isPossible(mat, node, n, colors, i)) {\n                colors[node] = i;\n                if (solve(mat, m, node + 1, n, colors)) return true;\n                colors[node] = 0;\n            }\n        }\n        return false;\n    }\n    public static String graphColoring(int [][]mat, int m) {\n        // Write your code here\n        int n = mat.length;\n        return solve(mat, m, 0, n, new int[n]) ? "YES" : "NO";\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/m-coloring-problem_981273',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '2f368cef-83a7-4a29-be98-deee27554eb6',
                  isFolder: false,
                  name: 'NQueensProblem.java',
                  code: 'import java.util.Arrays;\n\npublic class NQueensProblem {\n\n    public static boolean safeToPlace(int i, int j, int[][] mat) {\n        int row = i, col = j;\n        while (row >= 0 && col >= 0) if (mat[row--][col--] == 1) return false;\n        row = i;\n        col = j;\n        while (col >= 0) if (mat[row][col--] == 1) return false;\n        col = j;\n        while (row < mat.length && col >= 0) if (mat[row++][col--] == 1) return false;\n        return true;\n    }\n\n    public static boolean solve(int[][] board, int col) {\n        if (col == board.length) {\n            for (int[] row : board)\n                System.out.println(Arrays.toString(row));\n            return true;\n        }\n\n        for (int row = 0; row < board.length; row++) {\n            if (safeToPlace(row, col, board)) {\n                board[row][col] = 1;\n                if (solve(board, col + 1)) return true;\n                board[row][col] = 0;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        int[][] board = new int[n][n];\n        solve(board, 0);\n    }\n}',
                  link: 'https://leetcode.com/problems/n-queens/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '3f80aecb-a7f0-4e0d-bd52-db60402c2cbd',
                  isFolder: false,
                  name: 'PalindromePartitioning.java',
                  code: 'import java.util.*;\npublic class PalindromePartitioning {\n    boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n\n    void solve(String s, List<List<String>> ans, List<String> temp, int idx) {\n        if (idx == s.length()) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            if (!isPalindrome(s, idx, i)) continue;\n            temp.add(s.substring(idx, i+1));\n            solve(s, ans, temp, i + 1);\n            temp.remove(temp.size() - 1);\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> ans = new ArrayList<>();\n        solve(s, ans, new ArrayList<>(), 0);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-partitioning/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'fb10f92c-194d-4e64-bbbe-00d1211af19d',
                  isFolder: false,
                  name: 'RatInAMaze.java',
                  code: 'import java.util.*;\n\npublic class RatInAMaze {\n    public static void func(int[][] mat, int i, int j, String path, List<String> paths, String directions, int[] di, int[] dj, boolean[][] visited) {\n        int m = mat.length; // rows\n        int n = mat[0].length; // cols\n        if (i < 0 || j < 0 || j >= n || i >= m || mat[i][j] == 0 || visited[i][j]) return;\n        if (i == m - 1 && j == n - 1) {\n            paths.add(path);\n            return;\n        }\n        for (int x = 0; x < 4; x++) {\n            visited[i][j] = true;\n            func(mat, i + di[x], j + dj[x], path + directions.charAt(x), paths, directions, di, dj, visited);\n            visited[i][j] = false;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 0, 0, 0},\n                {1, 1, 0, 1},\n                {1, 1, 0, 0},\n                {0, 1, 1, 1},\n        };\n        List<String> paths = new ArrayList<>();\n        boolean[][] visited = new boolean[mat.length][mat[0].length];\n        String directions = "DLRU";\n        int[] di = {1, 0, 0, -1};\n        int[] dj = {0, -1, 1, 0};\n        func(mat, 0, 0, "", paths, directions, di, dj, visited);\n        System.out.println(paths);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/rat-in-a-maze-_8842357',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'aeab4e10-2997-4ca3-8d8d-303a9f03f6aa',
                  isFolder: false,
                  name: 'SudokuSolver.java',
                  code: "public class SudokuSolver {\n    public static void printBoard(char[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            if (i % 3 == 0 && i != 0) {\n                System.out.println(\"- - - - - - - - - - - - - \");\n            }\n            for (int j = 0; j < board[i].length; j++) {\n                if (j % 3 == 0 && j != 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(board[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static boolean isPossible(char[][] board, int r, int c, char ch) {\n        for (int i = 0; i < 9; i++) {\n            if (board[r][i] == ch || board[i][c] == ch) return false;\n        }\n        int row = r / 3;\n        int col = c / 3;\n        for (int i = row * 3; i < (row + 1) * 3; i++) {\n            for (int j = col * 3; j < (col + 1) * 3; j++) {\n                if (board[i][j] == ch) return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean solve(char[][] board) {\n        for (int row = 0; row < board.length; row++) {\n            for (int col = 0; col < board[row].length; col++) {\n                if (board[row][col] == '.') {\n                    for (char ch = '1'; ch <= '9'; ch++) {\n                        if (isPossible(board, row, col, ch)) {\n                            board[row][col] = ch;\n                            if (solve(board)) return true;\n                            board[row][col] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void solveSudoku(char[][] board) {\n        if (solve(board)) {\n            printBoard(board);\n        };\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},\n                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},\n                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},\n                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},\n                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},\n                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},\n                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},\n                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},\n                {'.', '.', '.', '.', '8', '.', '.', '7', '9'}\n        };\n        solveSudoku(board);\n    }\n}",
                  link: 'https://leetcode.com/problems/sudoku-solver/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'b4b364d4-81b9-4d8c-80cc-99fc64d75edd',
                  isFolder: false,
                  name: 'WordBreak.java',
                  code: 'import java.util.List;\n\npublic class WordBreak {\n    static boolean check(String s, String b) {\n        return s.length() >= b.length() && s.startsWith(b);\n    }\n\n    static boolean solve(String s, List<String> words, int idx, int[] dp) {\n        if (idx == s.length())\n            return true;\n        for (int i = 0; i < words.size(); i++) {\n            if (!check(s.substring(idx), words.get(i)))\n                continue;\n            int x = idx + words.get(i).length();\n            if (dp[x] == 0 ? solve(s, words, x, dp) : dp[x] > 0)\n                return true;\n            dp[x] = -1;\n        }\n        return false;\n    }\n\n    public boolean wordBreak(String s, List<String> words) {\n        int[] dp = new int[s.length() + 1];\n        return solve(s, words, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/word-break/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '28983f3d-e9da-41c9-8dff-2018da09eaea',
                  isFolder: false,
                  name: 'WordSearch.java',
                  code: "public class WordSearch {\n    static boolean solve(String word, int idx, int i, int j, int[] dx, int[] dy, boolean[][] visited, char[][] board) {\n        if (idx == word.length()) return true;\n        char ch = word.charAt(idx);\n        if (i < 0 || j < 0 || i == board.length || j == board[0].length || visited[i][j] || board[i][j] != ch) return false;\n        System.out.println(board[i][j]);\n        for (int x = 0; x < 4; x++) {\n            visited[i][j] = true;\n            if (solve(word, idx + 1, i + dx[x], j + dy[x], dx, dy, visited, board)) {\n                return true;\n            }\n            visited[i][j] = false;\n        }\n        return false;\n    }\n\n    public static boolean exist(char[][] board, String word) {\n        // DLRU\n        int[] dx = {0, -1, 1, 0};\n        int[] dy = {1, 0, 0, -1};\n        boolean[][] visited = new boolean[board.length][board[0].length];\n\n        char ch = word.charAt(0);\n        for (int i = 0; i < board.length; i++)\n            for (int j = 0; j < board[i].length; j++)\n                if (board[i][j] == ch && solve(word, 0, i, j, dx, dy, visited, board)) return true;\n        return false;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n                {'A', 'B', 'C', 'E'},\n                {'S', 'F', 'C', 'S'},\n                {'A', 'D', 'E', 'E'}\n        };\n        String word = \"ABCCED\";\n        System.out.println(exist(board, word));\n    }\n}",
                  link: 'https://leetcode.com/problems/word-search/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
              ],
            },
            {
              id: '336e5b49-b451-47bc-bf90-81f0fb4c7c02',
              isFolder: true,
              name: 'Sliding Window & Two Pointer Combined Problems',
              content: [
                {
                  id: '1f620a00-3321-4153-acc8-95c7d6f423cd',
                  isFolder: false,
                  name: 'LongestSubstringwithAtMostKDistinctCharacters.java',
                  code: "public class LongestSubstringwithAtMostKDistinctCharacters {\n    public static int kDistinctChars(int k, String str) {\n        // Write your code here\n        int[] count = new int[26];\n        int i = 0, j = 0, unique = 0, maxLength = 0;\n        while (j < str.length()) {\n            int idx1 = str.charAt(j) - 'a';\n            count[idx1]++;\n            if (count[idx1] == 1) unique++;\n            while (unique > k) {\n                int idx2 = str.charAt(i++) - 'a';\n                count[idx2]--;\n                if (count[idx2] == 0) unique--;\n            }\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/longest-substring-with-at-most-k-distinct-characters_2221410',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '8eeae189-5597-471b-bfc6-6f541ec48ae0',
                  isFolder: false,
                  name: 'MinimumWindowSubsequence.java',
                  code: 'import java.util.*;\n\npublic class MinimumWindowSubsequence {\n    public static String minWindow(String s, String t) {\n        // Write your code here\n        int i = 0, j = 0, start, end, minLength = s.length() + 1, subStart = 0;\n        while (i < s.length() && j < t.length()) {\n            if (s.charAt(i) == t.charAt(j)) {\n                if (j == t.length() - 1) {\n                    end = i;\n                    while (j >= 0) {\n                        if (s.charAt(i) == t.charAt(j)) j--;\n                        i--;\n                    }\n                    start = i + 1;\n                    int size = end - start + 1;\n                    if (minLength > size) {\n                        minLength = size;\n                        subStart = start;\n                    }\n                    j = 0;\n                    i++;\n                } else j++;\n            }\n            i++;\n        }\n        return minLength > s.length() ? "" : s.substring(subStart, subStart + minLength);\n\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-window-subsequence_2181133',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '56da1b73-ac27-462e-b506-9f68120be5a6',
                  isFolder: false,
                  name: 'MinimumWindowSubstring.java',
                  code: 'import java.util.*;\n\npublic class MinimumWindowSubstring {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < t.length(); i++) {\n            char ch = t.charAt(i);\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n        }\n        int start = 0, subStart = 0, minLength = s.length() + 1, match = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char ch1 = s.charAt(end);\n            if (map.containsKey(ch1)) {\n                map.put(ch1, map.get(ch1) - 1);\n                if (map.get(ch1) == 0) match++;\n            }\n            while (match == map.size()) {\n                int size = end - start + 1;\n                if (minLength > size) {\n                    minLength = size;\n                    subStart = start;\n                }\n                char ch2 = s.charAt(start);\n                if (map.containsKey(ch2)) {\n                    map.put(ch2, map.get(ch2) + 1);\n                    if (map.get(ch2) == 1) match--;\n                }\n                start++;\n            }\n        }\n        return minLength > s.length() ? "" : s.substring(subStart, subStart + minLength);\n    }\n}',
                  link: 'https://leetcode.com/problems/minimum-window-substring/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '8fc77535-06fd-437b-9ffb-e2eb530f9c81',
                  isFolder: false,
                  name: 'SubarrayswithKDifferentIntegers.java',
                  code: 'public class SubarrayswithKDifferentIntegers {\n    public static int atmost(int[] nums, int k) {\n        int[] bucket = new int[nums.length + 1];\n        int i = 0, j = 0, unique = 0, count = 0;\n        while (j < nums.length) {\n            int idx1 = nums[j];\n            bucket[idx1]++;\n            if (bucket[idx1] == 1) unique++;\n            while (unique > k) {\n                int idx2 = nums[i++];\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) unique--;\n            }\n            count += j - i + 1;\n            j++;\n        }\n        return count;\n    }\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atmost(nums, k) - atmost(nums, k - 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/subarrays-with-k-different-integers/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'c69efb3f-8bd3-4fb3-9b1e-7dbdaee40ade',
                  isFolder: false,
                  name: 'BinarySubArraysWithSum.java',
                  code: 'import java.util.*;\npublic class BinarySubArraysWithSum {\n    public static int atmost(int[] nums, int goal) {\n        int sum = 0, i = 0, j = 0, count = 0;\n        while (j < nums.length) {\n            sum += nums[j];\n            while (i <= j && sum > goal) {\n                sum -= nums[i];\n                i++;\n            }\n            count += j - i + 1;\n            j++;\n        }\n        return count;\n    }\n    public int numSubarraysWithSum(int[] nums, int goal) {\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        hm.put(0, 1);\n//        int sum = 0, count = 0;\n//        for (int i = 0; i < nums.length; i++) {\n//            sum += nums[i];\n//            if (hm.containsKey(sum - goal))\n//                count += hm.get(sum - goal);\n//            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n//        }\n//        return count;\n        return atmost(nums, goal) - atmost(nums, goal - 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-subarrays-with-sum/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '2180e94f-6f08-4520-b85e-01fdc79e18c4',
                  isFolder: false,
                  name: 'CountNumberOfNiceSubArrays.java',
                  code: 'import java.util.*;\n\npublic class CountNumberOfNiceSubArrays {\n    public static int atmost(int[] nums, int goal) {\n        int sum = 0, i = 0, j = 0, count = 0;\n        while (j < nums.length) {\n            sum += nums[j]%2;\n            while (i <= j && sum > goal) {\n                sum -= nums[i]%2;\n                i++;\n            }\n            count += j - i + 1;\n            j++;\n        }\n        return count;\n    }\n    public int numberOfSubarrays(int[] nums, int k) {\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        hm.put(0, 1);\n//        int sum = 0, count = 0;\n//        for (int i = 0; i < nums.length; i++) {\n//            sum += nums[i]%2 == 0 ? 0 : 1;\n//            if (hm.containsKey(sum - k))\n//                count += hm.get(sum - k);\n//            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n//        }\n//        return count;\n        return atmost(nums, k) - atmost(nums, k - 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/count-number-of-nice-subarrays/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'e8a87609-e577-4089-9bf0-c7e764dc82e1',
                  isFolder: false,
                  name: 'FruitIntoBaskets.java',
                  code: 'import java.util.*;\n\npublic class FruitIntoBaskets {\n    public static int findMaxFruits(int[] arr, int n) {\n        // Write your code here.\n        int i = 0, j = 0, count = 0, maxCount = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        while (j < n) {\n            hm.put(arr[j], hm.getOrDefault(arr[j], 0) + 1);\n            count++;\n            while (hm.size() > 2) {\n                int c = hm.get(arr[i]);\n                if (c == 1) hm.remove(arr[i]);\n                else hm.put(arr[i], c - 1);\n                count--;\n                i++;\n            }\n            maxCount = Math.max(maxCount, count);\n            j++;\n        }\n        return maxCount;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/fruits-and-baskets_985356',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '140e2839-15b5-4fa3-8686-1f6590f78c98',
                  isFolder: false,
                  name: 'LongestRepeatingCharacterReplacement.java',
                  code: "public class LongestRepeatingCharacterReplacement {\n    public static int getMaxFrequency(int[] arr) {\n        int maxFrequency = 0;\n        for (int i = 0; i < 26; i++)\n            maxFrequency = Math.max(maxFrequency, arr[i]);\n        return maxFrequency;\n    }\n    public int characterReplacement(String s, int k) {\n        int[] bucket = new int[26];\n        int i = 0, j = 0, maxLength = 0;\n        while (j < s.length()) {\n            int idx = s.charAt(j) - 'A';\n            bucket[idx]++;\n            while (j-i+1 - getMaxFrequency(bucket) > k)\n                bucket[s.charAt(i++) - 'A']--;\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/longest-repeating-character-replacement/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '151dbdb2-0acb-4cff-99fd-f2e6ccb9b221',
                  isFolder: false,
                  name: 'LongestSubStringWithoutRepeatingCharacters.java',
                  code: "import java.util.*;\npublic class LongestSubStringWithoutRepeatingCharacters {\n    public int lengthOfLongestSubstring(String s) {\n//        HashMap<Character, Integer> hm = new HashMap<>();\n//        int i = 0, j = 0, maxLength = 0;\n//        while (j < s.length()) {\n//            char ch = s.charAt(j);\n//            hm.put(ch, hm.getOrDefault(ch, 0) + 1);\n//            while (hm.size() < j - i + 1) {\n//                char ch2 = s.charAt(i);\n//                int c = hm.get(ch2);\n//                if (c == 1) hm.remove(ch2);\n//                else hm.put(ch2, c - 1);\n//                i++;\n//            }\n//            if (hm.size() == j - i + 1)\n//                maxLength = Math.max(maxLength, j - i + 1);\n//            j++;\n//        }\n//        return maxLength;\n//        Could have used a HashMap as well\n        int[] bucket = new int[128];\n        int i = 0, j = 0, unique = 0, maxLength = 0;\n        while (j < s.length()) {\n            int idx = s.charAt(j) - ' ';\n            bucket[idx]++;\n            if (bucket[idx] == 1) unique++;\n            while (unique < j - i + 1) {\n                int idx2 = s.charAt(i) - ' ';\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) unique--;\n                i++;\n            }\n            if (unique == j - i + 1) {\n                maxLength = Math.max(maxLength, j - i + 1);\n            }\n            j++;\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/longest-substring-without-repeating-characters/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'e0951641-4dcf-44d1-89ad-e1cd43f71005',
                  isFolder: false,
                  name: 'MaximumConsecutiveOnes3.java',
                  code: 'public class MaximumConsecutiveOnes3 {\n    public int longestOnes(int[] nums, int k) {\n        int i = 0, j = 0, maxLength = 0, flips = 0;\n        while (j < nums.length) {\n            if (nums[j] == 0) flips++;\n            while (flips > k) if (nums[i++] == 0) flips--;\n//            if (flips <= k)\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}',
                  link: 'https://leetcode.com/problems/max-consecutive-ones-iii/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'bab357f8-f3c3-48fb-8aec-6d0e0da80400',
                  isFolder: false,
                  name: 'MaximumPointsFromCards.java',
                  code: 'public class MaximumPointsFromCards {\n    public int maxScore(int[] cardPoints, int k) {\n//        O(N)\n//        int n = cardPoints.length, sum = 0, i = 0, j = n - k;\n//        for (int point = j; point < n; point++)\n//            sum += cardPoints[point];\n//        int res = sum;\n//        while (j < n) {\n//            sum += cardPoints[i++] - cardPoints[j++];\n//            res = Math.max(res, sum);\n//        }\n//        return res;\n\n//        O(2N)\n        int n = cardPoints.length, totalSum = 0;\n        for (int point : cardPoints) totalSum += point;\n        if (k == n) return totalSum;\n\n        int window = 0, i = 0, j = 0, sum = 0, size = n - k;\n        while (j < n) {\n            window += cardPoints[j];\n            if (j - i + 1 == size) {\n                sum = Math.max(sum, totalSum - window);\n                window -= cardPoints[i++];\n            }\n            j++;\n        }\n        return sum;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '61348a68-a27a-4d44-a1ac-948be0a47b3d',
                  isFolder: false,
                  name: 'NumberOfSubStringsContainingAll3Characters.java',
                  code: "public class NumberOfSubStringsContainingAll3Characters {\n    public static int countSubstring(String s){\n        // Write your code here.\n//        int count = 0;\n//        int i = 0, j = 0;\n//        int[] arr = {0, 0, 0};\n//        while (j < s.length()) {\n//            arr[s.charAt(j) - 'a']++;\n//            while (arr[0] > 0 && arr[1] > 0 && arr[2] > 0) {\n//                arr[s.charAt(i) - 'a']--;\n//                i++;\n//            }\n//            count += i;\n//            j++;\n//        }\n//        return count;\n        int count = 0;\n        int idx_a = -1, idx_b = -1, idx_c = -1;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == 'a') {\n                idx_a = i;\n            }\n            else if (ch == 'b') {\n                idx_b = i;\n            }\n            else if (ch == 'c') {\n                idx_c = i;\n            }\n            count += Math.min(idx_a, Math.min(idx_b, idx_c))+1;\n        }\n        return count;\n    }\n}",
                  link: 'https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
              ],
            },
            {
              id: 'd1e93191-d09c-4656-a033-02a0cd27c0e9',
              isFolder: true,
              name: 'Stacks and Queues',
              content: [
                {
                  id: 'd03f214c-71e3-42a8-8e71-21be2c2b7a69',
                  isFolder: false,
                  name: 'CelebrityProblem.java',
                  code: 'import java.util.*;\n\npublic class CelebrityProblem {\n    int celebrity(int[][] M, int n) {\n        // code here\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            stack.push(i);\n        }\n        while (stack.size() > 1) {\n            int p1 = stack.pop();\n            int p2 = stack.pop();\n            if (M[p1][p2] == 1) {\n                stack.push(p2);\n            } else if (M[p2][p1] == 1) {\n                stack.push(p1);\n            }\n        }\n        int celeb = stack.pop();\n        // verify celeb\n        for (int i = 0; i < n; i++) {\n            if (i != celeb && M[i][celeb] == 0) return -1;\n            if (i != celeb && M[celeb][i] == 1) return -1;\n        }\n        return celeb;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/the-celebrity-problem_982769',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: 'cf3f1d21-4322-4fc3-9592-b373ce0ba80c',
                  isFolder: false,
                  name: 'LFUCache.java',
                  code: 'import java.util.*;\nclass LFUCache {\n    static class Node {\n        int key, value, frequency;\n        Node next;\n        Node prev;\n        Node (int k, int v) {\n            this.key = k;\n            this.value = v;\n            this.next = null;\n            this.prev = null;\n            this.frequency = 1;\n        }\n    }\n    static class DLL {\n        Node head, tail;\n        int size;\n        DLL() {\n            this.head = new Node(-100, -100);\n            this.tail = new Node(-100, -100);\n            this.head.next = this.tail;\n            this.tail.prev = this.head;\n        }\n        void add(Node node) {\n            node.next = head.next;\n            node.prev = head;\n            head.next.prev = node;\n            head.next = node;\n            size += 1;\n        }\n        void remove(Node node) {\n            Node next = node.next;\n            Node prev = node.prev;\n            next.prev = prev;\n            prev.next = next;\n            size -= 1;\n        }\n    }\n    Map<Integer, Node> keyNode;\n    Map<Integer, DLL> freqList;\n    int maxSize;\n    int minFrequency = 1;\n    public LFUCache(int capacity) {\n        keyNode = new HashMap<>();\n        freqList = new HashMap<>();\n        maxSize = capacity;\n    }\n\n    void updateFrequency(Node node) {\n        DLL list = freqList.get(node.frequency);\n        list.remove(node);\n        if (list.size == 0 && node.frequency == minFrequency) minFrequency++;\n        node.frequency += 1;\n        if (freqList.containsKey(node.frequency)) {\n            freqList.get(node.frequency).add(node);\n        } else {\n            DLL newList = new DLL();\n            newList.add(node);\n            freqList.put(node.frequency, newList);\n        }\n    }\n\n    public int get(int key) {\n        if (keyNode.containsKey(key)) {\n            Node node = keyNode.get(key);\n            updateFrequency(node);\n            return node.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (maxSize == 0) return;\n        if (keyNode.containsKey(key)) {\n            Node node = keyNode.get(key);\n            node.value = value;\n            updateFrequency(node);\n        }\n        else {\n            Node node = new Node(key, value);\n            if (keyNode.size() == maxSize) {\n                DLL list = freqList.get(minFrequency);\n                keyNode.remove(list.tail.prev.key);\n                list.remove(list.tail.prev);\n            }\n            minFrequency = 1;\n            if (freqList.containsKey(node.frequency)) {\n                freqList.get(node.frequency).add(node);\n            } else {\n                DLL newList = new DLL();\n                newList.add(node);\n                freqList.put(node.frequency, newList);\n            }\n            keyNode.put(node.key, node);\n        }\n    }\n}\n\n/*\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */',
                  link: 'https://leetcode.com/problems/lfu-cache/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '1c15bada-72c5-48b5-a536-c9d70b8151f7',
                  isFolder: false,
                  name: 'LRUCache.java',
                  code: 'import java.util.*;\n\nclass LRUCache {\n    static class Node {\n        int key;\n        int value;\n        Node next;\n        Node prev;\n        Node (int key, int value)  {\n            this.next = null;\n            this.prev = null;\n            this.key = key;\n            this.value = value;\n        }\n    }\n    Node head = new Node(-1,-1);\n    Node tail = new Node(-1,-1);\n    int capacity;\n    HashMap<Integer, Node> hm = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (this.hm.containsKey(key)) {\n            Node temp = this.hm.get(key);\n            delete(temp);\n            insert(temp);\n            return temp.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (this.hm.containsKey(key)) delete(this.hm.get(key));\n        if (this.hm.size() == this.capacity) delete(this.tail.prev);\n        insert(new Node(key, value));\n    }\n\n    public void delete(Node node) {\n        this.hm.remove(node.key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    public void insert(Node node) {\n        this.hm.put(node.key, node);\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n}',
                  link: 'https://leetcode.com/problems/lru-cache/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '4812678e-bcb1-4a32-b7b3-32e6f59417a4',
                  isFolder: false,
                  name: 'SlidingWindowMaximum.java',
                  code: 'import java.util.*;\n\npublic class SlidingWindowMaximum {\n    public static int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> q = new ArrayDeque<>();\n        int[] ans = new int[nums.length - k + 1];\n        int i = 0, j = 0;\n        while (j < nums.length) {\n            while (!q.isEmpty() && nums[q.peekLast()] < nums[j]) q.pollLast();\n            q.offer(j);\n            if (j - i + 1 == k) {\n                if (q.peekFirst() < i) q.pollFirst();\n                ans[i] = nums[q.peekFirst()];\n                i++;\n            }\n            j++;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, -1, -3, 5, 3, 6, 7};\n        int[] ans = maxSlidingWindow(arr, 3);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: 'https://leetcode.com/problems/sliding-window-maximum/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '3eaa7a7f-4ee2-4964-b2fb-ccf2ac610e7c',
                  isFolder: false,
                  name: 'StockSpanner.java',
                  code: 'import java.util.*;\nclass StockSpanner {\n    static class Pair {\n        int first, second;\n        Pair(int a, int b) {\n            this.first = a;\n            this.second = b;\n        }\n    }\n    static Stack<Pair> stack;\n    public StockSpanner() {\n        stack = new Stack<>();\n    }\n    \n    public int next(int price) {\n        if (stack.isEmpty()) {\n            Pair temp = new Pair(price, 1);\n            stack.add(temp);\n            return 1;\n        }\n        int val = 1;\n        while (!stack.isEmpty() && stack.peek().first <= price) {\n            val += stack.pop().second;\n        }\n        stack.push(new Pair(price, val));\n        return val;\n    }\n\n    public static void main(String[] args) {\n        StockSpanner obj = new StockSpanner();\n        int[] arr = {100, 80, 60, 70, 60, 75, 85};\n        int[] ans = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            ans[i] = obj.next(arr[i]);\n        }\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: 'https://leetcode.com/problems/online-stock-span/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '2aaf789e-ad29-4fff-9242-5e2ff89a24ad',
                  isFolder: false,
                  name: 'MinStack.java',
                  code: 'import java.util.*;\n\npublic class MinStack {\n    Stack<Integer> stack;\n    Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        minStack.push(minStack.isEmpty() ? val : Math.min(minStack.peek(), val));\n    }\n\n    public void pop() {\n        stack.pop();\n        minStack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}',
                  link: 'https://leetcode.com/problems/min-stack/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '9f311ed5-b6ab-44e6-93cb-d9616f01b71c',
                  isFolder: false,
                  name: 'QueueUsingArray.java',
                  code: "public class QueueUsingArray {\n    class Queue {\n        int front, rear;\n        int []arr;\n\n        Queue() {\n            front = 0;\n            rear = 0;\n            arr = new int[100001];\n        }\n\n        // Enqueue (add) element 'e' at the end of the queue.\n        public void enqueue(int e) {\n            // Write your code here.\n            if (rear < arr.length) {\n                arr[rear++] = e;\n            }\n        }\n\n        // Dequeue (retrieve) the element from the front of the queue.\n        public int dequeue() {\n            // Write your code here.\n            if (front < rear) {\n                return arr[front++];\n            }\n            return -1;\n        }\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/implement-queue-using-arrays_8390825',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '1e732439-1be9-461e-90c3-42491eac5dc9',
                  isFolder: false,
                  name: 'QueueUsingLinkedList.java',
                  code: 'class Node {\n    public int data;\n    public Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n};\n\nclass MQueue{\n    Node front;\n    Node rear;\n    void push(){};\n    MQueue() {\n        front = null;\n        rear = null;\n    }\n}\n\npublic class QueueUsingLinkedList extends MQueue {\n    public void push(int x) {\n        // Write Your Code Here\n        Node newNode = new Node(x);\n        if (front == null && rear == null) {\n            front = newNode;\n            rear = newNode;\n        } else {\n            rear.next = newNode;\n            rear = rear.next;\n        }\n    }\n\n    public int pop() {\n        // Write Your Code Here\n        if (front == null || rear == null) return -1;\n        Node temp = front;\n        if (front == rear) {\n            front = null;\n            rear = null;\n        } else {\n            front = front.next;\n        }\n        return temp.data;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/implement-queue-using-linked-list_8161235',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '9509bf65-c02c-4562-9d00-b027fed0c0d3',
                  isFolder: false,
                  name: 'QueueUsingStack.java',
                  code: 'import java.util.*;\n\npublic class QueueUsingStack {\n    class MyQueue {\n        Stack<Integer> s1;\n        Stack<Integer> s2;\n\n        public MyQueue() {\n            s1 = new Stack<>();\n            s2 = new Stack<>();\n        }\n\n        public void push(int x) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n            s1.push(x);\n            while (!s2.isEmpty()) {\n                s1.push(s2.pop());\n            }\n        }\n\n        public int pop() {\n            return this.s1.pop();\n        }\n\n        public int peek() {\n            return this.s1.peek();\n        }\n\n        public boolean empty() {\n            return this.s1.isEmpty();\n        }\n    }\n\n}',
                  link: 'https://leetcode.com/problems/implement-queue-using-stacks/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'f932ec69-079b-473c-9e28-e95f2995d8c5',
                  isFolder: false,
                  name: 'StackUsingArrays.java',
                  code: 'public class StackUsingArrays {\n    static class Stack {\n        int[] stack;\n        int index;\n        int capacity;\n        Stack(int capacity) {\n            // Write your code here.\n            this.stack = new int[capacity];\n            this.index = -1;\n            this.capacity = capacity;\n        }\n        public void push(int num) {\n            // Write your code here\n            if (this.index != this.capacity - 1) {\n                this.index += 1;\n                this.stack[this.index] = num;\n            }\n        }\n        public int pop() {\n            // Write your code here.\n            if (this.index != -1) {\n                return this.stack[this.index--];\n            }\n            return -1;\n        }\n        public int top() {\n            // Write your code here.\n            if (this.index != -1) {\n                return this.stack[this.index];\n            }\n            return -1;\n        }\n        public int isEmpty() {\n            // Write your code here.\n            return this.index == -1 ? 1 : 0;\n            // false = 0;\n        }\n        public int isFull() {\n            // Write your code here.\n            return this.index == this.capacity - 1 ? 1 : 0;\n        }\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/stack-implementation-using-array_3210209',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '6faefa48-ba38-4e09-b101-d8186e58d64e',
                  isFolder: false,
                  name: 'StackUsingLinkedList.java',
                  code: 'public class StackUsingLinkedList {\n    static class Node {\n        int data;\n        Node next;\n\n        Node() {\n            this.data = 0;\n            this.next = null;\n        }\n\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n\n        Node(int data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n\n    ;\n\n    static class Stack {\n        //Write your code here\n        Node head;\n        Node tail;\n        int length;\n\n        Stack() {\n            head = null;\n            tail = null;\n            length = 0;\n        }\n\n        int getSize() {\n            return this.length;\n        }\n\n        boolean isEmpty() {\n            return this.length == 0;\n        }\n\n        void push(int data) {\n            Node newNode = new Node(data);\n            if (tail == null || head == null) {\n                head = newNode;\n                tail = newNode;\n            } else {\n                tail.next = newNode;\n                tail = tail.next;\n            }\n            length++;\n        }\n\n        void pop() {\n            if (head == tail) {\n                head = null;\n                tail = null;\n                length = 0;\n            } else {\n                Node curr = head;\n                Node prev = null;\n                while (curr.next != null) {\n                    prev = curr;\n                    curr = curr.next;\n                }\n                prev.next = null;\n                tail = prev;\n                length--;\n            }\n        }\n\n        int getTop() {\n            if (tail != null) return tail.data;\n            return -1;\n        }\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/implement-stack-with-linked-list_1279905',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'ab59ff92-af7a-4c97-ab5c-05ce9639dd39',
                  isFolder: false,
                  name: 'StackUsingQueue.java',
                  code: 'import java.util.*;\n\npublic class StackUsingQueue {\n    class MyStack {\n        static Queue<Integer> queue;\n        public MyStack() {\n            queue = new LinkedList<>();\n        }\n\n        public void push(int x) {\n            queue.add(x);\n            for (int i =0; i < queue.size() - 1; i++) {\n                int element = queue.poll();\n                queue.add(element);\n            }\n        }\n\n        public int pop() {\n            return queue.remove();\n        }\n\n        public int top() {\n            return queue.peek();\n        }\n\n        public boolean empty() {\n            return queue.isEmpty();\n        }\n\n    }\n}',
                  link: 'https://leetcode.com/problems/implement-stack-using-queues/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'a1f40991-48c8-45fe-9cc9-aecd9bcd1ecd',
                  isFolder: false,
                  name: 'ValidParentheses.java',
                  code: "import java.util.*;\n\npublic class ValidParentheses {\n    public boolean isValid(String s) {\n        HashMap<Character, Character> hm = new HashMap<>();\n        hm.put('(', ')');\n        hm.put('[', ']');\n        hm.put('{', '}');\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (hm.containsKey(ch)) {\n                stack.push(ch);\n            } else {\n                if (stack.isEmpty()) return false;\n                char element = stack.peek();\n                if (hm.get(element) != ch) return false;\n                stack.pop();\n            }\n        }\n        return stack.isEmpty();\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-parentheses/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '53e74ca3-28bc-4e79-96bc-1702883dee24',
                  isFolder: false,
                  name: 'AsteroidCollision.java',
                  code: 'import java.util.*;\n\npublic class AsteroidCollision {\n    public static boolean sameSign (int i, int j) {\n        return (i > 0 && j > 0) || (i < 0 && j < 0);\n    }\n    public static boolean rulesFollowed(Stack<Integer> stack, int asteroid) {\n        return stack.isEmpty() || stack.peek() > 0 && asteroid > 0 || stack.peek() < 0 && asteroid < 0 || stack.peek() < 0;\n    }\n\n    public static int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n        int idx = 0;\n        while (idx < asteroids.length) {\n            if (rulesFollowed(stack, asteroids[idx])) stack.push(asteroids[idx]);\n            else {\n                int val = Math.abs(asteroids[idx]);\n                if (stack.peek() == val) stack.pop();\n                else if (stack.peek() < val) {\n                    stack.pop();\n                    idx--;\n                }\n            }\n            idx++;\n        }\n        int size = stack.size();\n        int[] ans = new int[size];\n        while (!stack.isEmpty())\n            ans[--size] = stack.pop();\n        return ans;\n//        Stack<Integer> stack = new Stack<>();\n//        int j = -1;\n//        int idx = 0;\n//        while (idx < asteroids.length) {\n//            if (j == -1 || sameSign(asteroids[j], asteroids[idx]) || asteroids[j] < 0)\n//                asteroids[++j] = asteroids[idx];\n//            else {\n//                if (asteroids[j] == Math.abs(asteroids[idx])) {\n//                    asteroids[j] = 0;\n//                    j--;\n//                } else if (asteroids[j] < Math.abs(asteroids[idx])) {\n//                    asteroids[j] = 0;\n//                    j--;\n//                    idx--;\n//                }\n//            }\n//            idx++;\n//        }\n//        int[] ans = new int[j+1];\n//        System.arraycopy(asteroids, 0, ans, 0, j + 1);\n//        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, -2, 1, -2};\n//        int[] arr = {5, -5};\n//        int[] arr = {5, 10, -5};\n        System.out.println(Arrays.toString(asteroidCollision(arr)));\n    }\n}',
                  link: 'https://leetcode.com/problems/asteroid-collision/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: 'df8cadd3-c9ef-4554-bc3e-f46f2b0bc372',
                  isFolder: false,
                  name: 'LargestRectangleInHistogram.java',
                  code: 'import java.util.*;\n\npublic class LargestRectangleInHistogram {\n    public static int[] getPSE(int[] arr, int n) {\n        int[] ans = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n\n    public static int[] getNSE(int[] arr, int n) {\n        int[] ans = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = n;\n        return ans;\n    }\n\n    public static int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        if (n == 1) return heights[0];\n        int[] nse = getNSE(heights, n);\n        int[] pse = getPSE(heights, n);\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            int area = (nse[i] - pse[i] - 1) * heights[i];\n            maxArea = Math.max(maxArea, area);\n        }\n        return maxArea;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {3};\n        System.out.println(largestRectangleArea(heights));\n    }\n}\n\n// [2,1,5,6,2,3]\n//',
                  link: 'https://leetcode.com/problems/largest-rectangle-in-histogram/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: 'c2b5fb72-353b-4cd6-b9f2-2fd370b4a7f0',
                  isFolder: false,
                  name: 'MaximalRectangle.java',
                  code: "import java.util.*;\n\npublic class MaximalRectangle {\n    public static int[] getPSE(char[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n\n    public static int[] getNSE(char[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = n;\n        return ans;\n    }\n\n    public static int largestRectangleArea(char[] heights) {\n        int n = heights.length;\n        int[] nse = getNSE(heights, n), pse = getPSE(heights, n);\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++)\n            maxArea = Math.max(maxArea, (nse[i] - pse[i] - 1) * (heights[i] - '0'));\n        return maxArea;\n    }\n\n    public int maximalRectangle(char[][] M) {\n        int max = largestRectangleArea(M[0]);\n        for (int i = 1; i < M.length; i++) {\n            for (int j = 0; j < M[0].length; j++) {\n                M[i][j] = M[i][j] == '1' ? (char) (M[i][j] + M[i - 1][j] - '0') : '0';\n            }\n            max = Math.max(max, largestRectangleArea(M[i]));\n        }\n        return max;\n    }\n}",
                  link: 'https://leetcode.com/problems/maximal-rectangle/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '3288d9e5-91de-4e91-9b41-ff13b50d99e7',
                  isFolder: false,
                  name: 'NearestSmallerElement.java',
                  code: 'import java.util.*;\npublic class NearestSmallerElement {\n    public int[] prevSmaller(int[] A) {\n        int[] ans = new int[A.length];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = A.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && A[stack.peek()] > A[i])\n                ans[stack.pop()] = A[i];\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n}',
                  link: 'https://www.interviewbit.com/problems/nearest-smaller-element/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '56b534b9-2807-4c3d-bd60-e70bcee92f7a',
                  isFolder: false,
                  name: 'NextGreaterElement.java',
                  code: 'import java.util.*;\npublic class NextGreaterElement {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int[] ans = new int[nums1.length];\n        for (int i = 0; i < nums1.length; i++) {\n            hm.put(nums1[i], i);\n            ans[i] = -1;\n        }\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < nums2.length; i++) {\n            while (!stack.isEmpty() && nums2[i] > stack.peek())\n                ans[hm.get(stack.pop())] = nums2[i];\n            if (hm.containsKey(nums2[i]))\n                stack.push(nums2[i]);\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/next-greater-element-i/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '3e38ed05-7d54-4beb-a560-d3822502554e',
                  isFolder: false,
                  name: 'NextGreaterElement2.java',
                  code: 'import java.util.*;\n\npublic class NextGreaterElement2 {\n    public static int[] nextGreaterElementII(int []a) {\n        // Write your code here.\n        int n = a.length;\n        int[] ans = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < 2 * n; i++) {\n            int idx = i%n;\n            while (!stack.isEmpty() && a[stack.peek()] < a[idx])\n                ans[stack.pop()] = a[idx];\n            if (i < n) stack.push(idx);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/next-greater-element-ii/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '60400cb3-a3eb-46e4-b9fb-3f4352152eb0',
                  isFolder: false,
                  name: 'NGEsToRight.java',
                  code: 'public class NGEsToRight {\n    public static int[] countGreater(int []arr, int []query) {\n        // Write your code here.\n        int[] ans = new int[query.length];\n        for (int i = 0; i < query.length; i++) {\n            int idx = query[i];\n            int c = 0;\n            for (int j = idx+1; j < arr.length; j++) {\n                if (arr[j] > arr[idx]) c++;\n            }\n            ans[i] = c;\n        }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/count-of-greater-elements-to-the-right_8365436',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '1d32b2bb-4647-4fcd-900c-61d35baeb7ef',
                  isFolder: false,
                  name: 'RemoveKDigits.java',
                  code: 'import java.util.*;\npublic class RemoveKDigits {\n    public static String removeKdigits(String num, int k) {\n        if (num.length() <= k) return "0";\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < num.length(); i++) {\n            while (!stack.isEmpty() && k > 0 && num.charAt(i) < stack.peek()) {\n                stack.pop();\n                k--;\n            }\n            stack.push(num.charAt(i));\n        }\n        while (k > 0) {\n            stack.pop();\n            k--;\n        }\n        int size = stack.size();\n        char[] chars = new char[size];\n        while (!stack.isEmpty())\n            chars[--size] = stack.pop();\n        int i = 0;\n        while (i < chars.length && chars[i] == \'0\') i++;\n        if (i == chars.length) return "0";\n        return String.valueOf(chars, i, chars.length - i);\n    }\n\n    public static void main(String[] args) {\n        String s = "1001001";\n        int k = 2;\n        System.out.println(removeKdigits(s, k));\n    }\n}',
                  link: 'https://leetcode.com/problems/remove-k-digits/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '35b10c25-6a55-4160-8cbd-75911f38ffd8',
                  isFolder: false,
                  name: 'SumOfSubArrayMinimum.java',
                  code: 'import java.util.*;\n\npublic class SumOfSubArrayMinimum {\n    public static long solve(int[] arr, int start, long sum) {\n        if (start == arr.length) return sum;\n        int min = Integer.MAX_VALUE;\n        for (int i = start; i < arr.length; i++) {\n            min = Math.min(min, arr[i]);\n            sum += min;\n        }\n        return solve(arr, start + 1, sum);\n    }\n\n    public int sumSubarrayMins(int[] arr) {\n//        O(N^2) solution\n//        return (int) (solve(arr, 0, 0)%1000000007);\n        int n = arr.length;\n        int[] pse = getPSE(arr, n), nse = getNSE(arr, n);\n        long res = 0;\n        for(int i = 0; i < n; i++)\n            res +=  (long) (i - pse[i]) * (nse[i] - i) * arr[i];\n        return (int)(res % (1e9 + 7));\n    }\n\n    public int[] getPSE(int[] arr, int n) {\n        int[] psee = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for(int i = n-1; i >= 0; i--){\n            while(!stk.isEmpty() && arr[i] <= arr[stk.peek()])\n                psee[stk.pop()] = i;\n            stk.push(i);\n        }\n        while(!stk.isEmpty())\n            psee[stk.pop()] = -1;\n        return psee;\n    }\n\n    public int[] getNSE(int[] arr, int n) {\n        int[] nse = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for(int i = 0; i < n; i++){\n            while(!stk.isEmpty() && arr[i] < arr[stk.peek()])\n                nse[stk.pop()] = i;\n            stk.push(i);\n        }\n        while(!stk.isEmpty())\n            nse[stk.pop()] = n;\n        return nse;\n    }\n}',
                  link: 'https://leetcode.com/problems/sum-of-subarray-minimums/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '6c1f1a31-a68b-4177-a32d-f156422aeb1c',
                  isFolder: false,
                  name: 'SumOfSubarrayRanges.java',
                  code: 'import java.util.*;\n\npublic class SumOfSubarrayRanges {\n    public static long solve(int[] arr, int start, long sum) {\n        if (start == arr.length) return sum;\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        for (int i = start; i < arr.length; i++) {\n            min = Math.min(min, arr[i]);\n            max = Math.max(max, arr[i]);\n            sum += max - min;\n        }\n        return solve(arr, start + 1, sum);\n    }\n//    public long subArrayRanges(int[] nums) {\n//        return solve(nums, 0, 0);\n//    }\n\n    public int[] getPSE(int[] arr, int n) {\n        int[] pse = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stk.isEmpty() && arr[i] <= arr[stk.peek()])\n                pse[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            pse[stk.pop()] = -1;\n        return pse;\n    }\n\n    public int[] getPGE(int[] arr, int n) {\n        int[] pge = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stk.isEmpty() && arr[i] >= arr[stk.peek()])\n                pge[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            pge[stk.pop()] = -1;\n        return pge;\n    }\n\n    public int[] getNSE(int[] arr, int n) {\n        int[] nse = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stk.isEmpty() && arr[i] < arr[stk.peek()])\n                nse[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            nse[stk.pop()] = n;\n        return nse;\n    }\n\n    public int[] getNGE(int[] arr, int n) {\n        int[] nge = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stk.isEmpty() && arr[i] > arr[stk.peek()])\n                nge[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            nge[stk.pop()] = n;\n        return nge;\n    }\n\n    public long subArrayRanges(int[] nums) {\n        int n = nums.length;\n        int[] pse = getPSE(nums, n), nse = getNSE(nums, n), pge = getPGE(nums, n), nge = getNGE(nums, n);\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += ((long) (i - nge[i]) * (pge[i] - i) - (long) (i - nse[i]) * (pse[i] - i)) * nums[i];\n        }\n        return sum;\n    }\n}',
                  link: 'https://leetcode.com/problems/sum-of-subarray-ranges/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '76a7da32-0fa5-47f4-ae81-c68134090143',
                  isFolder: false,
                  name: 'TrappingRainwater.java',
                  code: 'public class TrappingRainwater {\n    public int trap(int[] height) {\n//        Takes O(n) extra space\n//        int n = height.length;\n//        int[] left = new int[n], right = new int[n];\n//        int totalWater = 0, maxL = 0, maxR = 0;\n//        for (int i = 0; i < n; i++) {\n//            maxL = Math.max(maxL, height[i]);\n//            maxR = Math.max(maxR, height[n-i-1]);\n//            left[i] = maxL;\n//            right[n-i-1] = maxR;\n//        }\n//        for (int i = 0; i < n; i++)\n//            totalWater += Math.min(left[i], right[i]) - height[i];\n//        return totalWater;\n\n//        Constant space solution\n        int l = 0, r = height.length - 1;\n        int maxL = height[l], maxR = height[r];\n        int total = 0;\n        while (l < r) {\n            if (maxL < maxR) {\n                maxL = Math.max(maxL, height[++l]);\n                total += maxL - height[l];\n            } else {\n                maxR = Math.max(maxR, height[--r]);\n                total += maxR - height[r];\n            }\n        }\n        return total;\n    }\n}',
                  link: 'https://leetcode.com/problems/trapping-rain-water/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '60e3fbcb-5b36-4b34-bff5-9ab8cd26a918',
                  isFolder: false,
                  name: 'InfixToPostfixUsingStack.java',
                  code: "import java.util.*;\npublic class InfixToPostfixUsingStack {\n    public static int pref(char operator) {\n        if (operator == '^') return 3;\n        if (operator == '*' || operator == '/') return 2;\n        if (operator == '+' || operator == '-') return 1;\n        return -1;\n    }\n    public static String infixToPostfix(String exp) {\n        // Write your code here\n        Stack<String> val = new Stack<>();\n        Stack<Character> op = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else if (ch == '(') op.push(ch);\n            else if (ch == ')') {\n                while (op.peek() != '(') {\n                    String val2 = val.pop();\n                    val.push(val.pop() + val2 + op.pop());\n                }\n                op.pop();\n            } else {\n                while (!op.isEmpty() && pref(op.peek()) >= pref(ch)) {\n                    String val2 = val.pop();\n                    val.push(val.pop() + val2 + op.pop());\n                }\n                op.push(ch);\n            }\n        }\n        while (!op.isEmpty()) {\n            String val2 = val.pop();\n            val.push(val.pop() + val2 + op.pop());\n        }\n        return val.peek();\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/day-23-:-infix-to-postfix-_1382146',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: 'd4f909b6-bfe7-456e-aba8-1c0c3d99d4b4',
                  isFolder: false,
                  name: 'InfixToPrefixUsingStack.java',
                  code: "import java.util.Stack;\n\npublic class InfixToPrefixUsingStack {\n    public static int pref(char operator) {\n        if (operator == '^') return 3;\n        if (operator == '*' || operator == '/') return 2;\n        if (operator == '+' || operator == '-') return 1;\n        return -1;\n    }\n    public static String convertInfixToPrefix(String exp) {\n        Stack<String> val = new Stack<>();\n        Stack<Character> op = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else if (ch == '(') op.push(ch);\n            else if (ch == ')') {\n                while (op.peek() != '(') {\n                    String val2 = val.pop();\n                    val.push(op.pop() + val.pop() + val2);\n                }\n                op.pop();\n            } else {\n                while (!op.isEmpty() && pref(ch) <= pref(op.peek())) {\n                    String val2 = val.pop();\n                    val.push(op.pop() + val.pop() + val2);\n                }\n                op.push(ch);\n            }\n        }\n        while (!op.isEmpty()) {\n            String val2 = val.pop();\n            val.push(op.pop() + val.pop() + val2);\n        }\n        return val.peek();\n    }\n}",
                  link: null,
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: 'a744d627-2a28-427c-9a6a-d31dd22c9acf',
                  isFolder: false,
                  name: 'PostfixToInfixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PostfixToInfixUsingStack {\n    public static String postToInfix(String exp) {\n        // Write your code here.\n        Stack<String> val = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else {\n                String val1 = val.pop();\n                val.push("(" + val.pop() + ch + val1 + ")");\n            }\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/postfix-to-infix_8382386',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: '19b69a4d-1f95-4b9f-9f45-236b72107e44',
                  isFolder: false,
                  name: 'PostfixToPrefixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PostfixToPrefixUsingStack {\n    public static String postfixToPrefix(String exp) {\n        // Write your code here\n        Stack<String> val = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else {\n                String val1 = val.pop();\n                val.push(ch + val.pop() + val1);\n            }\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/postfix-to-prefix_1788455',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: '63779b64-714d-452c-b21b-28998d8e8f6a',
                  isFolder: false,
                  name: 'PrefixToInfixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PrefixToInfixUsingStack {\n    public static String prefixToInfixConversion(String exp) {\n        // Write your code here\n        Stack<String> val = new Stack<>();\n        for (int i = exp.length() - 1; i >= 0; i--) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else val.push("(" + val.pop() + ch + val.pop() + ")");\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/prefix-to-infix_1215000',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: 'd94c4ce0-17a1-430f-8934-c5beb89984dd',
                  isFolder: false,
                  name: 'PrefixToPostfixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PrefixToPostfixUsingStack {\n    public static String preToPost(String s) {\n        // Write Your Code Here\n        Stack<String> val = new Stack<>();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char ch = s.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else val.push(val.pop() + val.pop() + ch);\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/convert-prefix-to-postfix_8391014',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
              ],
            },
            {
              id: '42d9e4eb-6d56-4f5c-8ebe-33c96d1ecd46',
              isFolder: true,
              name: 'Strings',
              content: [
                {
                  id: '8e768833-f6ee-4ca6-8c42-17b65cf08a0d',
                  isFolder: false,
                  name: 'IsomorphicStrings.java',
                  code: 'import java.util.*;\n\npublic class IsomorphicStrings {\n    public static boolean isIsomorphic(String s, String t) {\n        //    Brute force\n        //        Instead of char array use Stack array\n\n        //    Optimal approach\n        char[] mapST = new char[128];\n        char[] mapTS = new char[128];\n        for (int i = 0; i < s.length(); i++) {\n            char sChar = s.charAt(i);\n            char tChar = t.charAt(i);\n            if (mapST[sChar] != 0 && mapST[sChar] != tChar\n                    || mapTS[tChar] != 0 && mapTS[tChar] != sChar) {\n                return false;\n            }\n            mapST[sChar] = tChar;\n            mapTS[tChar] = sChar;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        String s = "edd";\n        String t = "add";\n        System.out.println(isIsomorphic(s, t));\n    }\n}',
                  link: 'https://leetcode.com/problems/isomorphic-strings/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '36cab450-87fa-46c5-b0f6-7d633f5477c2',
                  isFolder: false,
                  name: 'LargestOddNumberInString.java',
                  code: 'class LargestOddNumberInString {\n    public String largestOddNumber(String num) {\n        for (int i = num.length() - 1; i >= 0; i--) {\n            int value = num.charAt(i) - \'0\';\n            if (value % 2 == 1) return num.substring(0, i+1);\n        }\n        return "";\n    }\n}',
                  link: 'https://leetcode.com/problems/largest-odd-number-in-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '1b030394-f6d2-4c59-84f1-01f8d6a1ecf7',
                  isFolder: false,
                  name: 'LongestCommonPrefix.java',
                  code: 'import java.util.*;\n\npublic class LongestCommonPrefix {\n    public static String longestCommonPrefix(String[] strs) {\n//        Brute force\n//        Arrays.sort(strs);\n//        String f = strs[0], l = strs[strs.length - 1];\n//        int len = Math.min(f.length(), l.length());\n//        int i = 0;\n//        while (i < len) {\n//            if (f.charAt(i) != l.charAt(i)) break;\n//            i++;\n//        }\n//        return f.substring(0, i);\n//        Optimal solution\n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (!strs[i].startsWith(prefix)) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        String[] strs = {"flower", "flow", "flight"};\n        System.out.println(longestCommonPrefix(strs));\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-common-prefix/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '012d66f5-13cd-4f74-9c3d-f7c4c35ecee8',
                  isFolder: false,
                  name: 'RemoveOutermostParentheses.java',
                  code: "import java.util.*;\n\npublic class RemoveOutermostParentheses {\n    public static String removeOuterParentheses(String s) {\n//        Brute force approach\n//        StringBuilder sb = new StringBuilder();\n//        Stack<Character> stack = new Stack<>();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (ch == '(') {\n//                if (stack.size() > 0) {\n//                    sb.append(ch);\n//                }\n//                stack.push(ch);\n//            } else if (ch == ')') {\n//                stack.pop();\n//                if (stack.size() > 0) {\n//                    sb.append(ch);\n//                }\n//            }\n//        }\n//        return sb.toString();\n\n//        Optimal approach\n        int counter = 0;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') {\n                if (counter > 0) {\n                    sb.append(ch);\n                }\n                counter++;\n            } else if (ch == ')') {\n                if (counter > 1) {\n                    sb.append(ch);\n                }\n                counter--;\n            }\n        }\n        return sb.toString();\n    }\n}",
                  link: 'https://leetcode.com/problems/remove-outermost-parentheses/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'a433d9a9-62fb-482c-a204-4c474713989a',
                  isFolder: false,
                  name: 'ReverseWordsInAString.java',
                  code: 'public class ReverseWordsInAString {\n    public static String reverseWords(String s) {\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == \' \') i--;\n            // first character\n            j = i;\n            while (i >= 0 && s.charAt(i) != \' \') i--;\n            if (i == - 1) {\n                sb.append(s, 0, j+1);\n            } else {\n                sb.append(s, i+1, j+1).append(" ");\n            }\n        }\n        return sb.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        String s = "the sky is blue";\n        System.out.println(reverseWords(s));\n    }\n}',
                  link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'adeb8a68-3614-4fbb-8629-42c552cc5c49',
                  isFolder: false,
                  name: 'RotateStrings.java',
                  code: 'import java.util.*;\npublic class RotateStrings {\n    public static boolean rotateString(String s, String goal) {\n//        Brute force solution\n//        if (s.length() != goal.length()) return false;\n//        if (s.equals(goal)) return true;\n//        StringBuilder sb = new StringBuilder(goal);\n//        for (int i = 0; i < s.length(); i++) {\n//            sb.append(sb.charAt(0)).replace(0,1,"");\n//            if (s.contentEquals(sb)) return true;\n//        }\n//        return false;\n\n//        Trick solution\n        return (s + s).contains(goal);\n\n//        Queue solution\n//        if (s.length() != goal.length()) return false;\n//        Queue<Character> q1 = new LinkedList<>();\n//        Queue<Character> q2 = new LinkedList<>();\n//        for (int i = 0; i < s.length(); i++) {\n//            q1.add(s.charAt(i));\n//            q2.add(goal.charAt(i));\n//        }\n//        int k = s.length() - 2;\n//        while (k != 0) {\n//            q1.add(q1.remove());\n//            if (q1.equals(q2)) return true;\n//            k--;\n//        }\n//        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(rotateString("abcde","cdeab"));\n    }\n}',
                  link: 'https://leetcode.com/problems/rotate-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'e9cef4ab-9416-4985-8400-2932b6619384',
                  isFolder: false,
                  name: 'ValidAnagram.java',
                  code: "public class ValidAnagram {\n    public static boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) return false;\n        }\n        return true;\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-anagram/description/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'c47ce740-e158-4818-94e2-25e2e4825929',
                  isFolder: true,
                  name: 'Hard Problems',
                  content: [
                    {
                      id: '367c0c1c-f57c-4a60-8e4f-9f6387a08f74',
                      isFolder: false,
                      name: 'CountAndSay.java',
                      code: "import java.util.*;\n\npublic class CountAndSay {\n    public String countAndSay(int n) {\n        if (n == 1) return \"1\";\n        String x = countAndSay(n-1);\n        StringBuilder sb = new StringBuilder();\n        int len = x.length(), count = 1;\n        char prev = x.charAt(0);\n        for (int i = 1; i < len; i++) {\n            char ch = x.charAt(i);\n            if (prev == ch) count++;\n            else {\n                sb.append((char)('0'+count)).append(prev);\n                count = 1;\n                prev = ch;\n            }\n        }\n        if (count != 0) {\n            sb.append((char)('0'+count)).append(prev);\n        }\n        return sb.toString();\n    }\n}",
                      link: 'https://leetcode.com/problems/count-and-say/',
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: 'be89db9e-0df9-4633-9621-70b75b2d634e',
                      isFolder: false,
                      name: 'CountPalindromicSubsequenceOfGivenString.java',
                      code: 'import java.util.*;\n\npublic class CountPalindromicSubsequenceOfGivenString {\n    static int mod = (int) 1e9 + 7;\n\n    static int solve(String str, int i, int j, int[][] dp) {\n        if (i == j) return 1;\n        if (i > j) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        if (str.charAt(i) == str.charAt(j)) return dp[i][j] = 1 + solve(str, i + 1, j, dp) + solve(str, i, j - 1, dp);\n        return dp[i][j] = solve(str, i + 1, j, dp) + solve(str, i, j - 1, dp) - solve(str, i + 1, j - 1, dp);\n    }\n\n    public static int countPalindromicSubseq(String s) {\n        //    Write your code here.\n        int n = s.length();\n        int[][] dp = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        return solve(s, 0, n - 1, dp);\n    }\n}',
                      link: 'https://www.codingninjas.com/studio/problems/count-palindromic-subsequences_1062696',
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: '3f1c79bc-7daa-4587-8a95-89836d923682',
                      isFolder: false,
                      name: 'KMPAlgorithm.java',
                      code: 'import java.util.*;\n\npublic class KMPAlgorithm {\n    int[] getLPS(String needle) {\n        int m = needle.length();\n        int[] lps = new int[m];\n        int prevLPS = 0, i = 1;\n        while (i < m) {\n            if (needle.charAt(i) == needle.charAt(prevLPS)) {\n                lps[i] = prevLPS + 1;\n                prevLPS++;\n                i++;\n            } else {\n                if (prevLPS == 0) {\n                    lps[i] = 0;\n                    i++;\n                } else {\n                    prevLPS = lps[prevLPS - 1];\n                }\n            }\n        }\n        return lps;\n    }\n    int search(String haystack, String needle) {\n        int[] lps = getLPS(needle);\n        int i = 0, j = 0;\n        int n = haystack.length();\n        int m = needle.length();\n        while (i < n) {\n            if (haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            } else {\n                if (j == 0) {\n                    i++;\n                } else {\n                    j = lps[j-1];\n                }\n            }\n            if (j == m) {\n                return i - m;\n            }\n        }\n        return -1;\n    }\n}',
                      link: null,
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: '531a81e3-3b69-45c7-94dc-c50547b72e2b',
                      isFolder: false,
                      name: 'LongestHappyPrefix.java',
                      code: 'import java.util.*;\n\npublic class LongestHappyPrefix {\n    int[] getLPS(String needle) {\n        int m = needle.length();\n        int[] lps = new int[m];\n        int prevLPS = 0, i = 1;\n        while (i < m) {\n            if (needle.charAt(i) == needle.charAt(prevLPS)) {\n                lps[i] = prevLPS + 1;\n                prevLPS++;\n                i++;\n            } else {\n                if (prevLPS == 0) {\n                    lps[i] = 0;\n                    i++;\n                } else {\n                    prevLPS = lps[prevLPS - 1];\n                }\n            }\n        }\n        return lps;\n    }\n    public String longestPrefix(String s) {\n        int[] lps = getLPS(s);\n        return s.substring(0, lps[lps.length - 1]);\n    }\n}',
                      link: 'https://leetcode.com/problems/longest-happy-prefix/',
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: '252d6638-6355-41b8-b50e-b53761cf0773',
                      isFolder: false,
                      name: 'MinBracketReversalsToMakeExpressionBalanced.java',
                      code: "public class MinBracketReversalsToMakeExpressionBalanced {\n    public int minAddToMakeValid(String s) {\n        int openCount = 0, closeCount = 0;\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') openCount++;\n            else if (openCount > 0) openCount--;\n            else closeCount++;\n        }\n        return openCount+closeCount;\n    }\n}",
                      link: 'https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/',
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: '20a3ddf7-ebfb-4c77-829b-066a29563568',
                      isFolder: false,
                      name: 'RabinKarp.java',
                      code: 'import java.util.*;\n\npublic class RabinKarp {\n    private static final int PRIME = 101;\n\n    static double calculateHash(String str) {\n        double hash = 0;\n        for (int i = 0; i < str.length(); i++) {\n            hash += str.charAt(i) * Math.pow(PRIME, i);\n        }\n        return hash;\n    }\n\n    static double updateHash(double prevHash, char oldChar, char newChar, int patternLength) {\n        double newHash = (prevHash - oldChar) / PRIME;\n        newHash += newChar * Math.pow(PRIME, patternLength - 1);\n        return newHash;\n    }\n\n    static List<Integer> search(String text, String pattern) {\n        List<Integer> ans = new ArrayList<>();\n        int patternLength = pattern.length();\n        double patternHash = calculateHash(pattern);\n        double strHash = calculateHash(text.substring(0, patternLength));\n        for (int i = 0; i <= text.length() - patternLength; i++) {\n            if (strHash == patternHash) {\n                if (text.substring(i, i + patternLength).equals(pattern)) {\n                    ans.add(i + 1);\n                }\n            }\n            if (i < text.length() - patternLength) {\n                strHash = updateHash(strHash, text.charAt(i), text.charAt(i + patternLength), patternLength);\n            }\n        }\n        return ans;\n    }\n\n    public static List<Integer> stringMatch(String text, String pattern) {\n        // Write your code here.\n        return search(text, pattern);\n\n    }\n}',
                      link: 'https://www.naukri.com/code360/problems/stringmatch-rabincarp_1115738',
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: '42dcd200-99a5-49f3-91f7-a4c33086b1dd',
                      isFolder: false,
                      name: 'ShortestPalindrome.java',
                      code: "import java.util.*;\n\npublic class ShortestPalindrome {\n    public int[] getLPS(StringBuilder sb) {\n        int n = sb.length();\n        int[] lps = new int[n];\n        int prev = 0, i = 1;\n        while (i < n) {\n            if (sb.charAt(i) == sb.charAt(prev)) {\n                lps[i] = prev + 1;\n                prev++;\n                i++;\n            } else {\n                if (prev == 0) {\n                    lps[i] = 0;\n                    i++;\n                } else {\n                    prev = lps[prev - 1];\n                }\n            }\n        }\n        return lps;\n    }\n\n    public String shortestPalindrome(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        int n = s.length();\n        sb.append('&');\n        for (int i = n-1; i >= 0; i--) {\n            sb.append(s.charAt(i));\n        }\n        int[] lps = getLPS(sb);\n        StringBuilder ans = new StringBuilder();\n        int idx = n - lps[lps.length-1];\n        for (int i = n-1; i >= n-idx; i--) {\n            ans.append(s.charAt(i));\n        }\n        ans.append(s);\n        return ans.toString();\n    }\n}",
                      link: 'https://leetcode.com/problems/shortest-palindrome/',
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                    {
                      id: 'fbec1816-5ebe-4bc3-9a54-6e8f69b4963f',
                      isFolder: false,
                      name: 'ZAlgorithm.java',
                      code: 'import java.util.*;\n\npublic class ZAlgorithm {\n    static List<Integer> search(String text, String pattern) {\n        String newPattern = pattern + "$" + text;\n        List<Integer> ans = new ArrayList<>();\n        int[] z = z_function(newPattern.toCharArray());\n        int n = pattern.length();\n        for (int i = 0; i < z.length; i++) {\n            if (z[i] == n) {\n                ans.add(i - n - 1);\n            }\n        }\n        return ans;\n    }\n    static int[] z_function(char[] s) {\n        int n = s.length;\n        int[] z = new int[n];\n        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i < r) {\n                z[i] = Math.min(r - i, z[i - l]);\n            }\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n                z[i]++;\n            }\n            if (i + z[i] > r) {\n                l = i;\n                r = i + z[i];\n            }\n        }\n        return z;\n    }\n\n    public static void main(String[] args) {\n        String haystack = "sadbutsad", needle = "sad";\n        List<Integer> ans = search(haystack, needle);\n        System.out.println(ans);\n    }\n}',
                      link: null,
                      notes: '',
                      tags: ['Hard Problems'],
                    },
                  ],
                },
                {
                  id: '6ef2440c-ca32-44a3-a681-03a1ade04277',
                  isFolder: false,
                  name: 'CountWithKDifferentCharacters.java',
                  code: "import java.util.*;\n\npublic class CountWithKDifferentCharacters {\n    public static int helper(String str, int k) {\n        int[] bucket = new int[26];\n        int result = 0,  i = 0, j = 0, c = 0;\n        while (j < str.length()) {\n            int idx = str.charAt(j) - 'a';\n            bucket[idx]++;\n            if (bucket[idx] == 1) c++;\n            while (c > k) {\n                int idx2 = str.charAt(i) - 'a';\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) c--;\n                i++;\n            }\n            result += j - i + 1;\n            j++;\n        }\n        return result;\n    }\n    public static int countSubStrings(String str, int k) {\n        // Brute force solution: Generate all substrings and check the count of substrings containing k different characters\n//        int count = 0;\n//        for (int i = 0; i < str.length(); i++) {\n//            for (int j = i; j < str.length(); j++) {\n//                String s = str.substring(i, j+1);\n//                HashSet<Character> hs = new HashSet<>();\n//                for (int x = 0; x < s.length(); x++) {\n//                    hs.add(s.charAt(x));\n//                }\n//                if (hs.size() == k) count++;\n//            }\n//        }\n//        return count;\n\n        // Better solution: Use 2 nested loops (subarray trick) and array instead of HashSet\n//        int count = 0;\n//        for (int i = 0; i < str.length(); i++) {\n//            int[] bucket = new int[26];\n//            int c = 0;\n//            for (int j = i; j < str.length(); j++) {\n//                char ch = str.charAt(j);\n//                bucket[ch - 'a']++;\n//                if (bucket[ch - 'a'] == 1) c++;\n//                if (c == k) count++;\n//            }\n//        }\n//        return count;\n\n        // Optimal solution: To get the exact k we need the difference of atmost k and atmost k-1\n        return helper(str, k) - helper(str, k-1);\n    }\n\n    public static void main(String[] args) {\n        String s = \"aacfssa\";\n        int k = 3;\n        int count = countSubStrings(s, k);\n        System.out.println(count);\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/count-with-k-different-characters_1214627',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '68dabc4d-6508-4141-86e4-0353049a3872',
                  isFolder: false,
                  name: 'LongestPalindromicSubstring.java',
                  code: 'public class LongestPalindromicSubstring {\n    public static boolean isPalindrome(String str) {\n        int i = 0;\n        while (i < str.length() / 2) {\n            if (str.charAt(i) != str.charAt(str.length() - i - 1)) return false;\n            i++;\n        }\n        return true;\n    }\n\n    public static int expandFromMid(int left, int right, String s) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    public String longestPalindrome(String s) {\n//        Brute force\n//        String maxL = "";\n//        for (int i = 0; i < s.length(); i++) {\n//            for (int j = i; j < s.length(); j++) {\n//                if (s.charAt(i) == s.charAt(j)) {\n//                    String sub = s.substring(i, j + 1);\n//                    if (sub.length() > maxL.length() && isPalindrome(sub)) {\n//                        maxL = sub;\n//                    }\n//                }\n//            }\n//        }\n//        return maxL;\n\n//        Optimized approach: Go to each element and try to expand outwards, store max\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = expandFromMid(i, i, s);\n            int len2 = expandFromMid(i, i + 1, s);\n            int len = Math.max(len1, len2);\n            if (len > end - start + 1) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-palindromic-substring/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '23a65635-d1db-4ffd-a2af-9852f2fbf7c8',
                  isFolder: false,
                  name: 'MaximumNestingDepthOfParentheses.java',
                  code: "class MaximumNestingDepthOfParentheses {\n    public int maxDepth(String s) {\n        int maxLength = 0, count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') count++;\n            else if (ch == ')') count--;\n            maxLength = Math.max(maxLength, count);\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '1c474e2d-8ae3-4988-b78e-c84a580ba045',
                  isFolder: false,
                  name: 'ReverseWordsInAString.java',
                  code: "public class ReverseWordsInAString {\n    public String reverseWords(String s) {\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == ' ') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != ' ') i--;\n            if (i == - 1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n}",
                  link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '92011640-dd0f-457d-b411-4bceb1bbc2e1',
                  isFolder: false,
                  name: 'RomanToIntegers.java',
                  code: "import java.util.HashMap;\n\npublic class RomanToIntegers {\n    public static int romanToInt(String s) {\n        HashMap<Character, Integer> hm = new HashMap<>();\n        hm.put('I', 1);\n        hm.put('V', 5);\n        hm.put('X', 10);\n        hm.put('L', 50);\n        hm.put('C', 100);\n        hm.put('D', 500);\n        hm.put('M', 1000);\n        char[] sArr = s.toCharArray();\n        int sum = 0;\n        for (int i = 0; i < sArr.length; i++) {\n            if (i < sArr.length - 1 && hm.get(sArr[i]) >= hm.get(sArr[i+1])) {\n                sum += hm.get(sArr[i]);\n            } else {\n                sum -= hm.get(sArr[i]);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        String s = \"III\";\n        System.out.println(romanToInt(s));\n    }\n}",
                  link: 'https://leetcode.com/problems/roman-to-integer/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '2dcbe90f-662b-405b-a7ab-1011e37f886a',
                  isFolder: false,
                  name: 'SortCharacterByFrequency.java',
                  code: 'import java.util.*;\n\npublic class SortCharacterByFrequency {\n    public static HashMap<Character, Integer> getFrequencyMap(char[] s) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length; i++) {\n            map.put(s[i], map.getOrDefault(s[i], 0) + 1);\n        }\n        return map;\n    }\n\n    public static void addFrequencyChar(StringBuilder sb, int times, char ch) {\n        while (times != 0) {\n            sb.append(ch);\n            times--;\n        }\n    }\n\n    public static String frequencySort(String s) {\n//      Brute force solution\n//        HashMap<Character, Integer> hm = getFrequencyMap(s.toCharArray());\n//        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue(Collections.reverseOrder()));\n//        pq.addAll(hm.entrySet());\n//        StringBuilder sb = new StringBuilder();\n//        while (!pq.isEmpty()) {\n//            Map.Entry<Character, Integer> map = pq.poll();\n//            addFrequencyChar(sb, map.getValue(), map.getKey());\n//        }\n//        return sb.toString();\n\n//        Optimized Solution\n        HashMap<Character, Integer> hm = getFrequencyMap(s.toCharArray());\n        List<Character>[] list = new List[s.length() + 1];\n        for (Map.Entry<Character, Integer> map: hm.entrySet()) {\n            int i = map.getValue();\n            if (list[i] == null)\n                list[i] = new ArrayList<>();\n            list[i].add(map.getKey());\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = s.length(); i > 0; i--)\n            if (list[i] != null)\n                for (char ch : list[i]) addFrequencyChar(sb, i, ch);\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(frequencySort("treerrrazt"));\n    }\n}',
                  link: 'https://leetcode.com/problems/sort-characters-by-frequency/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '1036afe8-391b-4e57-8413-f10b81edc0b0',
                  isFolder: false,
                  name: 'StringToIntegerATOI.java',
                  code: "public class StringToIntegerATOI {\n    public int myAtoi(String s) {\n        boolean isNegative = false;\n        char[] sArray = s.toCharArray();\n        int n = sArray.length;\n        int i = 0;\n        while (i < n && sArray[i] == ' ') i++;\n        if (i < n && sArray[i] == '-') {\n            isNegative = true;\n            i++;\n        } else if (i < n && sArray[i] == '+') i++;\n        double num = 0;\n        while (i < n && sArray[i] - '0' >= 0 && sArray[i] - '0' <= 9) {\n            num = num*10 + (sArray[i] - '0');\n            i++;\n        }\n        num = isNegative ? -num : num;\n        if (num > Integer.MAX_VALUE)\n            num = Integer.MAX_VALUE;\n        else if (num < Integer.MIN_VALUE)\n            num = Integer.MIN_VALUE;\n        return (int)num;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n    }\n}",
                  link: 'https://leetcode.com/problems/string-to-integer-atoi/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '6acac4d1-6db8-4e5a-9fc4-1e0d05449b2a',
                  isFolder: false,
                  name: 'SumOfBeautyOfAllSubstrings.java',
                  code: "public class SumOfBeautyOfAllSubstrings {\n    public static int calcBeauty(String sub) {\n        int[] count = new int[26];\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\n        for (int i = 0; i < sub.length(); i++) {\n            int idx = sub.charAt(i) - 'a';\n            count[idx]++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                low = Math.min(low, count[i]);\n            }\n            high = Math.max(high, count[i]);\n        }\n        int c = high - low;\n        return Math.max(c, 0);\n    }\n\n    public static int beautySum(String s) {\n        int sum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int[] count = new int[26];\n            int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\n            for (int j = i; j < s.length(); j++) {\n                count[s.charAt(j) - 'a']++;\n                for (int c : count) {\n                    if (c != 0)\n                        low = Math.min(low, c);\n                    high = Math.max(high, c);\n                }\n                sum += high - low;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        String s = \"xzvfsppsjfbxdwkqe\";\n        int ans = beautySum(s);\n        System.out.println(ans);\n    }\n}",
                  link: 'https://leetcode.com/problems/sum-of-beauty-of-all-substrings/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
              ],
            },
            {
              id: '1a2a1988-6dee-4bd6-a122-216ae213fe90',
              isFolder: true,
              name: 'Tries',
              content: [
                {
                  id: 'f47e4ebe-dbe2-4e77-8085-6e7bb88203df',
                  isFolder: false,
                  name: 'LongestStringWithAllPrefixes.java',
                  code: "import java.util.*;\n\npublic class LongestStringWithAllPrefixes {\n    static class Trie {\n        static class TrieNode {\n            TrieNode[] node;\n            boolean isWord;\n\n            TrieNode() {\n                this.node = new TrieNode[26];\n                this.isWord = false;\n            }\n        }\n\n        TrieNode root;\n\n        public Trie() {\n            // Write your code here.\n            this.root = new TrieNode();\n        }\n\n        public void insert(String word) {\n            // Write your code here.\n            TrieNode curr = this.root;\n            int n = word.length();\n            for (int i = 0; i < n; i++) {\n                char ch = word.charAt(i);\n                if (curr.node[ch - 'a'] == null) {\n                    curr.node[ch - 'a'] = new TrieNode();\n                }\n                curr = curr.node[ch - 'a'];\n            }\n            curr.isWord = true;\n        }\n\n        public int getCompletedStr(String word) {\n            // Write your code here.\n            TrieNode curr = this.root;\n            int count = 0;\n            int n = word.length();\n            for (int i = 0; i < n; i++) {\n                if (curr.isWord) count++;\n                curr = curr.node[word.charAt(i) - 'a'];\n            }\n            if (curr.isWord) count++;\n            return count;\n        }\n    }\n\n    public static String completeString(int n, String[] a) {\n        // Write your code here.\n        Trie root = new Trie();\n        for (int i = 0; i < n; i++) {\n            root.insert(a[i]);\n        }\n        String largest = \"\";\n        for (int i = 0; i < n; i++) {\n            int c = root.getCompletedStr(a[i]);\n            if (c == a[i].length()\n                    && (c > largest.length()\n                    || (c == largest.length() && largest.compareTo(a[i]) > 0))) {\n                largest = a[i];\n            }\n        }\n        return largest == \"\" ? \"None\" : largest;\n    }\n}",
                  link: 'https://www.naukri.com/code360/problems/complete-string_2687860',
                  notes: '',
                  tags: ['Problems'],
                },
                {
                  id: 'ce1ad935-a667-4a3e-ba6b-f64bc17e4522',
                  isFolder: false,
                  name: 'MaxXorOfTwoNumbersInArray.java',
                  code: 'import java.util.*;\npublic class MaxXorOfTwoNumbersInArray {\n    static class Trie {\n        static class TrieNode {\n            TrieNode[] node;\n            TrieNode() {\n                this.node = new TrieNode[2];\n            }\n        }\n\n        TrieNode root;\n        public Trie() {\n            this.root = new TrieNode();\n        }\n\n        public void insert(int num) {\n            TrieNode curr = this.root;\n            for (int i = 31; i >= 0; i--) {\n                int bit = (num >> i) & 1;\n                if (curr.node[bit] == null) {\n                    curr.node[bit] = new TrieNode();\n                }\n                curr = curr.node[bit];\n            }\n        }\n        public int getMax(int num) {\n            TrieNode curr = this.root;\n            int maxNum = 0;\n            for (int i = 31; i >= 0; i--) {\n                int bit = (num >> i) & 1;\n                if (curr.node[1-bit] != null) {\n                    maxNum |= 1<<i;\n                    curr = curr.node[1-bit];\n                } else {\n                    curr = curr.node[bit];\n                }\n            }\n            return maxNum;\n        }\n    }\n    public int findMaximumXOR(int[] nums) {\n        Trie root = new Trie();\n        for (int num : nums) {\n            root.insert(num);\n        }\n        int maxi = 0;\n        for (int num: nums) {\n            maxi = Math.max(maxi, root.getMax(num));\n        }\n        return maxi;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/',
                  notes: '',
                  tags: ['Problems'],
                },
                {
                  id: '1075cdaa-09ee-43df-9e37-8e8bafa4400e',
                  isFolder: false,
                  name: 'MaxXORWithAnElementFromArrayOfflineQueries.java',
                  code: 'import java.util.*;\n\npublic class MaxXORWithAnElementFromArrayOfflineQueries {\n    static class Trie {\n        static class TrieNode {\n            TrieNode[] node;\n\n            TrieNode() {\n                this.node = new TrieNode[2];\n            }\n        }\n\n        TrieNode root;\n\n        public Trie() {\n            this.root = new TrieNode();\n        }\n\n        public void insert(int num) {\n            TrieNode curr = this.root;\n            for (int i = 31; i >= 0; i--) {\n                int bit = (num >> i) & 1;\n                if (curr.node[bit] == null) {\n                    curr.node[bit] = new TrieNode();\n                }\n                curr = curr.node[bit];\n            }\n        }\n\n        public int getMax(int num) {\n            TrieNode curr = this.root;\n            int maxNum = 0;\n            for (int i = 31; i >= 0; i--) {\n                int bit = (num >> i) & 1;\n                if (curr == null) return -1;\n                if (curr.node[1 - bit] != null) {\n                    maxNum |= 1 << i;\n                    curr = curr.node[1 - bit];\n                } else {\n                    curr = curr.node[bit];\n                }\n            }\n            return maxNum;\n        }\n    }\n\n    public int[] maximizeXor(int[] nums, int[][] queries) {\n        Trie root = new Trie();\n        int n = queries.length;\n        int[] ans = new int[n];\n        int[][] q = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            q[i] = new int[]{queries[i][0], queries[i][1], i};\n            ans[i] = -100;\n        }\n        Arrays.sort(q, (a, b) -> a[1] - b[1]);\n        Arrays.sort(nums);\n        int idx = 0;\n        for (int[] query : q) {\n            for (int i = idx; i < nums.length; i++) {\n                if (nums[i] > query[1]) break;\n                root.insert(nums[i]);\n                idx++;\n            }\n            ans[query[2]] = Math.max(ans[query[2]], root.getMax(query[0]));\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-xor-with-an-element-from-array/',
                  notes: '',
                  tags: ['Problems'],
                },
                {
                  id: '111e69ae-658c-4dc1-9b64-015b80b13f99',
                  isFolder: false,
                  name: 'NumberOfDistinctSubstringsInString.java',
                  code: "import java.util.*;\n\npublic class NumberOfDistinctSubstringsInString {\n    static class TrieNode {\n        TrieNode[] node;\n\n        TrieNode() {\n            this.node = new TrieNode[26];\n        }\n    }\n\n    public static int countDistinctSubstrings(String s) {\n        // Write your code here.\n        TrieNode root = new TrieNode();\n        int count = 1;\n        for (int i = 0; i < s.length(); i++) {\n            TrieNode curr = root;\n            for (int j = i; j < s.length(); j++) {\n                char ch = s.charAt(j);\n                if (curr.node[ch - 'a'] == null) {\n                    curr.node[ch - 'a'] = new TrieNode();\n                    count++;\n                }\n                curr = curr.node[ch - 'a'];\n            }\n        }\n        return count;\n    }\n}",
                  link: 'https://www.naukri.com/code360/problems/count-distinct-substrings_985292',
                  notes: '',
                  tags: ['Problems'],
                },
                {
                  id: '3be747b4-eeec-40f3-82d6-4c496c3df59c',
                  isFolder: false,
                  name: 'Trie2.java',
                  code: "public class Trie2 {\n    static class TrieNode {\n        TrieNode[] node;\n        int endWith;\n        int countPre;\n        TrieNode() {\n            this.node = new TrieNode[26];\n            this.countPre = 0;\n            this.endWith = 0;\n        }\n    }\n    \n    TrieNode root;\n    public Trie2() {\n        // Write your code here.\n        this.root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        // Write your code here.\n        TrieNode curr = this.root;\n        int n = word.length();\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (curr.node[ch-'a'] == null) {\n                curr.node[ch-'a'] = new TrieNode();\n            }\n            curr = curr.node[ch-'a'];\n            curr.countPre += 1;\n        }\n        curr.endWith += 1;\n    }\n\n    public int countWordsEqualTo(String word) {\n        // Write your code here.\n        TrieNode curr = this.root;\n        int n = word.length();\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (curr.node[ch-'a'] == null) {\n                return 0;\n            }\n            curr = curr.node[ch-'a'];\n        }\n        return curr.endWith;\n    }\n\n    public int countWordsStartingWith(String word) {\n        // Write your code here.\n        TrieNode curr = this.root;\n        int n = word.length();\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (curr.node[ch-'a'] == null) {\n                return 0;\n            }\n            curr = curr.node[ch-'a'];\n        }\n        return curr.countPre;\n    }\n\n    public void erase(String word) {\n        // Write your code here.\n        TrieNode curr = this.root;\n        int n = word.length();\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (curr.node[ch-'a'] == null) {\n                return;\n            }\n            curr = curr.node[ch-'a'];\n            curr.countPre--;\n        }\n        curr.endWith--;\n    }\n\n    public static TrieNode deleteWord(TrieNode root, String word) {\n        // WRITE YOUR CODE HERE\n        TrieNode curr = root;\n        int n = word.length();\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (curr.children[ch-'a'] == null) {\n                return root;\n            }\n            curr = curr.children[ch-'a'];\n        }\n        curr.isEnd = false;\n        return root;\n    }\n}",
                  link: 'https://www.naukri.com/code360/problems/implement-trie_1387095',
                  notes: '',
                  tags: ['Problems'],
                },
                {
                  id: '65c7caae-94c8-438d-8d6f-c46a169ed070',
                  isFolder: false,
                  name: 'Trie.java',
                  code: 'class Trie {\n    class TrieNode {\n        HashMap<Character, TrieNode> map;\n        boolean isWord;\n        TrieNode() {\n            this.map = new HashMap<>();\n            this.isWord = false;\n        }\n    }\n    TrieNode node;\n    public Trie() {\n        this.node = new TrieNode();\n    }\n    \n    public void insert(String word) {\n        int n = word.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                curr.map.put(ch, new TrieNode());\n            }\n            curr = curr.map.get(ch);\n        }\n        curr.isWord = true;\n    }\n    \n    public boolean search(String word) {\n        int n = word.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                return false;\n            }\n            curr = curr.map.get(ch);\n        }\n        return curr.isWord;\n    }\n    \n    public boolean startsWith(String prefix) {\n        int n = prefix.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = prefix.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                return false;\n            }\n            curr = curr.map.get(ch);\n        }\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */',
                  link: null,
                  notes: '',
                  tags: ['Theory'],
                },
              ],
            },
          ],
        },
      ],
    },
    {
      id: '5c972acc-a755-4aff-b0bf-356ee04dcca9',
      isFolder: true,
      name: 'Notes',
      content: [
        {
          id: 'dae8209c-8a5d-423f-aa08-c3fe82fe7039',
          isFolder: true,
          name: 'Algorithms',
          content: [
            {
              id: '9655c091-c74a-4b67-ae52-56e3504c72be',
              isFolder: false,
              name: 'BinarySearch.java',
              code: '// BS on 1D Arrays\npublic class BinarySearch {\n    //    Iterative Binary Search\n    public static int binarySearch(int[] A, int target) {\n        int start = 0;\n        int end = A.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (A[mid] == target) return mid;\n            if (A[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return -1;\n    }\n\n    //    Recursive Binary search\n    public static int binarySearch(int[] A, int target, int start, int end) {\n        if (start > end)\n            return -1;\n        int mid = start + (end - start) / 2;\n        if (A[mid] == target)\n            return mid;\n        if (A[mid] > target)\n            return binarySearch(A, target, start, mid - 1);\n        else\n            return binarySearch(A, target, mid + 1, end);\n    }\n\n    static int orderAgnosticBS(int arr[], int target) {\n        boolean isAscending = arr[0] > arr[arr.length - 1];\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = ((end - start) / 2) + start;\n            if (target == arr[mid]) return mid;\n            if (isAscending) {\n                if (target > arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return -1;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Search'],
            },
            {
              id: '4e706a67-c316-4827-8a0e-a551fc01a27d',
              isFolder: false,
              name: 'GraphSearch.java',
              code: 'import java.util.*;;\n/**\n * GraphSearch\n */\npublic class GraphSearch {\n    static class Edge {\n        int source, destination;\n        Edge(int s, int d) {\n            this.source = s;\n            this.destination = d;\n        }\n        @Override\n        public String toString() {\n            return "Edge{ src=" + source + ", dest=" + destination + \'}\';\n        }\n    }\n    static void bfs(List<Edge>[] adjList) {\n        boolean[] visited = new boolean[adjList.length];\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n\n    static void dfs(List<Edge>[] adjList, boolean[] visited, int curr) {\n        System.out.print(curr + " ");\n        visited[curr] = true;\n        for (int i = 0; i < adjList[curr].size(); i++) {\n            int dist = adjList[curr].get(i).destination;\n            if (!visited[dist]) {\n                dfs(adjList, visited, dist);\n            }\n        }\n    }\n}',
              link: null,
              notes: '',
              tags: ['Search'],
            },
            {
              id: 'b6cd3e68-43cb-46f6-af20-57eee9a2efd4',
              isFolder: false,
              name: 'LinearSearch.java',
              code: 'public class LinearSearch {\n    static int linearSearch(int arr[], int target) {\n        for (int i = 0; i <= arr.length; i++) {\n            if (target == arr[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Search'],
            },
            {
              id: 'bece4a55-141b-4056-b8e1-4e342613a877',
              isFolder: false,
              name: 'TreeSearch.java',
              code: 'import java.util.*;\n\npublic class TreeSearch {\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode() {\n        }\n\n        TreeNode(int val) {\n            this.val = val;\n        }\n\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n    // Implement bfs and dfs for trees\n    public boolean bfs(TreeNode root, int value) {\n        if (root == null) return false;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                if (node.val == value) return true;\n                if (node.left != null)\n                    q.offer(node.left);\n                if (node.right != null)\n                    q.offer(node.right);\n            }\n        }\n        return false;\n    }\n    public boolean dfs(TreeNode root, int value) {\n        if (root == null) return false;\n        if (root.val == value) return true;\n        return dfs(root.left, value) || dfs(root.right, value);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Search'],
            },
            {
              id: '19635cef-a69e-4679-9b10-93290c240bae',
              isFolder: false,
              name: 'BubbleSort.java',
              code: 'public class BubbleSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n      boolean swapped = false;\n      for (int j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          swap(arr, j, j + 1);\n          swapped = true;\n        }\n      }\n      if (!swapped) break;\n    }\n  }\n  \n  public static void bubbleSortRecursive(int[] arr, int n) {\n    if (n == 1) return;\n    boolean swapped = false;\n    for (int j = 0; j < n - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        swapped = true;\n      }\n    }\n    if (!swapped) return;\n    bubbleSortRecursive(arr, n - 1);\n  }\n}',
              link: null,
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'f5575144-9d26-4da6-ba66-77687159841c',
              isFolder: false,
              name: 'CyclicSort.java',
              code: 'public class CyclicSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void cyclicSort(int[] arr) {\n    int i = 0;\n    while (i < arr.length) {\n      if (arr[i] != arr[arr[i] - 1])\n        swap(arr, i, arr[i] - 1);\n      else\n        i++;\n    }\n  }\n}',
              link: null,
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '0be920ab-da1d-4a72-a1d9-47ad12749833',
              isFolder: false,
              name: 'InsertionSort.java',
              code: 'public class InsertionSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n  public static void insertionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 1; i < n - 1; i++) {\n      for (int j = i; j > 0; j--) {\n        if (arr[j] >= arr[j - 1])\n          break;\n        swap(arr, j, j-1);\n      }\n    }\n  }\n\n  public static void insertionSortRecursive(int[] arr, int i) {\n    if (i == arr.length-1) return;\n    for (int j = i; j > 0; j--) {\n      if (arr[j] >= arr[j - 1])\n        break;\n      swap(arr, j, j-1);\n    }\n    insertionSortRecursive(arr, i+1);\n  }\n}',
              link: null,
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '6a22ca5b-612a-454c-8fcf-2104102305c5',
              isFolder: false,
              name: 'MergeSort.java',
              code: 'public class MergeSort {\n  public static void mergeArray(int[] arr, int low, int mid, int high) {\n    int[] temp = new int[high - low + 1];\n    int left = low, right = mid + 1, i = 0;\n    while (left <= mid && right <= high) {\n      if (arr[left] <= arr[right])\n        temp[i++] = arr[left++];\n      else\n        temp[i++] = arr[right++];\n    }\n\n    while (left <= mid)\n      temp[i++] = arr[left++];\n\n    while (right <= high)\n      temp[i++] = arr[right++];\n\n    for (int j = 0; j < i; j++)\n      arr[j + low] = temp[j];\n  }\n\n  public static void mergeSort(int[] arr, int low, int high) {\n    if (low == high) {\n      return;\n    }\n    int mid = low + (high - low) / 2;\n    mergeSort(arr, low, mid);\n    mergeSort(arr, mid + 1, high);\n    mergeArray(arr, low, mid, high);\n  }\n\n}',
              link: null,
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '4b9568c3-ea34-433e-9600-5ba89dbcdc33',
              isFolder: false,
              name: 'QuickSort.java',
              code: 'public class QuickSort {\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int partition(int[] A, int low, int high) {\n        int pivot = A[low];\n        int i = low, j = high;\n        while (i < j) {\n            while (A[i] <= pivot && i < high) i++;\n            while (A[j] > pivot && j > low) j--;\n            if (i < j) swap(A, i, j);\n        }\n        swap(A, j, low);\n        return j;\n    }\n    public static void quickSort(int[] A, int low, int high) {\n        if (low < high) {\n            int pIdx = partition(A, low, high);\n            quickSort(A, low, pIdx-1);\n            quickSort(A, pIdx+1, high);\n        }\n    }\n}',
              link: null,
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'ea723138-a001-4330-b335-a7aa042241b4',
              isFolder: false,
              name: 'SelectionSort.java',
              code: 'public class SelectionSort {\n  public static void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++) {\n      int minIdx = i;\n      for (int j = i + 1; j < n; j++)\n        if (arr[minIdx] > arr[j])\n          minIdx = j;\n      if (i != minIdx) {\n        int temp = arr[i];\n        arr[i] = arr[minIdx];\n        arr[minIdx] = temp;\n      }\n    }\n  }\n\n}',
              link: null,
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '7ee54892-eb3d-49fc-bc88-17d2c8fb68e0',
              isFolder: false,
              name: 'CycleDetectionArray.java',
              code: "// AKA Floyd's algorithm, cycle detection in an array, find the duplicate number in an array of [1 - N]\npublic class CycleDetectionArray {\n    public static int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
              link: 'https://leetcode.com/problems/find-the-duplicate-number',
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: '51e270db-546f-4e81-8227-4388436fbae8',
              isFolder: false,
              name: 'CycleDetectionLinkedList.java',
              code: '// Detect loop or cycle in a linked list\npublic class CycleDetectionLinkedList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(0);\n        ListNode temp = head;\n        temp.next = new ListNode(2);\n        temp = temp.next;\n        temp.next = new ListNode(4);\n        temp = temp.next;\n        temp.next = new ListNode(1);\n        temp = temp.next;\n        temp.next = new ListNode(0);\n//        Created a cycle\n        temp.next.next  = head.next.next;\n    }\n}',
              link: 'https://leetcode.com/problems/linked-list-cycle',
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: '6629a8e5-db89-49c5-9feb-bc7450886b7e',
              isFolder: false,
              name: 'DutchNationalFlagAlgorithm.java',
              code: "// Dutch's national flag algorithm\n\nimport java.util.Arrays;\n\npublic class DutchNationalFlagAlgorithm {\n    public static int[] sort012(int[] arr) {\n        int low = 0, mid = 0, high = arr.length - 1;\n        while (mid <= high) {\n            if (arr[mid] == 0) {\n                int temp = arr[low];\n                arr[low] = arr[mid];\n                arr[mid] = temp;\n                low++;\n                mid++;\n            } else if (arr[mid] == 1) mid++;\n            else {\n                int temp = arr[high];\n                arr[high] = arr[mid];\n                arr[mid] = temp;\n                high--;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 0, 1, 2};\n        int[] ans = sort012(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              link: 'https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/',
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: 'bfc7d5ad-fd38-4987-866f-cf6739d8e388',
              isFolder: false,
              name: 'FastExponentiation.java',
              code: 'public class FastExponentiation {\n    public static int power(int a, int n) {\n        if (n == 0) return 1;\n        else if (n == 1) return a;\n\n        int r = power(a, n/2);\n\n        if (n%2 == 0) return r*r;\n        return r*a*r;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: '72c6a4ea-460f-4f6a-8fc5-c1902252c06a',
              isFolder: false,
              name: 'GCD.java',
              code: 'public class GCD {\n//    a = big, b = small\n    public static int getGCD(int a, int b) {\n        if (a%b == 0) return b;\n        return getGCD(b, a%b);\n    }\n\n    public static void main(String[] args) {\n        int ans = getGCD(51, 24);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: '95130c1b-8a76-4cb3-9460-79d5591cff9f',
              isFolder: false,
              name: 'KadanesAlgorithm.java',
              code: "// Largest Sum Contiguous Subarray (Kadane's Algorithm)\npublic class KadanesAlgorithm {\n    public static int maxSum(int[] nums) {\n        int sum = 0;\n        int maxSum = 0;\n        for (int num : nums) {\n            sum += num; // Increment\n            maxSum = Math.max(maxSum, sum); // Maximise\n            if (sum < 0) sum = 0; // Check to reset\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, -3, 4, -1, -2, 1, 5, -3};\n        int ans = maxSum(arr);\n        System.out.println(ans);\n    }\n}",
              link: 'https://www.geeksforgeeks.org/largest-sum-contiguous-subarray',
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: 'be8acc7d-443f-408e-aa3a-30f1abd5934a',
              isFolder: false,
              name: 'MooresVotingAlgorithm.java',
              code: '//  Boyer-Moore Majority Voting Algorithm: used to find the majority element among the given elements that have more than N/ 2 occurrences.\npublic class MooresVotingAlgorithm {\n    public static int findMajority(int[] N) {\n        int element = -1, count = 0;\n        for (int j : N) {\n            if (count == 0) {\n                element = j;\n                count = 1;\n            } else if (element == j) count++;\n            else count--;\n        }\n        return element;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 2, 2, 1, 1, 2, 3, 4};\n        int majority = findMajority(arr);\n        System.out.println(" The majority element is : " + majority);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm',
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: 'c983a977-c386-4681-b96b-81b7d44ac771',
              isFolder: false,
              name: 'SieveOfEratosthenes.java',
              code: 'import java.util.*;\n\npublic class SieveOfEratosthenes {\n    public static int sieve(int n) {\n        List<Integer> ans = new ArrayList<>();\n        if (n <= 2) return 0;\n        int count = 0;\n        boolean[] M = new boolean[n];\n        for (int i = 2; i < n; i++) {\n            if (!M[i]) {\n                ans.add(i);\n                count++;\n                for (int j = 2* i; j < n; j += i) {\n                    M[j] = true;\n                }\n            }\n        }\n        System.out.println(ans);\n        return count;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Special Algorithms'],
            },
            {
              id: '16534f1a-f723-4278-b2fb-500cb5669d5f',
              isFolder: false,
              name: 'SubsequencesOfAString.java',
              code: 'import java.util.*;\n\npublic class SubsequencesOfAString {\n    public static ArrayList<String> subsequences(String str) {\n        // Using power set technique\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/subsequences-of-string_985087',
              notes: '',
              tags: ['Special Algorithms'],
            },
          ],
        },
        {
          id: '92bbcea2-070d-4516-a943-000fd8af1c13',
          isFolder: false,
          name: 'DisjointSet.java',
          code: 'public class DisjointSet {\n    //    ZERO Based implementation\n    int[] parent;\n    int[] rank;\n    int[] size;\n\n    DisjointSet(int n) {\n        this.parent = new int[n];\n        this.rank = new int[n];\n        this.size = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    public int find(int num) {\n        if (num == parent[num]) return num;\n        parent[num] = find(parent[num]);\n        return parent[num];\n    }\n\n    public void unionByRank(int u, int v) {\n        int ultParentU = find(u), ultParentV = find(v);\n        if (ultParentU == ultParentV) return;\n        if (rank[ultParentU] > rank[ultParentV]) {\n            parent[ultParentV] = ultParentU;\n        } else if (rank[ultParentU] < rank[ultParentV]) {\n            parent[ultParentU] = ultParentV;\n        } else {\n            parent[ultParentV] = ultParentU;\n            rank[ultParentU]++;\n        }\n    }\n\n    public void unionBySize(int u, int v) {\n        int ultParentU = find(u);\n        int ultParentV = find(v);\n        if (ultParentU == ultParentV) return;\n        if (size[ultParentU] > size[ultParentV]) {\n            parent[ultParentV] = ultParentU;\n            size[ultParentU] += size[ultParentV];\n        } else {\n            parent[ultParentU] = ultParentV;\n            size[ultParentV] += size[ultParentU];\n        }\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: 'b6109459-08a8-4ab3-8eea-4f9e7af5e9cd',
          isFolder: false,
          name: 'DoublyLinkedList.java',
          code: 'public class DoublyLinkedList {\n    private Node head;\n    private Node tail;\n    private int length = 0;\n\n    class Node {\n        int value;\n        Node next;\n        Node prev;\n\n        Node(int val) {\n            this.value = val;\n        }\n    }\n\n    DoublyLinkedList() {\n        head = tail = null;\n    }\n\n    DoublyLinkedList(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n\n    public static void printList(DoublyLinkedList list) {\n        Node temp = list.head;\n        if (list.length == 0) {\n            System.out.println("<List empty>");\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.length; i++) {\n            sb.append(temp.value);\n            if (temp.next != null) {\n                sb.append(" <--> ");\n            }\n            temp = temp.next;\n        }\n        System.out.println(sb.toString());\n    }\n\n    public void append(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            tail.next = temp;\n            temp.prev = tail;\n            tail = temp;\n        }\n        length++;\n    }\n\n    public Node removeLast() {\n        if (length == 0) return null;\n        Node temp = tail;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            tail = tail.prev;\n            tail.next = temp.prev = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public void prepend(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            temp.next = head;\n            head.prev = temp;\n            head = temp;\n        }\n        length++;\n    }\n\n    public Node removeFirst() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            head.prev = null;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public Node get(int index) {\n        if (index < 0 || index >= length) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean insert(int index, int val) {\n        if (index < 0 || index > length) return false;\n        if (index == 0) {\n            prepend(val);\n        } else if (index == length) {\n            append(val);\n        } else {\n            Node before = get(index - 1);\n            Node after = before.next;\n            Node temp = new Node(val);\n            before.next = temp;\n            temp.next = after;\n            after.prev = temp;\n            temp.prev = before;\n        }\n        length++;\n        return true;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) {\n            length--;\n            return removeFirst();\n        }\n        if (index == length - 1) {\n            length--;\n            return removeLast();\n        }\n        Node temp = get(index);\n        if (temp != null) {\n            Node before = temp.prev;\n            Node after = temp.next;\n            before.next = after;\n            after.prev = before;\n            length--;\n            return temp;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        DoublyLinkedList list = new DoublyLinkedList(1);\n        list.append(2);\n        list.append(3);\n        list.append(9);\n        list.append(12);\n        System.out.println(list.remove(1));\n//        list.insert(4, 91);\n//        System.out.println(list.set(2, 99));\n//        System.out.println(list.get(2).value);\n//        System.out.println(list.removeFirst().value);\n        DoublyLinkedList.printList(list);\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: '858e4c31-4475-487e-b6ae-6dd51dc7d0a9',
          isFolder: false,
          name: 'Graph.java',
          code: 'import java.util.*;\n\npublic class Graph {\n    static class Edge {\n        int source, destination;\n\n        Edge(int s, int d) {\n            this.source = s;\n            this.destination = d;\n        }\n\n        @Override\n        public String toString() {\n            return "Edge{ src=" + source + ", dest=" + destination + \'}\';\n        }\n    }\n\n    static int getNeighbours(List<Edge> adjListItem) {\n        System.out.print("Neighbours: ");\n        for (Edge e : adjListItem) {\n            System.out.print(e.destination + " ");\n        }\n        return adjListItem.size();\n    }\n\n    static void buildGraph(List<Edge>[] adjList) {\n        for (int i = 0; i < adjList.length; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n        adjList[0].add(new Edge(0, 1));\n        adjList[0].add(new Edge(0, 2));\n\n        adjList[1].add(new Edge(1, 0));\n        adjList[1].add(new Edge(1, 3));\n\n        adjList[2].add(new Edge(2, 0));\n        adjList[2].add(new Edge(2, 4));\n\n        adjList[3].add(new Edge(3, 1));\n        adjList[3].add(new Edge(3, 4));\n\n        adjList[4].add(new Edge(4, 2));\n        adjList[4].add(new Edge(4, 5));\n\n        adjList[5].add(new Edge(5, 3));\n        adjList[5].add(new Edge(5, 4));\n        adjList[5].add(new Edge(5, 6));\n\n        adjList[6].add(new Edge(6, 5));\n    }\n\n    static void bfs(List<Edge>[] adjList) {\n        boolean[] visited = new boolean[adjList.length];\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n    static void bfsDisjoint(List<Edge>[] adjList, boolean[] visited, int start) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(start);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n\n    static void dfs(List<Edge>[] adjList, boolean[] visited, int curr) {\n        System.out.print(curr + " ");\n        visited[curr] = true;\n        for (int i = 0; i < adjList[curr].size(); i++) {\n            int dist = adjList[curr].get(i).destination;\n            if (!visited[dist]) {\n                dfs(adjList, visited, dist);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 7;\n        List<Edge>[] adjList = new List[V];\n        buildGraph(adjList);\n        for (int i = 0; i < adjList.length; i++) {\n            System.out.println(i + ": " + adjList[i]);\n        }\n//        Print neighbour information\n//        int len = getNeighbours(adjList[2]);\n//        System.out.println("\\n2 has " + len + " neighbours");\n\n//        BFS\n//        bfs(adjList);\n//        boolean[] visited = new boolean[adjList.length];\n//        for (int i = 0; i < visited.length; i++) {\n//            if (!visited[i]) {\n//                bfsDisjoint(adjList, visited, i);\n//            }\n//        }\n\n//        DFS\n        boolean[] visited = new boolean[adjList.length];\n        dfs(adjList, visited, 0);\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: 'a14d3030-40f5-4477-a38b-bb0c2da71344',
          isFolder: false,
          name: 'HashTables.java',
          code: 'import java.util.*;\n\npublic class HashTables {\n    public static void main(String[] args) {\n        int[] nums = { 1, 2, 3, 1, 3, 4, 1, 2, 5, 1, 2, 2, 1, 6, 3, 2, 6, 3, 2, 4, 2, 4, 3, 2, 4 };\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        System.out.println(hm); // {1=5, 2=8, 3=5, 4=4, 5=1, 6=2}\n        // Acces, Updating is O(1), Searching is O(N)\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: '3f894536-25bc-4fad-b5e6-e7a6cfce4ab6',
          isFolder: false,
          name: 'MST.java',
          code: 'import java.util.*;\n\nclass Pair {\n    int node;\n    int distance;\n\n    public Pair(int distance, int node) {\n        this.node = node;\n        this.distance = distance;\n    }\n}\n\nclass Edge implements Comparable<Edge> {\n    int src, dest, weight;\n    Edge(int _src, int _dest, int _wt) {\n        this.src = _src; this.dest = _dest; this.weight = _wt;\n    }\n    public int compareTo(Edge compareEdge) {\n        return this.weight - compareEdge.weight;\n    }\n};\n\npublic class MST {\n    // MST is minimum spanning tree\n    // a graph can be converted to a MST by 2 algorithms Prims and Kruskals\n    static int prims(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) {\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((x, y) -> x.distance - y.distance);\n        int[] vis = new int[V];\n        pq.add(new Pair(0, 0));\n        int sum = 0;\n        while (pq.size() > 0) {\n            int wt = pq.peek().distance;\n            int node = pq.peek().node;\n            pq.remove();\n            if (vis[node] == 1) {\n                continue;\n            }\n            // add it to the mst\n            vis[node] = 1;\n            sum += wt;\n            for (int i = 0; i < adj.get(node).size(); i++) {\n                int edW = adj.get(node).get(i).get(1);\n                int adjNode = adj.get(node).get(i).get(0);\n                if (vis[adjNode] == 0) {\n                    pq.add(new Pair(edW, adjNode));\n                }\n            }\n        }\n        return sum;\n    }\n\n    static int kruskals(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) {\n        List<Edge> edges = new ArrayList<Edge>();\n        // O(N + E)\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < adj.get(i).size(); j++) {\n                int adjNode = adj.get(i).get(j).get(0);\n                int wt = adj.get(i).get(j).get(1);\n                Edge temp = new Edge(i, adjNode, wt);\n                edges.add(temp);\n            }\n        }\n        DisjointSet ds = new DisjointSet(V);\n        // M log M\n        Collections.sort(edges);\n        int mstWt = 0;\n        // M x 4 x alpha x 2\n        for (int i = 0; i < edges.size(); i++) {\n            int wt = edges.get(i).weight;\n            int u = edges.get(i).src;\n            int v = edges.get(i).dest;\n\n            if (ds.find(u) != ds.find(v)) {\n                mstWt += wt;\n                ds.unionBySize(u, v);\n            }\n        }\n        return mstWt;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: '887b83c6-acd5-45a5-b9fd-2bff1d76f12e',
          isFolder: false,
          name: 'Queue.java',
          code: 'public class Queue {\n    class Node {\n        int value;\n        Node next;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    Node head;\n    Node tail;\n    int length;\n    Queue(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n    Queue() {\n        head = tail = null;\n        length = 0;\n    }\n    Node enqueue(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n        return newNode;\n    }\n\n    Node dequeue() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        return temp;\n    }\n\n    public static void main(String[] args) {\n        Queue q = new Queue(10);\n        q.enqueue(4);\n        q.enqueue(19);\n        System.out.println(q.dequeue().value);\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: 'a758bd8a-b965-46a3-95b4-e06129bbbede',
          isFolder: false,
          name: 'SinglyLinkedList.java',
          code: 'public class SinglyLinkedList {\n    static class Node {\n        int value;\n        Node next;\n        Node (int val) {\n            this.value = val;\n        }\n    }\n    int length;\n    private Node head;\n    private Node tail;\n    SinglyLinkedList(int value) {\n        Node newNode = new Node(value);\n        head = tail = newNode;\n        length = 1;\n    }\n    SinglyLinkedList() {\n        head = tail = null;\n        length = 0;\n    }\n\n//    Methods\n    public void prepend(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            newNode.next = head;\n            head = newNode;\n        }\n        length++;\n    }\n    public void append(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n    }\n    public Node removeLast() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            Node pre = head;\n            while (temp.next != null) {\n                pre = temp;\n                temp = temp.next;\n            }\n            tail = pre;\n            tail.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node removeFirst() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node get(int index) {\n        if (index >= length || index < 0) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public void insert(int index, int val) {\n        if (index < 0 || index > length) return;\n        else if (index == 0) {\n            prepend(val);\n            return;\n        } else if (index == length) {\n            append(val);\n            return;\n        }\n        Node temp = head;\n        for (int i = 0; i < index - 1; i++) {\n            temp = temp.next;\n        }\n        Node newNode = new Node(val);\n        newNode.next = temp.next;\n        temp.next = newNode;\n        length++;\n        return;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) return removeFirst();\n        if (index == length - 1) return removeLast();\n        Node prev = get(index - 1);\n        Node temp = prev.next;\n        prev.next = temp.next;\n        temp.next = null;\n        length--;\n        return temp;\n    }\n\n    public void reverse() {\n        Node temp = head;\n        head = tail;\n        tail = temp;\n        Node prev = null;\n        Node next = null;\n        for (int i = 0; i < length; i++) {\n            next = temp.next;\n            temp.next = prev;\n            prev = temp;\n            temp = next;\n        }\n    }\n\n    public int getLength() {\n        return length;\n    }\n    public String getString() {\n        Node temp = head;\n        StringBuilder sb = new StringBuilder();\n        while (temp != null) {\n            sb.append(temp.value).append(" ");\n            temp = temp.next;\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.append(1);\n        list.append(3);\n        list.append(5);\n        list.append(6);\n        System.out.println(list.getString());\n        list.reverse();\n        System.out.println(list.getString());\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: 'f8e57880-e417-4927-a256-70fb685d79cc',
          isFolder: false,
          name: 'Stack.java',
          code: '// Using Singly linked list\n\npublic class Stack {\n    class Node {\n        Node next;\n        int value;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    private Node top;\n    private int height;\n    Stack(int val) {\n        top = new Node(val);\n        height = 1;\n    }\n//    Peek\n    public Node peek() {\n        return top;\n    }\n//    Push\n    public void push(int val) {\n        Node newNode = new Node(val);\n        if (height == 0) {\n            top = newNode;\n        } else {\n            newNode.next = top;\n            top = newNode;\n        }\n        height++;\n    }\n//    Pop\n    public Node pop() {\n        if (isEmpty()) {\n            return null;\n        }\n        Node temp = top;\n        top = top.next;\n        temp.next = null;\n        height--;\n        return temp;\n    }\n//    isEmpty\n    public boolean isEmpty() {\n        return height == 0;\n    }\n\n    public static void main(String[] args) {\n        Stack myStack = new Stack(10);\n        myStack.push(19);\n        myStack.push(13);\n        myStack.push(41);\n        myStack.push(25);\n//        System.out.println(myStack.pop().value);\n//        System.out.println(myStack.peek().value);\n        System.out.println(myStack.isEmpty());\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: '966b743c-8f8b-4a86-bcaa-e810ddda4604',
          isFolder: false,
          name: 'Tree.java',
          code: 'public class Tree {\n    static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int d) {\n            this.val = d;\n            this.left = this.right = null;\n        }\n        TreeNode(int d, TreeNode l, TreeNode r) {\n            this.val = d;\n            this.left = l;\n            this.right = r;\n        }\n    }\n    static void print(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        print(root.left);\n        System.out.println(root.val);\n        print(root.right);\n    }\n    static TreeNode buildTreeWithArray(int[] arr, int s, int e) {\n        if (s > e) return null;\n        int mid = (s + e) / 2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = buildTreeWithArray(arr, s, mid - 1);\n        root.right = buildTreeWithArray(arr, mid + 1, e);\n        return root;\n    }\n    static TreeNode buildTreeWithArray(int[] arr) {\n        int n = arr.length;\n        TreeNode root = buildTreeWithArray(arr, 0, n - 1);\n        print(root);\n        return root;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1,2,3,4,5,6,7,8,9};\n        buildTreeWithArray(arr);\n    }\n}',
          link: null,
          notes: '',
          tags: ['Data Structures'],
        },
        {
          id: '1a1ad16f-0c92-4d1f-a50a-b0e59623c26b',
          isFolder: false,
          name: 'Trie.java',
          code: 'import java.util.*;\nclass Trie {\n    class TrieNode {\n        HashMap<Character, TrieNode> map;\n        boolean isWord;\n        TrieNode() {\n            this.map = new HashMap<>();\n            this.isWord = false;\n        }\n    }\n    TrieNode node;\n    public Trie() {\n        this.node = new TrieNode();\n    }\n\n    public void insert(String word) {\n        int n = word.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                curr.map.put(ch, new TrieNode());\n            }\n            curr = curr.map.get(ch);\n        }\n        curr.isWord = true;\n    }\n\n    public boolean search(String word) {\n        int n = word.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = word.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                return false;\n            }\n            curr = curr.map.get(ch);\n        }\n        return curr.isWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        int n = prefix.length();\n        TrieNode curr = this.node;\n        for (int i = 0; i < n; i++) {\n            char ch = prefix.charAt(i);\n            if (!curr.map.containsKey(ch)) {\n                return false;\n            }\n            curr = curr.map.get(ch);\n        }\n        return true;\n    }\n}',
          link: 'https://leetcode.com/problems/implement-trie-prefix-tree/',
          notes: '',
          tags: ['Data Structures'],
        },
      ],
    },
  ],
};

export default data;
