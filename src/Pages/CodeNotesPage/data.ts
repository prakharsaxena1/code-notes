const data = {
  id: 'c0a7b0bb-16a5-412a-9965-0f8869fd9c63',
  isFolder: true,
  name: 'DSA',
  content: [
    {
      id: '0293219a-14a3-4fe3-8b5f-b68cf5a17cad',
      isFolder: true,
      name: 'Concepts',
      content: [
        {
          id: '2f8a2d48-9586-49db-9ecd-f76f391e5579',
          isFolder: false,
          name: 'DoublyLinkedList.java',
          code: 'public class DoublyLinkedList {\n    private Node head;\n    private Node tail;\n    private int length = 0;\n\n    class Node {\n        int value;\n        Node next;\n        Node prev;\n\n        Node(int val) {\n            this.value = val;\n        }\n    }\n\n    DoublyLinkedList() {\n        head = tail = null;\n    }\n\n    DoublyLinkedList(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n\n    public static void printList(DoublyLinkedList list) {\n        Node temp = list.head;\n        if (list.length == 0) {\n            System.out.println("<List empty>");\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.length; i++) {\n            sb.append(temp.value);\n            if (temp.next != null) {\n                sb.append(" <--> ");\n            }\n            temp = temp.next;\n        }\n        System.out.println(sb.toString());\n    }\n\n    public void append(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            tail.next = temp;\n            temp.prev = tail;\n            tail = temp;\n        }\n        length++;\n    }\n\n    public Node removeLast() {\n        if (length == 0) return null;\n        Node temp = tail;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            tail = tail.prev;\n            tail.next = temp.prev = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public void prepend(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            temp.next = head;\n            head.prev = temp;\n            head = temp;\n        }\n        length++;\n    }\n\n    public Node removeFirst() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            head.prev = null;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public Node get(int index) {\n        if (index < 0 || index >= length) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean insert(int index, int val) {\n        if (index < 0 || index > length) return false;\n        if (index == 0) {\n            prepend(val);\n        } else if (index == length) {\n            append(val);\n        } else {\n            Node before = get(index - 1);\n            Node after = before.next;\n            Node temp = new Node(val);\n            before.next = temp;\n            temp.next = after;\n            after.prev = temp;\n            temp.prev = before;\n        }\n        length++;\n        return true;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) {\n            length--;\n            return removeFirst();\n        }\n        if (index == length - 1) {\n            length--;\n            return removeLast();\n        }\n        Node temp = get(index);\n        if (temp != null) {\n            Node before = temp.prev;\n            Node after = temp.next;\n            before.next = after;\n            after.prev = before;\n            length--;\n            return temp;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        DoublyLinkedList list = new DoublyLinkedList(1);\n        list.append(2);\n        list.append(3);\n        list.append(9);\n        list.append(12);\n        System.out.println(list.remove(1));\n//        list.insert(4, 91);\n//        System.out.println(list.set(2, 99));\n//        System.out.println(list.get(2).value);\n//        System.out.println(list.removeFirst().value);\n        DoublyLinkedList.printList(list);\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: '7cb6ea3c-6dda-4bc3-9b57-a53018dacc82',
          isFolder: false,
          name: 'Queue.java',
          code: 'public class Queue {\n    class Node {\n        int value;\n        Node next;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    Node head;\n    Node tail;\n    int length;\n    Queue(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n    Queue() {\n        head = tail = null;\n        length = 0;\n    }\n    Node enqueue(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n        return newNode;\n    }\n\n    Node dequeue() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        return temp;\n    }\n\n    public static void main(String[] args) {\n        Queue q = new Queue(10);\n        q.enqueue(4);\n        q.enqueue(19);\n        System.out.println(q.dequeue().value);\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: 'f182fd19-c7f2-46af-8fbf-248eb84926f3',
          isFolder: false,
          name: 'SinglyLinkedList.java',
          code: 'public class SinglyLinkedList {\n    static class Node {\n        int value;\n        Node next;\n        Node (int val) {\n            this.value = val;\n        }\n    }\n    int length;\n    private Node head;\n    private Node tail;\n    SinglyLinkedList(int value) {\n        Node newNode = new Node(value);\n        head = tail = newNode;\n        length = 1;\n    }\n    SinglyLinkedList() {\n        head = tail = null;\n        length = 0;\n    }\n\n//    Methods\n    public void prepend(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            newNode.next = head;\n            head = newNode;\n        }\n        length++;\n    }\n    public void append(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n    }\n    public Node removeLast() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            Node pre = head;\n            while (temp.next != null) {\n                pre = temp;\n                temp = temp.next;\n            }\n            tail = pre;\n            tail.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node removeFirst() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node get(int index) {\n        if (index >= length || index < 0) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public void insert(int index, int val) {\n        if (index < 0 || index > length) return;\n        else if (index == 0) {\n            prepend(val);\n            return;\n        } else if (index == length) {\n            append(val);\n            return;\n        }\n        Node temp = head;\n        for (int i = 0; i < index - 1; i++) {\n            temp = temp.next;\n        }\n        Node newNode = new Node(val);\n        newNode.next = temp.next;\n        temp.next = newNode;\n        length++;\n        return;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) return removeFirst();\n        if (index == length - 1) return removeLast();\n        Node prev = get(index - 1);\n        Node temp = prev.next;\n        prev.next = temp.next;\n        temp.next = null;\n        length--;\n        return temp;\n    }\n\n    public void reverse() {\n        Node temp = head;\n        head = tail;\n        tail = temp;\n        Node prev = null;\n        Node next = null;\n        for (int i = 0; i < length; i++) {\n            next = temp.next;\n            temp.next = prev;\n            prev = temp;\n            temp = next;\n        }\n    }\n\n    public int getLength() {\n        return length;\n    }\n    public String getString() {\n        Node temp = head;\n        StringBuilder sb = new StringBuilder();\n        while (temp != null) {\n            sb.append(temp.value).append(" ");\n            temp = temp.next;\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.append(1);\n        list.append(3);\n        list.append(5);\n        list.append(6);\n        System.out.println(list.getString());\n        list.reverse();\n        System.out.println(list.getString());\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: 'a9391bdc-2694-4cbe-9098-37e672042c31',
          isFolder: false,
          name: 'Stack.java',
          code: '// Using Singly linked list\n\npublic class Stack {\n    class Node {\n        Node next;\n        int value;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    private Node top;\n    private int height;\n    Stack(int val) {\n        top = new Node(val);\n        height = 1;\n    }\n//    Peek\n    public Node peek() {\n        return top;\n    }\n//    Push\n    public void push(int val) {\n        Node newNode = new Node(val);\n        if (height == 0) {\n            top = newNode;\n        } else {\n            newNode.next = top;\n            top = newNode;\n        }\n        height++;\n    }\n//    Pop\n    public Node pop() {\n        if (isEmpty()) {\n            return null;\n        }\n        Node temp = top;\n        top = top.next;\n        temp.next = null;\n        height--;\n        return temp;\n    }\n//    isEmpty\n    public boolean isEmpty() {\n        return height == 0;\n    }\n\n    public static void main(String[] args) {\n        Stack myStack = new Stack(10);\n        myStack.push(19);\n        myStack.push(13);\n        myStack.push(41);\n        myStack.push(25);\n//        System.out.println(myStack.pop().value);\n//        System.out.println(myStack.peek().value);\n        System.out.println(myStack.isEmpty());\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: 'e12f3c0d-d223-4249-bb6c-d0b5b0bb4f70',
          isFolder: false,
          name: 'BinarySearch.java',
          code: '// BS on 1D Arrays\npublic class BinarySearch {\n    //    Iterative Binary Search\n    public static int binarySearch(int[] A, int target) {\n        int start = 0;\n        int end = A.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (A[mid] == target) return mid;\n            if (A[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return -1;\n    }\n\n    //    Recursive Binary search\n    public static int binarySearch(int[] A, int target, int start, int end) {\n        if (start > end)\n            return -1;\n        int mid = start + (end - start) / 2;\n        if (A[mid] == target)\n            return mid;\n        if (A[mid] > target)\n            return binarySearch(A, target, start, mid - 1);\n        else\n            return binarySearch(A, target, mid + 1, end);\n    }\n\n    static int orderAgnosticBS(int arr[], int target) {\n        boolean isAscending = arr[0] > arr[arr.length - 1];\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = ((end - start) / 2) + start;\n            if (target == arr[mid]) return mid;\n            if (isAscending) {\n                if (target > arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return -1;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Search'],
        },
        {
          id: 'c7f1eebe-8eab-4ba4-8c9d-4440b3257336',
          isFolder: false,
          name: 'LinearSearch.java',
          code: 'public class LinearSearch {\n    static int linearSearch(int arr[], int target) {\n        for (int i = 0; i <= arr.length; i++) {\n            if (target == arr[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Search'],
        },
        {
          id: '6c6d370e-7a07-4004-886a-abf628f1c6f5',
          isFolder: false,
          name: 'BubbleSort.java',
          code: 'public class BubbleSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n      boolean swapped = false;\n      for (int j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          swap(arr, j, j + 1);\n          swapped = true;\n        }\n      }\n      if (!swapped) break;\n    }\n  }\n  \n  public static void bubbleSortRecursive(int[] arr, int n) {\n    if (n == 1) return;\n    boolean swapped = false;\n    for (int j = 0; j < n - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        swapped = true;\n      }\n    }\n    if (!swapped) return;\n    bubbleSortRecursive(arr, n - 1);\n  }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '7c98f7a3-f6fd-4747-8192-c77b4d1afd7d',
          isFolder: false,
          name: 'CyclicSort.java',
          code: 'public class CyclicSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void cyclicSort(int[] arr) {\n    int i = 0;\n    while (i < arr.length) {\n      if (arr[i] != arr[arr[i] - 1])\n        swap(arr, i, arr[i] - 1);\n      else\n        i++;\n    }\n  }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '9be964d3-3cbe-4fad-9c47-e2c17b548956',
          isFolder: false,
          name: 'InsertionSort.java',
          code: 'public class InsertionSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n  public static void insertionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 1; i < n - 1; i++) {\n      for (int j = i; j > 0; j--) {\n        if (arr[j] >= arr[j - 1])\n          break;\n        swap(arr, j, j-1);\n      }\n    }\n  }\n\n  public static void insertionSortRecursive(int[] arr, int i) {\n    if (i == arr.length-1) return;\n    for (int j = i; j > 0; j--) {\n      if (arr[j] >= arr[j - 1])\n        break;\n      swap(arr, j, j-1);\n    }\n    insertionSortRecursive(arr, i+1);\n  }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '295cbd71-54a3-462e-a366-dee9c7d45e0c',
          isFolder: false,
          name: 'MergeSort.java',
          code: 'public class MergeSort {\n  public static void mergeArray(int[] arr, int low, int mid, int high) {\n    int[] temp = new int[high - low + 1];\n    int left = low, right = mid + 1, i = 0;\n    while (left <= mid && right <= high) {\n      if (arr[left] <= arr[right])\n        temp[i++] = arr[left++];\n      else\n        temp[i++] = arr[right++];\n    }\n\n    while (left <= mid)\n      temp[i++] = arr[left++];\n\n    while (right <= high)\n      temp[i++] = arr[right++];\n\n    for (int j = 0; j < i; j++)\n      arr[j + low] = temp[j];\n  }\n\n  public static void mergeSort(int[] arr, int low, int high) {\n    if (low == high) {\n      return;\n    }\n    int mid = low + (high - low) / 2;\n    mergeSort(arr, low, mid);\n    mergeSort(arr, mid + 1, high);\n    mergeArray(arr, low, mid, high);\n  }\n\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '877abb72-125a-4b34-8390-32786a3447bf',
          isFolder: false,
          name: 'QuickSort.java',
          code: 'public class QuickSort {\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int partition(int[] A, int low, int high) {\n        int pivot = A[low];\n        int i = low, j = high;\n        while (i < j) {\n            while (A[i] <= pivot && i < high) i++;\n            while (A[j] > pivot && j > low) j--;\n            if (i < j) swap(A, i, j);\n        }\n        swap(A, j, low);\n        return j;\n    }\n    public static void quickSort(int[] A, int low, int high) {\n        if (low < high) {\n            int pIdx = partition(A, low, high);\n            quickSort(A, low, pIdx-1);\n            quickSort(A, pIdx+1, high);\n        }\n    }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '6c95497b-da2c-413e-8199-eac729796d84',
          isFolder: false,
          name: 'SelectionSort.java',
          code: 'public class SelectionSort {\n  public static void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++) {\n      int minIdx = i;\n      for (int j = i + 1; j < n; j++)\n        if (arr[minIdx] > arr[j])\n          minIdx = j;\n      if (i != minIdx) {\n        int temp = arr[i];\n        arr[i] = arr[minIdx];\n        arr[minIdx] = temp;\n      }\n    }\n  }\n\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: 'de8912d1-31a0-4b6b-879c-7cb934f899d6',
          isFolder: false,
          name: 'CycleDetectionArray.java',
          code: "// AKA Floyd's algorithm, cycle detection in an array, find the duplicate number in an array of [1 - N]\npublic class CycleDetectionArray {\n    public static int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
          link: 'https://leetcode.com/problems/find-the-duplicate-number',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: 'f3ebb9eb-266a-4cdc-9912-8d006f474f4f',
          isFolder: false,
          name: 'CycleDetectionLinkedList.java',
          code: '// Detect loop or cycle in a linked list\npublic class CycleDetectionLinkedList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(0);\n        ListNode temp = head;\n        temp.next = new ListNode(2);\n        temp = temp.next;\n        temp.next = new ListNode(4);\n        temp = temp.next;\n        temp.next = new ListNode(1);\n        temp = temp.next;\n        temp.next = new ListNode(0);\n//        Created a cycle\n        temp.next.next  = head.next.next;\n    }\n}',
          link: 'https://leetcode.com/problems/linked-list-cycle',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '582a06d8-d248-4785-a95d-ad36becff756',
          isFolder: false,
          name: 'DutchNationalFlagAlgorithm.java',
          code: "// Dutch's national flag algorithm\n\nimport java.util.Arrays;\n\npublic class DutchNationalFlagAlgorithm {\n    public static int[] sort012(int[] arr) {\n        int low = 0, mid = 0, high = arr.length - 1;\n        while (mid <= high) {\n            if (arr[mid] == 0) {\n                int temp = arr[low];\n                arr[low] = arr[mid];\n                arr[mid] = temp;\n                low++;\n                mid++;\n            } else if (arr[mid] == 1) mid++;\n            else {\n                int temp = arr[high];\n                arr[high] = arr[mid];\n                arr[mid] = temp;\n                high--;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 0, 1, 2};\n        int[] ans = sort012(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
          link: 'https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '44986c9f-93a5-44d9-a0d9-96c7a2c0719b',
          isFolder: false,
          name: 'FastExponentiation.java',
          code: 'public class FastExponentiation {\n    public static int power(int a, int n) {\n        if (n == 0) return 1;\n        else if (n == 1) return a;\n\n        int r = power(a, n/2);\n\n        if (n%2 == 0) return r*r;\n        return r*a*r;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '88739651-3580-4943-867e-d40647c7b10d',
          isFolder: false,
          name: 'GCD.java',
          code: 'public class GCD {\n//    a = big, b = small\n    public static int getGCD(int a, int b) {\n        if (a%b == 0) return b;\n        return getGCD(b, a%b);\n    }\n\n    public static void main(String[] args) {\n        int ans = getGCD(51, 24);\n        System.out.println(ans);\n    }\n}',
          link: null,
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '56ce5c0a-2a77-4d3b-9c0c-163bfaafafcc',
          isFolder: false,
          name: 'KadanesAlgorithm.java',
          code: "// Largest Sum Contiguous Subarray (Kadane's Algorithm)\npublic class KadanesAlgorithm {\n    public static int maxSum(int[] nums) {\n        int sum = 0;\n        int maxSum = 0;\n        for (int num : nums) {\n            sum += num; // Increment\n            maxSum = Math.max(maxSum, sum); // Maximise\n            if (sum < 0) sum = 0; // Check to reset\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, -3, 4, -1, -2, 1, 5, -3};\n        int ans = maxSum(arr);\n        System.out.println(ans);\n    }\n}",
          link: 'https://www.geeksforgeeks.org/largest-sum-contiguous-subarray',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '512ed611-0bff-4882-852c-86d8569ee55c',
          isFolder: false,
          name: 'MooresVotingAlgorithm.java',
          code: '//  Boyer-Moore Majority Voting Algorithm: used to find the majority element among the given elements that have more than N/ 2 occurrences.\npublic class MooresVotingAlgorithm {\n    public static int findMajority(int[] N) {\n        int element = -1, count = 0;\n        for (int j : N) {\n            if (count == 0) {\n                element = j;\n                count = 1;\n            } else if (element == j) count++;\n            else count--;\n        }\n        return element;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 2, 2, 1, 1, 2, 3, 4};\n        int majority = findMajority(arr);\n        System.out.println(" The majority element is : " + majority);\n    }\n}',
          link: 'https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '9df11fec-e5a6-4a1d-9fe2-4dba7dc728e4',
          isFolder: false,
          name: 'SieveOfEratosthenes.java',
          code: 'import java.util.*;\n\npublic class SieveOfEratosthenes {\n    public static int sieve(int n) {\n        List<Integer> ans = new ArrayList<>();\n        if (n <= 2) return 0;\n        int count = 0;\n        boolean[] M = new boolean[n];\n        for (int i = 2; i < n; i++) {\n            if (!M[i]) {\n                ans.add(i);\n                count++;\n                for (int j = 2* i; j < n; j += i) {\n                    M[j] = true;\n                }\n            }\n        }\n        System.out.println(ans);\n        return count;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '64d6bc4f-3b85-4b74-9212-bac94175da19',
          isFolder: false,
          name: 'SubsequencesOfAString.java',
          code: 'import java.util.*;\n\npublic class SubsequencesOfAString {\n    public static ArrayList<String> subsequences(String str) {\n        // Using power set technique\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n}',
          link: 'https://www.codingninjas.com/studio/problems/subsequences-of-string_985087',
          notes: '',
          tags: ['Special Algorithms'],
        },
      ],
    },
    {
      id: '82ade028-b6ad-4f5e-98d0-cf9cfc301884',
      isFolder: true,
      name: 'DSAPrepQuestions',
      content: [
        {
          id: 'f637003d-6daa-4048-b71a-12f592633eb2',
          isFolder: true,
          name: 'Combined',
          content: [
            {
              id: 'd9e0fccd-a766-492d-8393-4adc679f1559',
              isFolder: false,
              name: 'AddToArrayFormOfInteger.java',
              code: 'import java.util.*;\n\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            num[i] += k;\n            k = num[i] / 10;\n            ans.add(0, num[i] % 10);\n        }\n        while (k != 0) {\n            ans.add(0, k % 10);\n            k /= 10;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/add-to-array-form-of-integer',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'f075fc1a-bd9c-419d-840c-bca165423d1a',
              isFolder: false,
              name: 'CellWithOddValuesInMatrix.java',
              code: 'public class CellWithOddValuesInMatrix {\n    public int oddCells(int m, int n, int[][] I) {\n        // M = rows, N = cols\n        boolean[] row = new boolean[m];\n        boolean[] col = new boolean[n];\n        int r=0, c=0;\n        for (int i = 0; i < I.length; i++) {\n            row[I[i][0]] ^= true;\n            col[I[i][1]] ^= true;\n        }\n        for (int j = 0; j < n; j++)\n            if (col[j]) c++;\n\n        for (int j = 0; j < m; j++)\n            if (row[j]) r++;\n\n        // r(n-c) + c(m-r)\n        // rn + cm - rc - rc\n        return r*n + c*m - 2*r*c;\n    }\n}',
              link: 'https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '2b7d261a-c369-476f-95b4-0eb7f40c20de',
              isFolder: false,
              name: 'GoodArray.java',
              code: 'public class GoodArray {\n    public boolean isGoodArray(int[] N) {\n        int ans = N[0];\n        for (int i = 1; i < N.length; i++)\n            ans = GCD(N[i], ans);\n        return ans == 1;\n    }\n    public int GCD(int a, int b) {\n        if (a%b == 0) return b;\n        return GCD(b, a%b);\n    }\n}',
              link: 'https://leetcode.com/problems/check-if-it-is-a-good-array/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '0a6aa63e-12d4-45d8-a38d-9b5bc3877b30',
              isFolder: false,
              name: 'IsStringASubSequence.java',
              code: 'public class IsStringASubSequence {\n    public static boolean check(String s1, String s2) {\n        int i = 0, j = 0;\n        return checkRecursively(s1, s2, i, j);\n\n        // int i = 0, j = 0;\n        // while (i < A.length() && j < B.length()) {\n        //     if (A.charAt(i) == B.charAt(j)) i++;\n        //     j++;\n        // }\n        // return i >= A.length();\n    }\n    public static boolean checkRecursively(String s1, String s2, int i, int j) {\n        if (i >= s1.length()) return true;\n        if (j >= s2.length()) return false;\n        if (s1.charAt(i) == s2.charAt(j)) {\n            return checkRecursively(s1, s2, i+1, j+1);\n        }\n        return checkRecursively(s1, s2, i, j+1);\n    }\n    public static void main(String[] args) {\n        String s1 = "ABCD";\n        String s2 = "ADB";\n        System.out.println(check(s1, s2));\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/check-for-subsequence4930/1',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '3199cfa8-197d-4abf-97fc-7012733542bf',
              isFolder: false,
              name: 'JumpGame.java',
              code: 'public class JumpGame {\n    public boolean canJump(int[] nums) {\n        int n = nums.length - 1;\n        int goal = n;\n        for (int i = n; i >= 0; i--) {\n            if (i + nums[i] >= goal)\n                goal = i;\n        }\n        return goal == 0;\n    }\n}',
              link: 'https://leetcode.com/problems/jump-game/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '03226304-a85a-4ea3-a9b6-e5f79edefa08',
              isFolder: false,
              name: 'LeftMostRepeatingCharacter.java',
              code: "public class LeftMostRepeatingCharacter {\n    public static int indexLeftMostRepeatedCharacter (String str) {\n//        Brute force approach: O(N^2)\n//        Use 2 nested loops to check every character's occurrence it found break loop and return index\n//        for (int i = 0; i < str.length(); i++) {\n//            char ch = str.charAt(i);\n//            for (int j = i+1; j < str.length(); j++) {\n//                if (str.charAt(j) == ch) return i;\n//            }\n//        }\n//        return -1;\n\n//        Better Solution: O(2N)\n//        Uses 1 integer array to store count of all characters in 1 iteration, then in next iteration is count is > 1 that's the index else -1\n//        int[] bucket = new int[26];\n//        for (int i = 0; i < str.length(); i++) {\n//            bucket[str.charAt(i) - 'a']++;\n//        }\n//        for (int j = 0; j < str.length(); j++) {\n//            if (bucket[str.charAt(j) - 'a'] > 1) return j;\n//        }\n//        return -1;\n\n//        Best Solution: O(N)\n//        Use the bucket concept along with a min index value variable that will hold the min possible value of index as I traverse the array\n        int[] bucket = new int[26];\n        int minIdx = Integer.MAX_VALUE;\n        for (int i = str.length() - 1; i >= 0; i--) {\n            int idx = str.charAt(i) - 'a';\n            bucket[idx]++;\n            if (bucket[idx] > 1) {\n                minIdx = i;\n            }\n        }\n        if (minIdx == Integer.MAX_VALUE) return -1;\n        return minIdx;\n    }\n    public static void main(String[] args) {\n//        Only considering lowercase alphabets\n        String s = \"geeksforgeeks\";\n        int ans = indexLeftMostRepeatedCharacter(s);\n        System.out.println(ans);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'b0c45870-2891-472d-bafb-edacc23ce86d',
              isFolder: false,
              name: 'LongestOddEvenSubarray.java',
              code: "public class LongestOddEvenSubarray {\n    public static int longestOddEvenCount (int[] arr) {\n//        Brute force\n//        int count = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int c = 1;\n//            for (int j = i+1; j < arr.length; j++) {\n//                if (arr[j]%2 == 0 && arr[j-1]%2!= 0 || arr[j]%2 != 0 && arr[j-1]%2== 0) {\n//                    c++;\n//                } else {\n//                    break;\n//                }\n//            }\n//            count = Math.max(c, count);\n//        }\n//        return count;\n\n//        Optimised: Kadane's algorithm\n        int count = 1;\n        int max = 1;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i]%2 == 0 && arr[i-1]%2!= 0 || arr[i]%2 != 0 && arr[i-1]%2== 0) {\n                count++;\n                max = Math.max(count, max);\n            } else {\n                count = 1;\n            }\n        }\n        return max;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 10, 20, 6, 3, 8};\n        int count = longestOddEvenCount(arr);\n        System.out.println(count);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '72e851b5-ac52-4c15-9b4f-08347ba6fa27',
              isFolder: false,
              name: 'MaxCircularSubarraySum.java',
              code: "public class MaxCircularSubarraySum {\n    public static int normalSubarrayMaxSum(int[] arr) {\n        int sum = arr[0];\n        int maxSum = arr[0];\n        int n = arr.length;\n        for (int i = 1; i < n; i++) {\n            sum += arr[i];\n            maxSum = Math.max(sum, maxSum);\n            if (sum < 0) sum = 0;\n        }\n        return maxSum;\n    }\n\n    public static int maxCircularSubarraySum(int[] arr) {\n//        Brute force approach\n//        int n = arr.length;\n//        int sum = arr[0];\n//        for (int i = 0; i < n; i++) {\n//            int curr_sum = arr[i];\n//            int curr_max = arr[i];\n//            for (int j = 1; j < n; j++) {\n//                curr_sum += arr[(i+j)%n];\n//                curr_max = Math.max(curr_sum, curr_max);\n//            }\n//            sum = Math.max(sum, curr_max);\n//        }\n//        return sum;\n\n//        Optimised approach\n        int normalSum = normalSubarrayMaxSum(arr);\n        if (normalSum < 0) return normalSum;\n        int circularSum = arr[0];\n        int sum = arr[0];\n        int wholeSum = arr[0];\n//        We can also invert the array and get normal max sum using same function instead of modifying kadane's algorithm\n//        In that case we add it with wholeSum\n        for (int i = 1; i < arr.length; i++) {\n            wholeSum += arr[i];\n            sum += arr[i];\n            circularSum = Math.min(circularSum, sum);\n            if (sum > 0) sum = 0;\n        }\n        return Math.max(normalSum, wholeSum - circularSum);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-10, -5, -5, -1, -2, -4};\n        int ans = maxCircularSubarraySum(arr);\n        System.out.println(ans);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'c68f42f6-c4fe-452a-a3f1-94ebc0a1e9f6',
              isFolder: false,
              name: 'NumberOfGoodPairs.java',
              code: 'import java.util.*;\n\npublic class NumberOfGoodPairs {\n    public static int numIdenticalPairs(int[] nums) {\n        // O(n) solution\n        int numberOfGoodPairs = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i: nums) {\n            if (hm.containsKey(i)) {\n                numberOfGoodPairs += hm.get(i);\n            }\n            hm.put(i, hm.getOrDefault(i, 0) + 1);\n        }\n        return numberOfGoodPairs;\n\n        // O(n^2) solution\n        // int numberOfGoodPairs = 0;\n        // for (int i=0; i < nums.length -1; i++) {\n        //     for (int j=i+1; j < nums.length; j++) {\n        //         if (nums[i] == nums[j]) {\n        //             numberOfGoodPairs++;\n        //         }\n        //     }\n        // }\n        // return numberOfGoodPairs;\n    }\n}',
              link: 'https://leetcode.com/problems/number-of-good-pairs/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '08d285c1-d58a-4d89-959a-d6e3abaa8c79',
              isFolder: false,
              name: 'NumbersSmallerThanCurrentNumber.java',
              code: 'public class NumbersSmallerThanCurrentNumber {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] counts = new int[102];\n        for (int num : nums)\n            counts[num]++;\n        for (int j = 1; j < counts.length; j++)\n            counts[j] += counts[j - 1];\n        int[] ans = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0)\n                ans[i] = 0;\n            else\n                ans[i] = counts[nums[i] - 1];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'd27fa67c-fe6f-4e2d-8466-f90e51a9341f',
              isFolder: false,
              name: 'SpiralMatrix3.java',
              code: 'public class SpiralMatrix3 {\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\n        int[] directions = {0, 1, 0, -1, 0};\n        int[][] ans = new int[rows*cols][2];\n        ans[0] = new int[] {rStart, cStart};\n        int len = 0, d = 0, ptr = 1;\n        while (ptr < ans.length) {\n            if (d == 0 || d == 2) len++;\n            for (int i = 0; i < len; i++) {\n                rStart += directions[d];\n                cStart += directions[d+1];\n                if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {\n                    ans[ptr++] = new int[] {rStart, cStart};\n                }\n            }\n            d = ++d%4;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/spiral-matrix-iii/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '8c341d77-38bd-462a-9eb4-91781c00cc2f',
              isFolder: false,
              name: 'WavePrint.java',
              code: 'import java.util.Arrays;\n\npublic class WavePrint {\n    public static int[] wavePrint(int arr[][], int nRows, int mCols) {\n        // Write your code here.\n        int[] ans = new int[nRows*mCols];\n        int ptr = 0;\n        for (int i = 0; i < mCols; i++) {\n            if ((i&1) == 0) {\n                // TB\n                for (int j = 0; j < nRows; j++) {\n                    ans[ptr++] = arr[j][i];\n                }\n            } else {\n                // BT\n                for (int j = nRows - 1; j >= 0; j--) {\n                    ans[ptr++] = arr[j][i];\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12}\n        };\n        int[] ans = wavePrint(mat, mat.length, mat[0].length);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/print-like-a-wave_893268',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '86b48831-821a-4df1-8603-5c63165aee6b',
              isFolder: false,
              name: 'ArrangingCoins.java',
              code: 'public class ArrangingCoins {\n    public static int arrangeCoins(int n) {\n//        Brute force solution\n//        if (n <= 1) return n;\n//        int i;\n//        for (i = 0; i < n; i++) {\n//            long ans = ((long) i *(i+1))/2;\n//            if (ans > n) break;\n//        }\n//        return i-1;\n\n//        Better solution\n//        long start = 0, end = n;\n//        while (start <= end) {\n//            long mid = start + (end - start)/2;\n//            long val = (mid * (mid+1))/2;\n//            if (val == n) return (int) mid;\n//            if (val > n) {\n//                end = mid - 1;\n//            } else {\n//                start = mid + 1;\n//            }\n//        }\n//        return (int) end;\n\n//        Optimised solution\n//         Equation: k(k+1)/2 = n\n//         k^2 + k = 2*n\n//         k^2 + k + 1/4 = 2*n + 1/4\n//         (k + 1/2)^2 = 2n + 1/4\n//         k = sqrt(2n + 1/4) - 1/2\n        return (int) (Math.sqrt(2L*n + 0.25) - 0.5);\n    }\n\n    public static void main(String[] args) {\n        int ans = arrangeCoins(1804289383);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/arranging-coins/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '10698e76-01be-4049-a4a8-8379f61b7271',
              isFolder: false,
              name: 'FindRightInterval.java',
              code: 'import java.util.*;\npublic class FindRightInterval {\n    public static int[] findRightInterval(int[][] intervals) {\n        int[][] copy = new int[intervals.length][2];\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            copy[i] = intervals[i];\n            hm.put(intervals[i][0], i);\n        }\n        Arrays.sort(copy, Comparator.comparingInt(a -> a[0]));\n        int[] ans = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            int pos = search(copy, intervals[i][1]);\n            ans[i] = pos == -1 ? pos : hm.get(copy[pos][0]);\n        }\n        return ans;\n    }\n    public static int search(int[][] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid][0] == target) return mid;\n            if (arr[mid][0] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        if (start == arr.length) return -1;\n        return start;\n    }\n}',
              link: 'https://leetcode.com/problems/find-right-interval/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '01f9edfb-087f-4147-b8d0-c6e927a771b4',
              isFolder: false,
              name: 'FrequencyOfMostFrequentElement.java',
              code: 'import java.util.*;\n\npublic class FrequencyOfMostFrequentElement {\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums);\n        int l = 0, r = 0;\n        long maxLen = 1, total = 0;\n        while (r < nums.length) {\n            total += nums[r];\n            while ((long) nums[r] * (r - l + 1) > total + k) {\n                total -= nums[l++];\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n            r++;\n        }\n        return (int) maxLen;\n    }\n}',
              link: 'https://leetcode.com/problems/frequency-of-the-most-frequent-element/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '6b1973b2-917e-4e16-84f4-9436363d2c3f',
              isFolder: false,
              name: 'MaxValueAtGivenIndexInBoundedArray.java',
              code: 'public class MaxValueAtGivenIndexInBoundedArray {\n    public long getFormulaSum(int count, long mid) {\n        long c = Math.min(count, mid-1);\n        return c*mid - c*(c+1)/2 + Math.max(count - (mid-1), 0); // Adds extra 1s if any\n    }\n    public int maxValue(int n, int index, int maxSum) {\n        long start = 1;\n        long end = maxSum;\n        long result = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long totalSum = getFormulaSum(index, mid);\n            totalSum += mid;\n            totalSum += getFormulaSum(n-index-1, mid);\n            if (totalSum <= maxSum) {\n                result = mid;\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return (int)result;\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '32f610e4-ec8c-48d1-9e6c-1e80ce773e3d',
              isFolder: false,
              name: 'MinAbsoluteSumDifference.java',
              code: 'import java.util.*;\npublic class MinAbsoluteSumDifference {\n    public int minAbsoluteSumDiff(int[] N, int[] M) {\n        int[] abs = new int[N.length];\n        long maxSum = 0;\n        for (int i = 0; i < N.length; i++) {\n            abs[i] = Math.abs(N[i] - M[i]);\n            maxSum += abs[i];\n        }\n        Arrays.sort(N);\n        int max = 0;\n        for (int j = 0; j < N.length; j++) {\n            int minValue = Math.abs(M[j] - bSearch(N, M[j]));\n            int diff = abs[j] - minValue;\n            max = Math.max(max, diff);\n        }\n        return (int)((maxSum - max) % 1000000007);\n    }\n    public static int bSearch(int[] N, int target){\n        int start = 0, end = N.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (N[mid] == target) return N[mid];\n            if (N[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        if (start == N.length) start--;\n        if (end == -1) end++;\n        int diff1 = Math.abs(target - N[start]);\n        int diff2 = Math.abs(target - N[end]);\n        if (diff1 > diff2) return N[end];\n        return N[start];\n    }\n}',
              link: 'https://leetcode.com/problems/minimum-absolute-sum-difference/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '5d0f4a32-11dc-4f20-bbb0-e8bdb1b4a93c',
              isFolder: false,
              name: 'ReachANumber.java',
              code: 'public class ReachANumber {\n    public static long formula(long n) {\n        return (n*(n+1))>>1;\n    }\n\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        long start = 1, end = target;\n        int steps = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long distance = formula(mid);\n            if (distance >= target) {\n                steps = (int) mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        long dist = formula(steps) - target;\n        if ((dist&1) != 0) {\n            return steps + ((steps&1) == 0 ? 1 : 2);\n        }\n        return steps;\n    }\n}',
              link: 'https://leetcode.com/problems/reach-a-number/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '65738320-63eb-4782-ac36-2b5482acb666',
              isFolder: false,
              name: 'SquareRootWithPrecision.java',
              code: 'public class SquareRootWithPrecision {\n    public static int sqrt(int n) {\n        int start = 0, end = n;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            int root = mid * mid;\n            if (root == n) return mid;\n            if (root > n)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int getClosestSqrt(double n, int val, int num) {\n        int start = 0, end = 9;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            double x = n + mid / (double) val;\n            double root = x * x;\n            if (root < num)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return end;\n    }\n\n    public static double getSquareRootWithPrecision(int n, int p) {\n        double num = sqrt(n);\n        int increment = 10;\n        for (int i = 0; i < p; i++) {\n            int x = getClosestSqrt(num, increment, n); // log10\n            num += (double) x / increment;\n            increment *= 10;\n        }\n        return num;\n    }\n\n    public static void main(String[] args) {\n        int n = 40;\n        int p = 3;\n        double ans = getSquareRootWithPrecision(n, p);\n        System.out.printf("%.{%d}f", p, ans);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/find-square-root-number-upto-given-precision-using-binary-search/',
              notes: '',
              tags: ['Maths'],
            },
            {
              id: 'b9ddeb02-c29a-4608-8125-114a971d88a6',
              isFolder: false,
              name: 'XorOfRange.java',
              code: 'public class XorOfRange {\n    public static void main(String[] args) {\n        int n = 9;\n        int ans1 = computeXor(n);\n        int ans2 = computeXorEfficient(n);\n        System.out.println(ans1 + "  " + ans2);\n    }\n\n    static int computeXor(int n) {\n        if (n == 0) return 0;\n        int uni = 0;\n        for (int i = 1; i <= n; i++) {\n            uni = uni ^ i;\n        }\n        return uni;\n    }\n\n    static int computeXorEfficient(int n) {\n        int rem = n % 4;\n        switch (rem) {\n            case 0 -> {\n                return n;\n            }\n            case 1 -> {\n                return 1;\n            }\n            case 2 -> {\n                return n + 1;\n            }\n        }\n        return 0;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/find-xor-of-numbers-from-the-range-l-r/',
              notes: '',
              tags: ['Maths'],
            },
            {
              id: '8bac8d53-9c7b-4694-a354-f89248d6c10a',
              isFolder: false,
              name: 'Fibo.java',
              code: 'public class Fibo {\n    public static long fibo(int n, long[] temp) {\n        if (n <= 1) return n;\n        if (temp[n] != 0) return temp[n];\n        temp[n] = fibo(n-1, temp) + fibo(n-2, temp);\n        return temp[n];\n    }\n    // Optimised\n    public static long getFibo2(int n) {\n        long[] arr = new long[n + 1];\n        arr[1] = 1;\n        return fibo(n, arr);\n    }\n\n    // slow\n    public static long getFibo(int n) {\n        if (n <= 1) return n;\n        return getFibo(n-1) + getFibo(n-2);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'b4f30617-2cae-4520-8f9f-e09663243f7a',
              isFolder: false,
              name: 'LetterCombinationsOfPhoneNumber.java',
              code: 'import java.util.*;\npublic class LetterCombinationsOfPhoneNumber {\n    public List<String> letterCombinations(String digs) {\n        List<String> ans = new ArrayList<>();\n        if (digs.length() == 0) return ans;\n        StringBuilder sb = new StringBuilder();\n        String[] mappings = {"", "", "abc", "def", "ghi", "jkl","mno","pqrs","tuv","wxyz"};\n        solve(mappings, digs, ans, sb, 0);\n        return ans;\n    }\n    public static void solve(String[] mappings, String digs, List<String> ans, StringBuilder sb, int idx) {\n        // Base case\n        if (idx >= digs.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        // Get index\n        int index = digs.charAt(idx) - \'0\';\n        String val = mappings[index];\n        // Get all letters from mapping[index]\n        for (int i = 0; i < val.length(); i++) {\n            sb.append(val.charAt(i));\n            solve(mappings, digs, ans, sb, idx + 1);\n            sb.replace(sb.length() - 1, sb.length(), "");\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '3ec058d0-09c3-424f-9323-33ddc07694be',
              isFolder: false,
              name: 'MatrixFindPaths.java',
              code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MatrixFindPaths {\n    //    Given a n x m matrix, you are only allowed to move right and down direction\n//    find the of paths to reach the corner right of the matrix\n    public static void findPaths(int m, int n, int i, int j, List<String> paths, String path) {\n        if (i >= m || j >= n) return;\n        if (i == m - 1 && j == n - 1) {\n            paths.add(path);\n            return;\n        }\n        findPaths(m, n, i, j+1, paths, path+"R");\n        findPaths(m, n, i+1, j, paths, path + "D");\n    }\n\n    public static void main(String[] args) {\n        List<String> ans = new ArrayList<>();\n        findPaths(3, 2, 0, 0, ans, "");\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '24db31d1-9424-4d7e-a643-874e886a6e2d',
              isFolder: false,
              name: 'NKnightsProblem.java',
              code: "import java.util.Arrays;\n\npublic class NKnightsProblem {\n    static boolean isPossible(char[][] board, int row, int col) {\n//        Coordinates\n        int[][] coordinates = {\n                {col - 2, row - 1},\n                {col - 1, row - 2},\n                {col + 1, row - 2},\n                {col + 2, row - 1},\n                {col + 2, row + 1},\n                {col + 1, row + 2},\n                {col - 1, row + 2},\n                {col - 2, row + 1},\n        };\n        for (int[] coordinate : coordinates) {\n            int r = coordinate[1], c = coordinate[0];\n            if (r >= 0 && c >= 0 && r < board.length && c < board.length)\n                if (board[r][c] == 'K') return false;\n        }\n        return true;\n    }\n\n    static void solve(char[][] board, int col) {\n        if (col == board.length) {\n            for (char[] chars : board)\n                System.out.println(Arrays.toString(chars));\n            System.out.println();\n            return;\n        }\n        for (int row = 0; row < board.length; row++) {\n            if (isPossible(board, row, col)) {\n                board[row][col] = 'K';\n                solve(board, col + 1);\n                board[row][col] = '0';\n            }\n        }\n\n    }\n\n    public static void nKnights(int n, char[][] board) {\n        solve(board, 0);\n    }\n\n    public static void main(String[] args) {\n        int n = 1;\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], '0');\n        }\n        nKnights(n, board);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'd631cf8f-ba62-46bc-a1ff-78f4bc407638',
              isFolder: false,
              name: 'Permutations.java',
              code: 'import java.util.*;\npublic class Permutations {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int idx) {\n        // Base case\n        if (idx >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n\n        for (int i = idx; i < nums.length; i++) {\n            op.add(nums[i]);\n            swap(nums, idx, i);\n            solve(nums, ans, op, idx + 1);\n            swap(nums, idx, i);\n            op.remove(op.size() - 1);\n        }\n    }\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}',
              link: 'https://leetcode.com/problems/permutations/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '156693ae-4e45-4c63-83a4-91e77bff253a',
              isFolder: false,
              name: 'PermutationsOfString.java',
              code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsOfString {\n    public static void swap(StringBuilder s, int i, int j) {\n        char temp = s.charAt(i);\n        s.setCharAt(i, s.charAt(j));\n        s.setCharAt(j, temp);\n    }\n    public static void getPermutations(StringBuilder s, List<String> ans, int idx) {\n        if (idx == s.length()) {\n            ans.add(s.toString());\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            swap(s, idx, i);\n            getPermutations(s, ans, idx + 1);\n            swap(s, idx, i);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<String> ans = new ArrayList<>();\n        StringBuilder s = new StringBuilder("ABC");\n        getPermutations(s, ans, 0);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '13ef48b9-0e00-42c2-a5d5-7ef500a0e168',
              isFolder: false,
              name: 'RopeCuttingProblem.java',
              code: 'public class RopeCuttingProblem {\n    public static int maxCuts(int n, int a, int b, int c, int count) {\n//        Base case\n        if (n == 0) return count;\n        if (n < 0) return -1;\n        int aCut = maxCuts(n - a, a, b, c, count + 1);\n        int bCut = maxCuts(n - b, a, b, c, count + 1);\n        int cCut = maxCuts(n - c, a, b, c, count + 1);\n        return Math.max(aCut, Math.max(bCut, cCut));\n    }\n\n    public static void main(String[] args) {\n        int ans = maxCuts(9,2,2,2, 0);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '4afc33af-c302-4c01-9421-04c90996dd4f',
              isFolder: false,
              name: 'SubsequencesOfString.java',
              code: 'import java.util.*;\n// This is the same question as power set but the solution is using recursion\npublic class SubsequencesOfString {\n    public static void getSubsequences(String str, ArrayList<String> ans, StringBuilder sb, int index) {\n        if (index >= str.length()) {\n            if (sb.length() != 0) {\n                ans.add(sb.toString());\n            }\n            return;\n        }\n//        Exclude\n        getSubsequences(str, ans, sb, index+1);\n//        Include\n        sb.append(str.charAt(index));\n        getSubsequences(str, ans, sb, index+1);\n        sb.replace(sb.length() - 1, sb.length(),"");\n    }\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getSubsequences(str, ans, sb, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences("abc");\n        System.out.println(ans);\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/subsequences-of-string_985087',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'b85e644d-cab1-459d-9671-78005d69b296',
              isFolder: false,
              name: 'SubsetDuplicate.java',
              code: 'import java.util.*;\n\npublic class SubsetDuplicate {\n\n    public static void solve(int[] arr, List<List<Integer>> ans) {\n        ans.add(new ArrayList<>());\n        for (int i = 0; i < arr.length; i++) {\n            int n = ans.size();\n            int start = 0;\n            if (i > 0 && arr[i] == arr[i-1]) {\n                start = n/2;\n            }\n            for (int j = start; j < n; j++) {\n                List<Integer> list = new ArrayList<>(ans.get(j));\n                list.add(arr[i]);\n                ans.add(list);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2};\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, ans);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '5a664718-083b-4902-86fe-327014ca635b',
              isFolder: false,
              name: 'Subsets.java',
              code: 'import java.util.*;\n\npublic class Subsets {\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int index) {\n        if (index >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n//        Exclude\n        solve(nums, ans, op, index+1);\n//        Include\n        op.add(nums[index]);\n        solve(nums, ans, op, index+1);\n        op.remove(op.size() - 1);\n    }\n    public static List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1,2,3};\n        List<List<Integer>> ans =  subsets(nums);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '7a84d1d0-ca10-427b-b7cb-d3ed11d2a3b6',
              isFolder: false,
              name: 'TowerOfHanoi.java',
              code: 'import java.util.*;\n\npublic class TowerOfHanoi {\n    public static void towerOfHanoi(int n, String src, String helper, String dest) {\n        if (n == 1) {\n            System.out.println("Transferring " + n + " from: " + src + " to: " + dest);\n            return;\n        }\n        towerOfHanoi(n-1, src,  dest, helper);\n        System.out.println("Transferring " + n + " from: " + src + " to: " + dest);\n        towerOfHanoi(n-1, helper, src, dest);\n    }\n\n    public static void solve(int n, int src, int helper, int dest, ArrayList<ArrayList<Integer>> ans) {\n        if (n == 1) {\n            ans.add(new ArrayList<>(Arrays.asList(src, dest)));\n            return;\n        }\n        solve(n - 1, src, helper, dest, ans);\n        ans.add(new ArrayList<>(Arrays.asList(src, dest)));\n        solve(n - 1, helper, src, dest, ans);\n    }\n    public static void main(String[] args) {\n        towerOfHanoi(3, "S", "h", "D");\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '29716d78-b228-437e-a2dd-fd16d2252cec',
              isFolder: false,
              name: 'AssignCookies.java',
              code: 'import java.util.Arrays;\n\npublic class AssignCookies {\n    public static int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int gLast = g.length - 1;\n        int sLast = s.length - 1;\n        int count = 0;\n        while (gLast >= 0 && sLast >= 0) {\n            if (g[gLast] <= s[sLast]) {\n                gLast--;\n                sLast--;\n                count++;\n            } else {\n                gLast--;\n            }\n        }\n        return count;\n    }\n}',
              link: 'https://leetcode.com/problems/assign-cookies/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'f916cd7d-fe31-4604-af1d-7bd284de3b80',
              isFolder: false,
              name: 'CanMakeAPFromSequence.java',
              code: 'public class CanMakeAPFromSequence {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    public static boolean canMakeArithmeticProgression(int[] arr) {\n//        Brute force\n//         Arrays.sort(arr);\n//         int diff = arr[1] - arr[0];\n//         for (int i = 1; i < arr.length; i++) {\n//             if (arr[i] - arr[i-1] != diff) return false;\n//         }\n//         return true;\n\n//        Optimal solution\n        int min = Integer.MAX_VALUE, max =Integer.MIN_VALUE;\n        for (int num: arr){\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int n = arr.length;\n//        If difference is not perfectly divisible then return false\n        if ((max - min) % (n - 1) != 0) return false;\n//        To get the difference between any 2 element in a AP\n        int diff = (max - min) / (n - 1);\n        int i = 0;\n        while (i < n) {\n            if (arr[i] == min + i*diff) i++;\n            else if ((arr[i] - min)%diff != 0) return false;\n            else {\n                int j = (arr[i] - min)/diff;\n                if (arr[i] == arr[j]) return false;\n                swap(arr, i, j);\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13, 12, -12, 9, 9, 16, 7, -10, -20, 0, 18, -1, -20, -10, -8, 15, 15, 16, 2, 15};\n        System.out.println(canMakeArithmeticProgression(arr));\n    }\n}',
              link: 'https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'c4e6fd53-6bde-4b4e-a3db-0aa500e5a33d',
              isFolder: false,
              name: 'InsertionSortList.java',
              code: 'public class InsertionSortList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) {\n            this.val = val;\n        }\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public static ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null)  return head;\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = head;\n        ListNode curr = head.next;\n        while (curr != null) {\n            if (curr.val >= prev.val) {\n                prev = curr;\n                curr = curr.next;\n                continue;\n            }\n            ListNode temp = dummy;\n            while (curr.val > temp.next.val) {\n                temp = temp.next;\n            }\n            prev.next = curr.next;\n            curr.next = temp.next;\n            temp.next = curr;\n            curr = prev.next;\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = insertionSortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + " => ");\n            temp = temp.next;\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/insertion-sort-list',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'aa970252-a028-4e74-8a0f-24b3d43330b5',
              isFolder: false,
              name: 'LargestNumber.java',
              code: 'import java.util.*;\npublic class LargestNumber {\n    public String largestNumber(int[] nums) {\n        Comparator<String> comp = (i, j) -> (j+i).compareTo(i+j);\n        List<String> list = new ArrayList<>();\n        for (int num : nums) {\n            list.add(String.valueOf(num));\n        }\n        list.sort(comp);\n        StringBuilder sb = new StringBuilder();\n        for (String l : list) {\n            sb.append(l);\n        }\n        return String.valueOf(Integer.parseInt(String.valueOf(sb)));\n    }\n\n}',
              link: 'https://leetcode.com/problems/largest-number/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'b873d794-e1cf-40b0-830b-f575639a3373',
              isFolder: false,
              name: 'MaxProductOfTwoElementsInAnArray.java',
              code: 'public class MaxProductOfTwoElementsInAnArray {\n    public int maxProduct(int[] nums) {\n        int f = 0, s = 0;\n        for (int num : nums) {\n            if (num > f) {\n                s = f;\n                f = num;\n            } else if (num > s) {\n                s = num;\n            }\n        }\n        return (f-1)*(s-1);\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '991e4923-d048-46a5-93d3-371d3a32d341',
              isFolder: false,
              name: 'RankTransformOfAnArray.java',
              code: 'import java.util.*;\n\npublic class RankTransformOfAnArray {\n    public int[] arrayRankTransform(int[] arr) {\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        int[] h = arr.clone();\n        Arrays.sort(h);\n        int rank = 1;\n        for (int i = 0; i < h.length; i++) {\n            if (!hm.containsKey(h[i])) {\n                hm.put(h[i], rank++);\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            h[i] = hm.get(arr[i]);\n        }\n        return h;\n    }\n}',
              link: 'https://leetcode.com/problems/rank-transform-of-an-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'edc47d95-401b-4b27-9895-5f2c150c353a',
              isFolder: false,
              name: 'RelativeSortArray.java',
              code: 'import java.util.Arrays;\n\npublic class RelativeSortArray {\n    public static int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] count = new int[1001];\n        int totalCount = arr1.length;\n        for (int i : arr1) {\n            count[i]++;\n        }\n        int j = 0;\n        for (int k : arr2) {\n            while (count[k] != 0) {\n                arr1[j++] = k;\n                count[k]--;\n                totalCount--;\n            }\n        }\n        if (totalCount != 0) {\n            for (int i = 0; i < 1001; i++) {\n                while (count[i] != 0) {\n                    arr1[j++] = i;\n                    count[i]--;\n                }\n            }\n        }\n        return arr1;\n    }\n    public static void main(String[] args) {\n//        Input:\n        int[] arr1 = {2,3,1,3,2,4,6,7,9,2,19};\n        int[] arr2 = {2,1,4,3,9,6};\n        int[] ans = relativeSortArray(arr1, arr2);\n        System.out.println(Arrays.toString(ans));\n//        Output: [2,2,2,1,4,3,3,9,6,7,19]\n    }\n}',
              link: 'https://leetcode.com/problems/relative-sort-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'e7715d13-87c6-4959-9337-46c3d722dfb8',
              isFolder: false,
              name: 'SortArrayByIncreasingFrequency.java',
              code: 'import java.util.*;\npublic class SortArrayByIncreasingFrequency {\n    public static int[] frequencySort(int[] nums) {\n        // Count the frequency of each number\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        // Sort the unique numbers by frequency and then by value\n        List<Integer> numList = new ArrayList<>(hm.keySet());\n        numList.sort((a, b) -> {\n            int freqCompare = Integer.compare(hm.get(a), hm.get(b));\n            return (freqCompare != 0) ? freqCompare : Integer.compare(b, a);\n        });\n        // Populate the sorted result array -> O(n) operation\n        int index = 0;\n        for (int num : numList) {\n            int freq = hm.get(num);\n            for (int i = 0; i < freq; i++) {\n                nums[index++] = num;\n            }\n        }\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-1,1,-6,4,5,-6,1,4,1};\n        int[] ans = frequencySort(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/sort-array-by-increasing-frequency/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '2168557d-4b86-4210-9dcd-51797e9e4f1d',
              isFolder: false,
              name: 'SortIntegersByNumberOf1Bits.java',
              code: 'import java.util.*;\n\npublic class SortIntegersByNumberOf1Bits {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int compare(int a, int b) {\n        int aBits = Integer.bitCount(a);\n        int bBits = Integer.bitCount(b);\n        if (aBits != bBits) return aBits - bBits;\n        return a - b;\n    }\n\n    public static void mergeSort(int[] arr, int low, int high) {\n        if (low == high) return;\n        int mid = low + (high - low)/2;\n        mergeSort(arr, low, mid);\n        mergeSort(arr, mid+1, high);\n        merge(arr, low, mid, high);\n    }\n\n    public static void merge(int[] arr, int low, int mid, int high) {\n        int[] temp = new int[high - low + 1];\n        int i = 0, left = low, right = mid+1;\n        while (left <= mid && right <= high) {\n            if (compare(arr[left], arr[right]) > 0)\n                temp[i++] = arr[right++];\n            else\n                temp[i++] = arr[left++];\n        }\n        while (left <= mid) temp[i++] = arr[left++];\n        while (right <= high) temp[i++] = arr[right++];\n\n        for (int j = 0; j < temp.length; j++)\n            arr[j+low] = temp[j];\n    }\n\n    public static int[] sortByBits(int[] arr) {\n//        Brute force solution\n//        int n = arr.length - 1;\n//        for (int i = 0; i < n; i++) {\n//            boolean swapped = false;\n//            for (int j = 0; j < n - i; j++) {\n//                if (compare(arr[j], arr[j + 1]) > 0) {\n//                    swap(arr, j, j + 1);\n//                    swapped = true;\n//                }\n//            }\n//            if (!swapped) break;\n//        }\n//        return arr;\n\n//        Better solution\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] += Integer.bitCount(arr[i]) * 10001;\n//        }\n//        Arrays.sort(arr);\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] = arr[i] % 10001;\n//        }\n//        return arr;\n\n//        Optimised solution\n        mergeSort(arr, 0, arr.length - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n//        int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n//        int[] arr = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\n        int[] arr = {2, 3, 5, 7, 11, 13, 17, 19};\n        int[] ans = sortByBits(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '88f4d487-489e-4be0-b401-f913e20a360e',
              isFolder: false,
              name: 'SortList.java',
              code: 'class SortList {\n    static class ListNode {\n            int val;\n            ListNode next;\n            ListNode() {}\n            ListNode(int val) {\n                this.val = val;\n            }\n            ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode list2Head = slow.next;\n        slow.next = null;\n        head = mergeSort(head);\n        list2Head = mergeSort(list2Head);\n        return merge(head, list2Head);\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode();\n        ListNode head = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        }\n        if (right != null) {\n            temp.next = right;\n        }\n        return head.next;\n    }\n    public static ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = sortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + " => ");\n            temp = temp.next;\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/sort-list/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'b3dfba37-1386-41f6-8065-18369d73ad9f',
              isFolder: false,
              name: 'SplArrayWithXElementsGTEToX.java',
              code: 'public class SplArrayWithXElementsGTEToX {\n    public int specialArray(int[] nums) {\n        int start = 1, end = nums.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i: nums) {\n                if (i >= mid) count++;\n            }\n            if (count == mid) return mid;\n            if (count > mid)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '724d215b-f9e2-413f-834d-b8853438773a',
              isFolder: false,
              name: 'SquaresOfASortedArray.java',
              code: 'public class SquaresOfASortedArray {\n    public int[] sortedSquares(int[] nums) {\n//        Brute force\n//        int[] ans = new int[nums.length];\n//        for (int i=0; i < nums.length; i++) {\n//            ans[i] = nums[i]*nums[i];\n//        }\n//        Arrays.sort(ans);\n//        return ans;\n//        Best solution\n        int n = nums.length - 1;\n        int[] ans = new int[n+1];\n        int start = 0, end = n;\n        while(start <= end) {\n            if (Math.abs(nums[start]) >= Math.abs(nums[end])) {\n                ans[n--] = nums[start]*nums[start];\n                start++;\n            } else {\n                ans[n--] = nums[end]*nums[end];\n                end--;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n\n    }\n}',
              link: 'https://leetcode.com/problems/squares-of-a-sorted-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'f1cddc78-a508-499f-aa8f-d5cdb8b64335',
              isFolder: false,
              name: 'ThirdMaximumNumber.java',
              code: "// Approach: Ranking technique with conditions to handle the same values as first and second;\n// Use Long instead of int as min and max value is Integer's min and max value\n\npublic class ThirdMaximumNumber {\n    public static int getThirdMaxNumber(int[] arr) {\n        long f = Long.MIN_VALUE;\n        long s = Long.MIN_VALUE;\n        long t = Long.MIN_VALUE;\n        for (int num : arr) {\n            if (num > f) {\n                t = s;\n                s = f;\n                f = num;\n            } else if (num > s && num != f) {\n                t = s;\n                s = num;\n            } else if (num > t && num != s && num != f) {\n                t = num;\n            }\n        }\n        if (t == Long.MIN_VALUE) {\n            return (int)f;\n        }\n        return (int)t;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1,2,2,5,3,5};\n        int ans = getThirdMaxNumber(arr);\n        System.out.println(ans);\n    }\n}",
              link: 'https://leetcode.com/problems/third-maximum-number/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '471b5a68-6566-429b-81ae-f12de886e1e1',
              isFolder: false,
              name: 'ThreeSumClosest.java',
              code: 'import java.util.*;\npublic class ThreeSumClosest {\n    public static int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int n = nums.length;\n\n        int first3Sum = nums[0]+nums[1]+nums[2];\n        int last3Sum = nums[n-1]+nums[n-2]+nums[n-3];\n        if (first3Sum >= target) return first3Sum;\n        if (last3Sum <= target) return last3Sum;\n\n        int diff = Integer.MAX_VALUE;\n        int closest = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            int j = i+1;\n            int k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) return sum;\n\n                int abs = Math.abs(target - sum);\n                if (diff > abs) {\n                    closest = sum;\n                    diff = abs;\n                }\n                if (sum > target) k--;\n                else j++;\n            }\n        }\n        return closest;\n    }\n}',
              link: 'https://leetcode.com/problems/3sum-closest/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '12273822-3261-4780-9aa5-b04558b5e946',
              isFolder: false,
              name: 'MaximumOccuringCharacter.java',
              code: "public class MaximumOccuringCharacter {\n//    Use a hashmap or counts array to store the count of all the elements\n//    ans iterate over it to get the max count;\n    public static char getMaxOccuringChar(String line)\n    {\n        // Your code here\n        int[] count = new int[26];\n        for (int i = 0; i < line.length(); i++) {\n            count[(int) line.charAt(i) - 'a']++;\n        }\n        int max = count[0];\n        int idx = 0;\n        for (int j = 0; j < count.length; j++) {\n            if (count[j] > max) {\n                idx = j;\n                max = count[j];\n            }\n        }\n        return (char) (idx + 'a');\n    }\n\n    public static void main(String[] args) {\n        String s = \"testsample\";\n        char ans = getMaxOccuringChar(s);\n        System.out.println(ans);\n    }\n}",
              link: 'https://practice.geeksforgeeks.org/problems/maximum-occuring-character-1587115620/1',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '9213ce4c-3a17-4861-8e65-fcef421c503f',
              isFolder: false,
              name: 'PermutationInString.java',
              code: 'public class PermutationInString {\n    public static boolean checkCount(int[] arr1, int[] arr2) {\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] != arr2[i]) return false;\n        }\n        return true;\n    }\n\n    public static boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n        int[] count1 = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count1[s1.charAt(i) - 97]++;\n        }\n        int[] count2 = new int[26];\n        int windowSize = s1.length();\n        int i = 0;\n        while (i < windowSize) {\n            count2[s2.charAt(i) - 97]++;\n            i++;\n        }\n        if (checkCount(count1, count2)) return true;\n        while (i < s2.length()) {\n            // Add\n            count2[s2.charAt(i) -97]++;\n            // Minus\n            count2[s2.charAt(i-windowSize) -97]--;\n\n            i++;\n            if (checkCount(count1, count2)) return true;\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        String s1 = "ab";\n        String s2 = "eidboaoo";\n        boolean ans = checkInclusion(s1, s2);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/permutation-in-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'affafe15-708e-4c0a-a996-4f53989d25d4',
              isFolder: false,
              name: 'PowerSet.java',
              code: 'import java.util.*;\npublic class PowerSet {\n    public List<List<Integer>> powerSet(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < Math.pow(2, nums.length); i++) {\n            List<Integer> list = new ArrayList<>();\n            int idx = 0;\n            while(idx < nums.length) {\n                if (((i >> idx)&1) == 1) {\n                    list.add(nums[idx]);\n                }\n                idx++;\n            }\n            ans.add(list);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'c101833f-1c15-436e-9d8a-f8365afa7628',
              isFolder: false,
              name: 'RemoveAllAdjacentDuplicates.java',
              code: 'public class RemoveAllAdjacentDuplicates {\n    public static String removeDuplicates(String s) {\n//        Brute force solution\n//        Stack<Character> stack = new Stack<>();\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (!stack.isEmpty() && stack.peek() == ch)\n//                stack.pop();\n//            else\n//                stack.push(ch);\n//        }\n//        while (!stack.isEmpty()) sb.append(stack.pop());\n//        return sb.reverse().toString();\n\n//        Better solution using stack\n        char[] stack = new char[s.length()];\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            char ch = s.charAt(j);\n            if (i > 0 && stack[i-1] == ch)\n                i = Math.max(0, i - 1);\n            else\n                stack[i++] = ch;\n        }\n        return new String(stack, 0, i);\n    }\n    public static void main(String[] args) {\n        String s = "abbaca";\n        String ans = removeDuplicates(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '82e15569-5b9d-4d04-973d-190b22caede0',
              isFolder: false,
              name: 'RemoveAllOccurrencesOfSubstring.java',
              code: 'public class RemoveAllOccurrencesOfSubstring {\n    public static String removeOccurrences(String s, String part) {\n        StringBuilder sb = new StringBuilder(s);\n        while (sb.length()!=0 && sb.indexOf(part)>=0) {\n            int idx = sb.indexOf(part);\n            sb.delete(idx, idx+part.length());\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n        String s = "daabcbaabcbc";\n        String part = "abc";\n        String ans = removeOccurrences(s, part);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/remove-all-occurrences-of-a-substring/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'e48f3acc-10a5-4711-9345-2d34a5dc1918',
              isFolder: false,
              name: 'ReplaceSpaces.java',
              code: 'public class ReplaceSpaces {\n    public static StringBuilder replaceSpaces(StringBuilder str) {\n        // Write your code here.\n        // return new StringBuilder(str.toString().replace(" ", "@40"));\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == \' \')\n                sb.append("@40");\n            else\n                sb.append(str.charAt(i));\n        }\n        return sb;\n    }\n\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder("Coding Ninjas Is A Coding Platform");\n        StringBuilder ans = replaceSpaces(str);\n        System.out.println(ans);\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/replace-spaces_1172172',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '38cf477b-1357-4c3f-bc4a-a00520978e43',
              isFolder: false,
              name: 'ReverseWords1.java',
              code: 'public class ReverseWords1 {\n    public static String reverseWords(String s) {\n//        Brute force solution\n//        String[] sArr = s.split(" ");\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = sArr.length - 1; i >= 0; i--) {\n//            if (sArr[i].trim().length() != 0) {\n//                sb.append(sArr[i]).append(" ");\n//            }\n//        }\n//        return sb.toString().trim();\n\n//        Best: 2 pointer approach\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == \' \') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != \' \') i--;\n            if (i == -1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(\' \');\n        }\n        return sb.toString().trim();\n    }\n    public static void main(String[] args) {\n        String s = "a good   example";\n//        The string can have more than 1 space anywhere in the array\n        String ans = reverseWords(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '9cf64868-1211-4b83-82bb-f822465cc33a',
              isFolder: false,
              name: 'ReverseWordsInAString2.java',
              code: "import java.util.Arrays;\n\npublic class ReverseWordsInAString2 {\n//    Input: s = \"the sky is blue\"\n//    Output: \"blue is sky the\"\n    public static void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n\n    public static char[] reverseWords(char[] arr) {\n//        int start = 0;\n//        int end = arr.length;\n//        reverse(arr, start, end - 1);\n//        for (int i = 0; i < end; i++) {\n//            if (arr[i] == ' ') {\n//                reverse(arr, start, i-1);\n//                start = i+1;\n//            } else if (i == end - 1) {\n//                reverse(arr, start, i);\n//            }\n//        }\n//        return arr;\n        int start = 0;\n        int end = arr.length - 1;\n        reverse(arr, start, end);\n        for (int i = 0; i <= end; i++) {\n            if (arr[i] == ' ') {\n                reverse(arr, start, i - 1);\n                start = i + 1;\n            }\n        }\n        reverse(arr, start, end);\n        return arr;\n    }\n    public static void main(String[] args) {\n        char[] arr = {'t', 'h', 'e', ' ', 's', 'k', 'y', ' ', 'i', 's', ' ', 'b', 'l', 'u', 'e'};\n        char[] ans = reverseWords(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              link: 'https://www.lintcode.com/problem/927/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'e017de5b-0715-4017-a57a-27d44fbde34c',
              isFolder: false,
              name: 'StringCompression.java',
              code: "public class StringCompression {\n    public static int compress(char[] chars) {\n        // Best solution O(n)\n        int n = chars.length;\n        if (n == 1)\n            return 1;\n        int i = 0, j = 0, slow = 0;\n        while (j < n) {\n            while (j < n && chars[i] == chars[j])\n                j++;\n            chars[slow++] = chars[i];\n            if (j - i > 1) {\n                String diff = j - i + \"\";\n                for (int k = 0; k < diff.length(); k++) {\n                    chars[slow++] = diff.charAt(k);\n                }\n            }\n            i = j;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        char[] chars = { 'a', 'a', 'b', 'b', 'c', 'c', 'c' };\n        int ans = compress(chars);\n        System.out.println(ans);\n    }\n}",
              link: 'https://leetcode.com/problems/string-compression/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'c8cfc66b-a901-4b0d-b896-9d89c060b8d3',
              isFolder: false,
              name: 'ValidPalindrome.java',
              code: '//    The given string is polluted with characters other than numbers and alphabets.\n//    Also ignore the case while solving for the answer\n\npublic class ValidPalindrome {\n    public static boolean isPalindrome(String s) {\n//        Brute force: Remove every character that is not valid using replaceAll method\n//        This will take O(n) time to replace and O(n) time to make it lowercase and then\n//        another O(n) to iterate the array\n//        Total TC = O(3n)\n//        s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Best approach: Two pointer approach\n//        Total TC = O(2n) => (lowercase and iterating)\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n\n    }\n    public static void main(String[] args) {\n        String s = "A man, a plan, a canal: Panama";\n        boolean ans = isPalindrome(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/valid-palindrome/',
              notes: '',
              tags: ['Strings'],
            },
          ],
        },
        {
          id: '7a7af0f8-783a-4eea-8087-afe4ee1f8ec8',
          isFolder: true,
          name: 'Neetcode 150',
          content: [
            {
              id: 'd648b3f7-bc73-47e7-80d2-712399620ffb',
              isFolder: false,
              name: 'ContainsDuplicate.java',
              code: 'import java.util.*;\n\nclass ContainsDuplicate {\n    public boolean containsDuplicate(int[] nums) {\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : nums) {\n            if (hs.contains(i)) return true;\n            hs.add(i);\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/contains-duplicate/',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '865091cc-2a05-4c6c-b761-ea1a11824870',
              isFolder: false,
              name: 'GroupAnagrams.java',
              code: 'import java.util.*;\n/*\n* Sorting and storing in hashmap and value list\n* if a duplicate string is found store it in value list.\n* If it does not exist create a new key value pair in hashmap\n*/\n\npublic class GroupAnagrams {\n    public static List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<String, List<String>> hm = new HashMap<>();\n        for (String str : strs) {\n            char[] ch = str.toCharArray();\n            Arrays.sort(ch);\n            String s = new String(ch);\n            if (!hm.containsKey(s)) {\n                hm.put(s, new ArrayList<>());\n            }\n            hm.get(s).add(str);\n        }\n        System.out.println(hm);\n        return new ArrayList<>(hm.values());\n    }\n\n    public static void main(String[] args) {\n//        String[] arr = {"eat","tea","tan","ate","nat","bat"};\n        String[] arr = {""};\n        List<List<String>> ans = groupAnagrams(arr);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/group-anagrams',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'f944bdef-0833-4b81-81f8-7008c2e76e47',
              isFolder: false,
              name: 'LongestConsecutiveSequence.java',
              code: 'import java.util.*;\n\npublic class LongestConsecutiveSequence {\n    public static int longestConsecutive(int[] N) {\n//        Brute force solution\n//        if (N.length == 0) return 0;\n//        Arrays.sort(N);\n//        int maxLen = 0, len = 1, last = Integer.MIN_VALUE;\n//        for (int k : N) {\n//            if (k - 1 == last) len++;\n//            else if (k != last)len = 1;\n//            last = k;\n//            maxLen = Math.max(maxLen, len);\n//        }\n//        return maxLen;\n\n//        Best solution\n        HashSet<Integer> hs = new HashSet<>();\n        int maxCount = 0;\n        for (int num: N) hs.add(num);\n        for (int j : N) {\n            if (!hs.contains(j - 1)) {\n                int x = j;\n                int count = 1;\n                while (hs.contains(x+1)) {\n                    count++;\n                    x++;\n                }\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n        return maxCount;\n    }\n    public static void main(String[] args) {\n\n    }\n}',
              link: 'https://leetcode.com/problems/longest-consecutive-sequence',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '4d66cea9-a631-42ca-81e8-fd2ce98b7c59',
              isFolder: false,
              name: 'ProductArrayExceptSelf.java',
              code: 'public class ProductArrayExceptSelf {\n    public int[] productExceptSelf(int[] nums) {\n        int zeroCount = 0;\n        int zeroIdx = -1;\n        int[] ans = new int[nums.length];\n        int product = 1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                zeroCount++;\n                if (zeroCount > 1) return ans;\n                zeroIdx = i;\n                continue;\n            }\n            product *= nums[i];\n        }\n        if (zeroCount == 1) {\n            ans[zeroIdx] = product;\n            return ans;\n        }\n        for (int j = 0; j < nums.length; j++) {\n            ans[j] = product / nums[j];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/product-of-array-except-self/',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '0da7b965-5580-41fa-881c-2197a2838c36',
              isFolder: false,
              name: 'TopKFrequentElements.java',
              code: 'import java.util.*;\n\npublic class TopKFrequentElements {\n    public static int[] topKFrequent(int[] nums, int k) {\n        // This is the O(klogN) solution\n        // int[] kArr = new int[k];\n        // HashMap<Integer, Integer> hm = new HashMap<>();\n        // for (int num : nums) {\n        //     hm.put(num, hm.getOrDefault(num, 0) + 1);\n        // }\n        // PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue());\n        // for (Map.Entry<Integer, Integer> it : hm.entrySet()) {\n        //     pq.add(it);\n        //     if (pq.size() > k) pq.poll();\n        // }\n        // while (!pq.isEmpty()) {\n        //     kArr[--k] = pq.poll().getKey();\n        // }\n        // return kArr;\n\n        // Most efficient solution: O(n)\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        List<List<Integer>> countList = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            countList.add(new ArrayList<>());\n        }\n        for(Map.Entry<Integer, Integer> val : hm.entrySet()) {\n            countList.get(val.getValue()-1).add(val.getKey());\n        }\n        int[] ans = new int[k];\n        int ptr = 0;\n        for (int i = countList.size() - 1; i >= 0; i--) {\n            if (countList.get(i).size() != 0) {\n                for (int j: countList.get(i)) {\n                    if (ptr == k) break;\n                    ans[ptr++] = j;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 1, 1, 2, 2, 3};\n        int k = 2;\n        int[] ans = topKFrequent(nums, k);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/top-k-frequent-elements',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '3d4b9300-ee18-4d54-bd1d-ae38672d013f',
              isFolder: false,
              name: 'TwoSum.java',
              code: 'import java.util.HashMap;\n\npublic class TwoSum {\n  public int[] twoSum(int[] nums, int target) {\n    HashMap<Integer, Integer> hm = new HashMap<>();\n    for (int j = 0; j < nums.length; j++) {\n      if (hm.containsKey(target - nums[j]))\n        return new int[] { j, hm.get(target - nums[j]) };\n      hm.put(nums[j], j);\n    }\n    return new int[] { -1, -1 };\n  }\n}',
              link: 'https://leetcode.com/problems/two-sum',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '6a4f6031-a1f4-4419-a8c3-2c11026611fc',
              isFolder: false,
              name: 'ValidAnagram.java',
              code: "public class ValidAnagram {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length())\n      return false;\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n      count[s.charAt(i) - 'a']++;\n      count[t.charAt(i) - 'a']--;\n    }\n    for (int i = 0; i < 26; i++) {\n      if (count[i] != 0)\n        return false;\n    }\n    return true;\n  }\n}",
              link: 'https://leetcode.com/problems/valid-anagram',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '1343538e-55a1-4efe-ae84-c632f8a0e5ed',
              isFolder: false,
              name: 'ValidSudoku.java',
              code: "import java.util.HashSet;\n\npublic class ValidSudoku {\n    public static boolean checkBlock(int iIdx, int jIdx, char[][] board) {\n        HashSet<Character> hs = new HashSet<>();\n        int rows = iIdx + 3;\n        int cols = jIdx + 3;\n        for (int i = iIdx; i < rows; i++) {\n            for (int j = jIdx; j < cols; j++) {\n                char curr = board[i][j];\n                if (curr != '.') {\n                    if (hs.contains(curr)) return false;\n                    hs.add(curr);\n                }\n            }\n        }\n        return true;\n    }\n    public static boolean isValidSudoku(char[][] board) {\n//        Row column check\n        for (int i = 0; i < board.length; i++) {\n            HashSet<Character> row = new HashSet<>();\n            HashSet<Character> col = new HashSet<>();\n            for (int j = 0; j < board.length; j++) {\n                char r = board[i][j], c = board[j][i];\n                if (r != '.' && row.contains(r)) return false;\n                else row.add(r);\n                if (c != '.' && col.contains(c)) return false;\n                else col.add(c);\n            }\n        }\n//        3x3 box check\n        for (int i = 0; i < 9; i += 3)\n            for (int j = 0; j < 9; j += 3)\n                if (!checkBlock(i, j, board)) return false;\n\n        return true;\n    }\n}",
              link: 'https://leetcode.com/problems/valid-sudoku',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '5ad7b41e-f3ea-431d-8fb2-5fe5aa4f1096',
              isFolder: false,
              name: 'FindMinInSortedRotatedArray.java',
              code: 'public class FindMinInSortedRotatedArray {\n    public int findMin(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] > arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'ab0e42f2-2930-48a3-9384-614140adb55b',
              isFolder: false,
              name: 'kokoEatingBananas.java',
              code: 'public class kokoEatingBananas {\n    public long totalTimeToEat(int mid, int[] piles) {\n        long hours = 0;\n        for (int i : piles) {\n            hours += (i + mid - 1) / mid;\n        }\n        return hours;\n    }\n\n    public int minEatingSpeed(int[] piles, int h) {\n        int start = 1;\n        int end = 0;\n        for(int i: piles) {\n            end = Math.max(end, i);\n        }\n        int ans = 0;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (totalTimeToEat(mid, piles) <= h) {\n                ans = mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/koko-eating-bananas',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '7c4dd101-0ed6-4850-8db5-b67e36daf4c5',
              isFolder: false,
              name: 'MedianOfTwoSortedArrays.java',
              code: 'public class MedianOfTwoSortedArrays {\n    public double findMedianSortedArrays(int[] M, int[] N) {\n       int m = M.length, n = N.length;\n       if (m > n) return findMedianSortedArrays(N, M);\n       int k = (m + n + 1)/2;\n       int start = 0, end = m;\n       while (start <= end) {\n           int mid1 = start + (end - start)/2;\n           int mid2 = k - mid1;\n           int l1 = mid1 > 0 ? M[mid1 - 1] : Integer.MIN_VALUE;\n           int l2 = mid2 > 0 ? N[mid2 - 1] : Integer.MIN_VALUE;\n           int r1 = mid1 < m ? M[mid1] : Integer.MIN_VALUE;\n           int r2 = mid2 < n ? N[mid2] : Integer.MIN_VALUE;\n           if (l1 <= r2 && l2 <= r1) {\n               double median = Math.max(l1, l2);\n               if ((m+n) %2 == 0) {\n                   median += Math.min(r1, r2);\n                   return median / 2;\n               }\n               return median;\n           }\n           if (l1 > r2) {\n               end = mid1 - 1;\n           } else {\n               start = mid1 + 1;\n           }\n       }\n       return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/median-of-two-sorted-arrays',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '5f27d105-06d5-4dcd-8ba7-7e93a92cd14f',
              isFolder: false,
              name: 'Search2DMatrix.java',
              code: 'public class Search2DMatrix {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        int start = 0;\n        int end = n*m -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (matrix[mid/m][mid%m] == target)\n                return true;\n            if (matrix[mid/m][mid%m] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/search-a-2d-matrix',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'a1a85f0c-dfbd-470f-ad2c-fe0d16ec6541',
              isFolder: false,
              name: 'SearchInRotatedSortedArray.java',
              code: 'public class SearchInRotatedSortedArray {\n    public int search(int[] arr, int target) {\n        int start = 0; int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (target == arr[mid]) return mid;\n            if (arr[mid] >= arr[start]) {\n                if (target >= arr[start] && target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target <= arr[end] && target > arr[mid])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            }\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/search-in-rotated-sorted-array',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '176e9c04-2788-4a01-8530-140a8ef24fcf',
              isFolder: false,
              name: 'TimeMap.java',
              code: 'import java.util.*;\n\nclass TimeMap {\n    HashMap<String, List<String[]>> hm;\n    public TimeMap() {\n        hm = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (!hm.containsKey(key))\n            hm.put(key, new ArrayList<>());\n        hm.get(key).add(new String[]{ value, String.valueOf(timestamp) });\n    }\n\n    public String get(String key, int timestamp) {\n        if (!hm.containsKey(key)) return "";\n        List<String[]> list = hm.get(key);\n        int pos = findPos(list, timestamp);\n        if (pos == -1) return "";\n        return list.get(pos)[0];\n    }\n\n    public static int findPos(List<String[]> list, int target) {\n        int start = 0, end = list.size() - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int val = Integer.parseInt(list.get(mid)[1]);\n            if (val == target) return mid;\n            if (val > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static void main(String[] args) {\n        String[] operations = {"TimeMap", "set", "set", "get", "get", "get", "get", "get"};\n        String[][] values = {{}, {"love", "high", "10"}, {"love", "low", "20"}, {"love", "5"}, {"love", "10"}, {"love", "15"}, {"love", "20"}, {"love", "25"}};\n        TimeMap timeMap = null;\n        List<String> output = new ArrayList<>();\n        for (int i = 0; i < operations.length; i++) {\n            String[] val = values[i];\n            switch (operations[i]) {\n                case "TimeMap" -> {\n                    timeMap = new TimeMap();\n                    output.add(null);\n                }\n                case "set" -> {\n                    timeMap.set(val[0], val[1], Integer.parseInt(val[2]));\n                    output.add(null);\n                }\n                case "get" -> {\n                    output.add(timeMap.get(val[0], Integer.parseInt(val[1])));\n                }\n            }\n        }\n        System.out.println(output);\n    }\n}\n\n/**\n * Your TimeMap object will be instantiated and called as such:\n * TimeMap obj = new TimeMap();\n * obj.set(key,value,timestamp);\n * String param_2 = obj.get(key,timestamp);\n */',
              link: 'https://leetcode.com/problems/time-based-key-value-store',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'd2031ed9-1a1e-4523-a2d6-1f0099ae1843',
              isFolder: false,
              name: 'AddTwoNumbers.java',
              code: 'public class AddTwoNumbers {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode sum = new ListNode(0);\n        ListNode sumHead = sum;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int d1 = l1 != null ? l1.val : 0;\n            int d2 = l2 != null ? l2.val : 0;\n            carry += d1 + d2;\n            sum.next = new ListNode(carry%10);\n            sum = sum.next;\n            carry /= 10;\n            l1 = l1 != null ? l1.next : null;\n            l2 = l2 != null ? l2.next : null;\n        }\n        return sumHead.next;\n    }\n}',
              link: 'https://leetcode.com/problems/add-two-numbers/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '9eb8209c-6245-4368-a7ba-609436bde1f6',
              isFolder: false,
              name: 'CopyListWithRandomPointer.java',
              code: 'public class CopyListWithRandomPointer {\n    public Node copyRandomList(Node head) {\n        // Optimised solution\n        if (head == null) return null;\n        // Step 1: Create a new linked list in between the nodes of current LL\n        Node curr = head;\n        while (curr != null) {\n            Node newNode = new Node(curr.val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            curr = newNode.next;\n        }\n        // Step 2: Assign random pointers to the deep copy\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n        // Step 3: Separate both the linked list and return Head\n        Node copy = head.next;\n        Node temp = copy;\n        curr = head;\n        while (temp != null) {\n            curr.next = temp.next;\n            curr = curr.next;\n            if (curr == null) break;\n            temp.next = curr.next;\n            temp = temp.next;\n        }\n        return copy;\n    }\n}',
              link: 'https://leetcode.com/problems/copy-list-with-random-pointer/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '9ad13811-12f0-4c08-a4ed-dedcaa9a2ddb',
              isFolder: false,
              name: 'FindTheDuplicateNumber.java',
              code: "public class FindTheDuplicateNumber {\n    public int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
              link: 'https://leetcode.com/problems/find-the-duplicate-number/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '1f9c804c-0613-4e8b-afb5-c42e38b7db43',
              isFolder: false,
              name: 'LinkedListCycle.java',
              code: 'public class LinkedListCycle {\n    public boolean hasCycle(ListNode head) {\n        // Brute force\n        // HashSet<ListNode> hs = new HashSet<>();\n        // ListNode curr = head;\n        // while (curr != null) {\n        //     if (hs.contains(curr)) return true;\n        //     hs.add(curr);\n        //     curr = curr.next;\n        // }\n        // return false;\n\n        // Optimised\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/linked-list-cycle/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'e56b3438-2e7e-4ff5-8084-46d37c9dd8ac',
              isFolder: false,
              name: 'ListNode.java',
              code: '// !ignore\npublic class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '05c34081-2dd8-4847-8373-e37d4b6ac8b8',
              isFolder: false,
              name: 'MergeKSortedLists.java',
              code: 'public class MergeKSortedLists {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        temp.next = left != null ? left : right;\n        return tHead.next;\n    }\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += interval*2) {\n                lists[i] = merge(lists[i], lists[i+interval]);\n            }\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
              link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '68414faa-b702-4d60-b5b0-9fbdcc4872a1',
              isFolder: false,
              name: 'MergeTwoSortedLists.java',
              code: 'public class MergeTwoSortedLists {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        } else {\n            temp.next = right;\n        }\n        return tHead.next;\n    }\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        return merge(list1, list2);\n    }\n}',
              link: 'https://leetcode.com/problems/merge-two-sorted-lists/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '6978d34c-6d25-4581-8fe3-5a2fd3323aa3',
              isFolder: false,
              name: 'Node.java',
              code: '// !ignore\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '3cd882f7-9c0c-4607-ad1d-4a130ca652d7',
              isFolder: false,
              name: 'RemoveNthNodeFromEndOfList.java',
              code: 'public class RemoveNthNodeFromEndOfList {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Optimised approach\n        ListNode start = new ListNode(0, head);\n        ListNode slow = start;\n        ListNode fast = start;\n        for (int i = 0; i < n; i++) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return start.next;\n    }\n}',
              link: 'https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '58f04ee0-a383-4d27-b478-9d091ed0b486',
              isFolder: false,
              name: 'ReorderList.java',
              code: 'public class ReorderList {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            temp.next = left;\n            left = left.next;\n            temp = temp.next;\n            temp.next = right;\n            right = right.next;\n            temp = temp.next;\n        }\n        temp.next = left != null ? left : right;\n        return tHead.next;\n    }\n\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n        slow = revLL(slow);\n        head = merge(head, slow);\n    }\n}',
              link: 'https://leetcode.com/problems/reorder-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'e819507a-cbaa-400d-832d-cd48cc35e585',
              isFolder: false,
              name: 'ReverseLinkedList.java',
              code: 'public class ReverseLinkedList {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-linked-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '1288c325-49ce-459a-85b3-2fc83281bf77',
              isFolder: false,
              name: 'ReverseNodesInKGroups.java',
              code: 'public class ReverseNodesInKGroups {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = head;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head, start = head, prev = head;\n        ListNode newHead = new ListNode(0, head);\n        ListNode temp = newHead;\n\n        while (curr != null) {\n            for (int i = 1; i <= k; i++) {\n                if (curr.next == null && i < k) return newHead.next;\n                prev = curr;\n                curr = curr.next;\n            }\n            prev.next = null;\n            temp.next = revLL(start);\n            start.next = curr;\n            temp = start;\n            start = curr;\n        }\n        return newHead.next;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-nodes-in-k-group/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '1d736a15-b0c0-4ec3-9fe0-0c3d14b6bab8',
              isFolder: false,
              name: 'MinStack.java',
              code: 'import java.util.*;\n\nclass MinStack {\n    Stack<Integer> stack;\n    Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        int minValue = minStack.empty() ? val : Math.min(minStack.peek(), val);\n        minStack.push(minValue);\n    }\n\n    public void pop() {\n        minStack.pop();\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n\n    public static void main(String[] args) {\n//        ["MinStack","push","push","push","top","pop","getMin","pop","getMin","pop","push","top","getMin","push","top","getMin","pop","getMin"]\n//        [[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\n        MinStack st = new MinStack();\n        st.push(2147483646);\n        st.push(2147483646);\n        st.push(2147483647);\n        System.out.println(st.top());\n        st.pop();\n        System.out.println(st.getMin());\n        st.pop();\n        System.out.println(st.getMin());\n        st.pop();\n//        System.out.println(st.top());\n\n    }\n}\n\n/*\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */',
              link: 'https://leetcode.com/problems/min-stack/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: 'dff25962-0247-4f2f-b099-4cc2cbf9ec3a',
              isFolder: false,
              name: 'ReversePolishNotation.java',
              code: 'import java.util.*;\n\nclass ReversePolishNotation {\n    public static int operate(String op, int first, int second) {\n        if (op.equals("-")) return second - first;\n        if (op.equals("*")) return second * first;\n        if (op.equals("/")) return second / first;\n        return second + first; // op = +\n    }\n\n    public int evalRPN(String[] tokens) {\n        // Basically secondPop operation firstPop\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/"))\n                stack.push(operate(token, stack.pop(), stack.pop()));\n            else\n                stack.add(Integer.parseInt(token));\n        }\n        return stack.pop();\n    }\n}',
              link: 'https://leetcode.com/problems/evaluate-reverse-polish-notation/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '46b88ff8-216f-4223-b27b-24cfecead8fa',
              isFolder: false,
              name: 'ValidParentheses.java',
              code: "import java.util.*;\npublic class ValidParentheses {\n    public static boolean isValid(String s) {\n//        Best w Stack\n//        int len = s.length();\n//        if ((len&1) == 1) return false;\n//        HashMap<Character, Character> hm = new HashMap<>();\n//        hm.put('(', ')');\n//        hm.put('[', ']');\n//        hm.put('{', '}');\n//        char[] charArr = s.toCharArray();\n//        Stack<Character> stack = new Stack<>();\n//        for (int i = 0; i < len; i++) {\n//            char ch = charArr[i];\n//            if (hm.containsKey(ch)) stack.push(ch);\n//            else {\n//                if(stack.empty()) return false;\n//                char top = stack.pop();\n//                if (hm.get(top) != ch) return false;\n//            }\n//        }\n//        return stack.empty();\n\n//     Best w/o stack\n        int len = s.length();\n        if ((len&1) == 1) return false;\n        char[] stack = new char[len];\n        char[] charArr = s.toCharArray();\n        HashMap<Character, Character> hm = new HashMap<>();\n        hm.put('(', ')');\n        hm.put('[', ']');\n        hm.put('{', '}');\n        int ptr = -1;\n        for (int i = 0; i < len; i++) {\n            char ch = charArr[i];\n            if (hm.containsKey(ch)) {\n                stack[++ptr] = ch;\n            } else {\n                if(ptr == -1) return false;\n                char top = stack[ptr--];\n                if (hm.get(top) != ch) return false;\n            }\n        }\n        return ptr == -1;\n    }\n\n    public static void main(String[] args) {\n        String s = \"()\";\n        System.out.println(isValid(s));\n    }\n}",
              link: 'https://leetcode.com/problems/valid-parentheses/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: 'f66676fa-7b6c-46b2-a215-cdc5d39e555f',
              isFolder: false,
              name: 'ContainerWithMostWater.java',
              code: 'public class ContainerWithMostWater {\n    public static int maxArea(int[] heights) {\n        int i = 0;\n        int j = heights.length - 1;\n        int area = 0;\n        int max = 0;\n        while (i < j) {\n            if (heights[i] <= heights[j]) i++;\n            else if (heights[i] > heights[j]) j--;\n\n            area = (j - i) * Math.min(heights[i], heights[j]);\n            max = Math.max(max, area);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n        int ans = maxArea(heights);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/container-with-most-water/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: 'bdc5396b-ec64-4a5c-86d7-2164cc960a21',
              isFolder: false,
              name: 'ThreeSum.java',
              code: 'import java.util.*;\npublic class ThreeSum {\n    public List<List<Integer>> threeSum(int[] N) {\n        Arrays.sort(N);\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = N.length;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && N[i] == N[i-1]) continue;\n            int j = i+1;\n            int k = n-1;\n            while (j < k) {\n                int sum = N[i] + N[j] + N[k];\n                if (sum > 0) k--;\n                else if (sum < 0) j++;\n                else {\n                    ans.add(Arrays.asList(N[i], N[j], N[k]));\n                    j++;\n                    k--;\n                    while (j < k && N[j] == N[j-1]) j++;\n                    while (j < k && N[k] == N[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/3sum',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: 'ef84452f-3433-45a6-b96e-6317fb360e2e',
              isFolder: false,
              name: 'TrappingRainWater.java',
              code: '// import java.util.Arrays;\npublic class TrappingRainWater {\n    public static int trap(int[] height) {\n        int n = height.length;\n//        int[] maxLeft = new int[n];\n//        int[] maxRight = new int[n];\n//        int leftMax = 0, rightMax = 0;\n//        for (int i = 0; i < n; i++) {\n//            maxLeft[i] = leftMax;\n//            leftMax = Math.max(leftMax, height[i]);\n//            maxRight[n - i - 1] = rightMax;\n//            rightMax = Math.max(rightMax, height[n - i - 1]);\n//        }\n//        int count = 0;\n//        for (int j = 0; j < n; j++) {\n//            count += Math.max(Math.min(maxLeft[j], maxRight[j]) - height[j], 0);\n//        }\n//        return count;\n        int start = 0, end = n - 1;\n        int maxL = height[start], maxR = height[end];\n        int c = 0;\n        while (start < end) {\n            if (height[start] <= height[end]) {\n                start++;\n                maxL = Math.max(maxL, height[start]);\n                c += Math.max(maxL - height[start], 0);\n\n            } else {\n                end--;\n                maxR = Math.max(maxR, height[end]);\n                c += Math.max(maxR - height[end], 0);\n            }\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n        int ans = trap(arr);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/trapping-rain-water/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: 'a51531c1-8038-4a7a-9181-2489d2f85d62',
              isFolder: false,
              name: 'TwoSumSortedArray.java',
              code: 'public class TwoSumSortedArray {\n    public static int[] twoSum(int[] N, int target) {\n//        Brute force: Linear search the pair using 2 for loops (nested) O(N^2)\n\n//        Better solution: Use 2 pointer from left and right to get sum\n\n//        Optimised solution: Binary search\n        int start = 0;\n        int end = N.length - 1;\n        int[] ans = {-1, -1};\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int sum = N[start] + N[end];\n            if (sum == target){\n                ans[0] = start + 1;\n                ans[1] = end + 1;\n                return ans;\n            }\n            if (sum > target)\n                end = N[start] + N[mid] > target ? mid - 1 : end - 1;\n            else\n                start = N[end] + N[mid] < target ? mid + 1 : start + 1;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '172bc9d4-4a2c-4931-9ee9-2d259d60413b',
              isFolder: false,
              name: 'ValidPalindrome.java',
              code: 'public class ValidPalindrome {\n    public boolean isPalindrome(String s) {\n//        Brute force solution\n//        s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Optimised solution\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n    }\n}',
              link: 'https://leetcode.com/problems/valid-palindrome/',
              notes: '',
              tags: ['Two Pointers'],
            },
          ],
        },
        {
          id: '4c3766ad-e4c1-4cd8-a1c6-e5deb4f2f652',
          isFolder: true,
          name: 'stiver_dsa_sheet',
          content: [
            {
              id: 'e009545e-db9f-44a5-8494-d39182991ac2',
              isFolder: true,
              name: 'Arrays',
              content: [
                {
                  id: 'f60f72cc-3b83-4924-ad8d-896cf6bb29fa',
                  isFolder: false,
                  name: 'MajorityFrequency.java',
                  code: 'import java.util.*;\n\npublic class MajorityFrequency {\n    public static int majorityElement(int[] v) {\n        // Write your code here\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int maxFrequency = v.length / 2;\n        for (int i = 0 ; i <  v.length; i++) {\n            if (hm.containsKey(v[i])) {\n                hm.put(v[i], hm.get(v[i]) + 1);\n                if (hm.get(v[i]) > maxFrequency) {\n                    return v[i];\n                }\n            } else {\n                hm.put(v[i], 1);\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 2, 1, 3, 1, 1, 3, 1, 1};\n        int ans = majorityElement(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '9660cc92-821d-47f4-85f9-1182b45ea63b',
                  isFolder: false,
                  name: 'MaximumConsecutiveOnes.java',
                  code: 'public class MaximumConsecutiveOnes {\n    public static int findMaxConsecutiveOnes(int[] N) {\n        int count = 0;\n        int maxCount = 0;\n        for (int i = 0; i < N.length; i++) {\n            if (N[i] == 0) {\n                count = 0;\n            } else {\n                count++;\n            }\n            maxCount = Math.max(count, maxCount);\n        }\n        return maxCount;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 0, 1, 1, 0, 1};\n        int ans = findMaxConsecutiveOnes(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '493d7106-08ac-4107-8fd2-ab9dacbcf78b',
                  isFolder: false,
                  name: 'MergeSortedArraysDuplicates.java',
                  code: 'import java.util.*;\n\npublic class MergeSortedArraysDuplicates {\n    public static List< Integer > sortedArray(int []a, int []b) {\n        // Write your code here\n        List<Integer> ans = new ArrayList<>();\n        int i = 0, j = 0;\n        while (i < a.length && j < b.length) {\n            if (a[i] <= b[j]) {\n                if (ans.size() == 0 || ans.get(ans.size() - 1) != a[i])\n                    ans.add(a[i]);\n                i++;\n            } else {\n                if (ans.size() == 0 || ans.get(ans.size() - 1) != b[j])\n                    ans.add(b[j]);\n                j++;\n            }\n        }\n        while (i < a.length) {\n            if (ans.get(ans.size() - 1) != a[i])\n                ans.add(a[i]);\n            i++;\n        }\n        while (j < b.length) {\n            if (ans.get(ans.size() - 1) != b[j])\n                ans.add(b[j]);\n            j++;\n        }\n        return ans;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '2adfb49e-cc41-43b8-9a74-e7ced50ffd32',
                  isFolder: false,
                  name: 'ZeroOneTwo.java',
                  code: 'import java.util.*;\n\npublic class ZeroOneTwo {\n    public static void sortArray(ArrayList<Integer> arr, int n) {\n        // Write your code here.\n        int start = 0, end = n-1, element = 0;\n        while (element < 2) {\n            if (start >= end) {\n                element++;\n                end = n-1;\n            }\n            if (arr.get(start) == element) start++;\n            else if (arr.get(end) != element) end--;\n            else {\n                arr.set(end, arr.get(start));\n                arr.set(start, element);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        arr.add(2);\n        arr.add(2);\n        arr.add(2);\n        arr.add(2);\n        arr.add(0);\n        arr.add(0);\n        arr.add(1);\n        arr.add(0);\n        sortArray(arr, arr.size());\n        System.out.println(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '9f2bb186-bed8-42ff-8211-e43784bfca04',
                  isFolder: false,
                  name: 'CountInversions.java',
                  code: 'public class CountInversions {\n    public static int merge(int[] A, int low, int mid, int high) {\n        int left = low, right = mid + 1, i = 0;\n        int count = 0;\n        int[] temp = new int[high - low + 1];\n        while (left <= mid && right <= high) {\n            if (A[left] <= A[right]) {\n                temp[i++] = A[left++];\n            } else {\n                count += mid - left + 1;\n                temp[i++] = A[right++];\n            }\n        }\n        while (left <= mid)\n            temp[i++] = A[left++];\n        while (right <= high)\n            temp[i++] = A[right++];\n        for (int j = 0; j < temp.length; j++)\n            A[j + low] = temp[j];\n        return count;\n    }\n\n    public static int mergeSort(int[] A, int low, int high) {\n        if (low == high) return 0;\n        int mid = (low + high) / 2;\n        int count = 0;\n        count += mergeSort(A, low, mid);\n        count += mergeSort(A, mid + 1, high);\n        count += merge(A, low, mid, high);\n        return count;\n    }\n\n    public static int numberOfInversions(int[] A, int n) {\n        // Write your code here.\n        return mergeSort(A, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {5, 4, 3, 2, 1};\n//        int[] arr = {1, 2, 3, 4, 5};\n        int inversions = numberOfInversions(arr, arr.length);\n        System.out.println(inversions);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '503230fc-0dc8-4846-893e-2c61a3da62b7',
                  isFolder: false,
                  name: 'FourSum.java',
                  code: 'import java.util.*;\n\npublic class FourSum {\n    public static void fourSum(int[] A, int target) {\n        int n = A.length;\n//        BETTER APPROACH\n//         HashSet<List<Integer>> unique = new HashSet<>();\n//         for (int i = 0; i < n; i++) {\n//             for (int j = i + 1; j < n; j++) {\n//                 HashSet<Integer> hs = new HashSet<>();\n//                 for (int k = j + 1; k < n; k++) {\n//                     int fourth = target - (A[i] + A[j] + A[k]);\n//                     if (hs.contains(fourth)) {\n//                         List<Integer> temp = Arrays.asList(A[i], A[j], A[k], fourth);\n//                         temp.sort(null);\n//                         unique.add(temp);\n//                     }\n//                     hs.add(A[k]);\n//                 }\n//             }\n//         }\n//         List<List<Integer>> X = new ArrayList<>(unique);\n\n//        BEST APPROACH\n       Arrays.sort(A);\n       List<List<Integer>> ans = new ArrayList<>();\n       for (int i = 0; i < n; i++) {\n           if (i > 0 && A[i] == A[i - 1]) continue;\n           for (int j = i + 1; j < n - 1; j++) {\n               if (j > i+1 && A[j] == A[j - 1]) continue;\n               int k = j + 1;\n               int l = n - 1;\n               while (k < l) {\n                   int sum = A[i];\n                   sum += A[j];\n                   sum += A[k];\n                   sum += A[l];\n                   if (sum > target) l--;\n                   else if (sum < target) k++;\n                   else {\n                       ans.add(Arrays.asList(A[i], A[j], A[k], A[l]));\n                       k++;\n                       l--;\n                       while (k < l && A[k] == A[k - 1]) k++;\n                       while (k < l && A[l] == A[l + 1]) l--;\n                   }\n               }\n           }\n       }\n       System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 0, -1, 0, -2, 2};\n        fourSum(arr, 0);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '3c1591e0-5ef2-4d42-9a8a-3d9407b973f7',
                  isFolder: false,
                  name: 'LargestSubArray0Sum.java',
                  code: 'import java.util.HashMap;\n\npublic class LargestSubArray0Sum {\n    public static int longestSubArrayWith0Sum(int[] arr) {\n        int longest = 0;\n//        Better solution O(N^2)\n//        for (int i = 0; i < arr.length; i++) {\n//            int sum = 0;\n//            for (int j = i; j < arr.length; j++) {\n//                sum += arr[j];\n//                if (sum == 0)\n//                    longest = Math.max(longest, j - i + 1);\n//            }\n//        }\n\n//        Best solution\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n            if (sum == 0)\n                longest = Math.max(longest, i + 1);\n            else if (hm.containsKey(sum))\n                longest = Math.max(longest, i - hm.get(sum));\n            if (!hm.containsKey(sum)) hm.put(sum, i);\n        }\n        return  longest;\n    }\n    public static void main(String[] args) {\n        int[] arr = {9, -3, 3, -1, 6, -5};\n        int ans = longestSubArrayWith0Sum(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '3ab2a98b-f559-45a1-94d4-98ad8ed56121',
                  isFolder: false,
                  name: 'MajorityElementNBy3.java',
                  code: 'import java.util.*;\n\npublic class MajorityElementNBy3 {\n    public static void printMajorityElements(int[] arr) {\n        List<Integer> ans = new ArrayList<>();\n        int majority = (arr.length / 3) + 1;\n//        Better approach\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        for (int j : arr) {\n//            hm.put(j, hm.getOrDefault(j, 0) + 1);\n//        }\n//        for (Map.Entry<Integer, Integer> x: hm.entrySet()) {\n//            if (x.getValue() > majority) ans.add(x.getKey());\n//            if (ans.size() == 2) break;\n//        }\n\n//        Best approach\n        int c1 = 0, c2 = 0, e1 = -1, e2 = -1;\n        for (int j : arr) {\n            if (c1 == 0 && e2 != j) {\n                c1 = 1;\n                e1 = j;\n            } else if (c2 == 0 && e1 != j) {\n                c2 = 1;\n                e2 = j;\n            } else if (j == e1) c1++;\n            else if (j == e2) c2++;\n            else {\n                c1--;\n                c2--;\n            }\n        }\n//        We got elements\n        c1 = 0;\n        c2 = 0;\n        for (int i: arr) {\n            if (i == e1) c1++;\n            else if (i == e2) c2++;\n        }\n        if (c1 >= majority) ans.add(e1);\n        if (c2 >= majority) ans.add(e2);\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 1, 1, 3, 1, 4, 5, 6};\n        printMajorityElements(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'fba99f90-32dc-44fa-adf8-175a0ebb0e74',
                  isFolder: false,
                  name: 'MaximumProductSubArray.java',
                  code: 'public class MaximumProductSubArray {\n    public static int subarrayWithMaxProduct(int []arr){\n        // Brute force\n//        int maxProd = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int prod = arr[i];\n//            for (int j = i+1; j < arr.length; j++) {\n//                prod *= arr[j];\n//                maxProd = Math.max(maxProd, prod);\n//            }\n//        }\n//        return maxProd;\n        // Best approach\n        int maxProd = arr[0];\n        int prodLeft = 1;\n        int prodRight = 1;\n        for (int i = 0; i < arr.length; i++) {\n            prodLeft *= arr[i];\n            prodRight *= arr[arr.length - i - 1];\n            maxProd = Math.max(maxProd, Math.max(prodLeft, prodRight));\n            if (prodLeft == 0) prodLeft++;\n            if (prodRight == 0) prodRight++;\n        }\n        return maxProd;\n    }\n    public static void main(String[] args) {\n        int[] arr = {-2, 3, -4, 0};\n        int ans = subarrayWithMaxProduct(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '7aaa6dd4-dec6-4b5a-b957-d6c5d78c3aa1',
                  isFolder: false,
                  name: 'MergeOverlappingSubIntervals.java',
                  code: 'import java.util.*;\n\npublic class MergeOverlappingSubIntervals {\n    public static void mergeIntervals(int[][] arr) {\n        Arrays.sort(arr, Comparator.comparingInt(a -> a[0]));\n        int start = arr[0][0], end = arr[0][1];\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 1; i < arr.length; i++) {\n            if (end >= arr[i][0])\n                end = Math.max(end, arr[i][1]);\n            else {\n                ans.add(Arrays.asList(start, end));\n                start = arr[i][0];\n                end = arr[i][1];\n            }\n        }\n        ans.add(Arrays.asList(start, end));\n        System.out.println(ans);\n    }\n    public static void main(String[] args) {\n//        int[][] arr = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n        int[][] arr = {{1, 4}, {4, 5}};\n        mergeIntervals(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '32abeb94-f157-48d9-9237-2ea30223afca',
                  isFolder: false,
                  name: 'MergeTwoSortedArrays.java',
                  code: 'import java.util.Arrays;\n\npublic class MergeTwoSortedArrays {\n//    Variation 1\n    public static void mergeSortedArrays(int[] a, int[] b, int m, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        while (j >= 0) {\n            if (a[i] >= b[j])\n                a[k--] = a[i--];\n            else\n                a[k--] = b[j--];\n        }\n        System.out.println(Arrays.toString(a));\n    }\n    public static void mergeSortedArrays2(int[] a, int[] b) {\n        int m = a.length, n = b.length;\n//        int[] temp = new int[m+n];\n//        int left = 0, right = 0, index = 0;\n//        while (left < m && right < n) {\n//            if (a[left] <= b[right]) {\n//                temp[index++] = a[left++];\n//            } else {\n//                temp[index++] = b[right++];\n//            }\n//        }\n//        while (left < m) temp[index++] = a[left++];\n//        while (right < n) temp[index++] = b[right++];\n//        for (int i = 0; i < temp.length; i++) {\n//            if (i < m)\n//                a[i] = temp[i];\n//            else\n//                b[i-m] = temp[i];\n//        }\n        int l = m - 1;\n        int r = 0;\n        while (l >=0 && r < n) {\n            if (a[l] <= b[r]) break;\n            int temp = a[l];\n            a[l--] = b[r];\n            b[r++] = temp;\n        }\n        Arrays.sort(a);\n        Arrays.sort(b);\n        System.out.println(Arrays.toString(a));\n        System.out.println(Arrays.toString(b));\n    }\n\n    public static void main(String[] args) {\n//        Type 1:\n//        int[] a = {1, 4, 8, 10, 0, 0, 0};\n//        int[] b = {2, 3, 9};\n//        mergeSortedArrays(a, b, 4,3);\n        int[] a = {1, 4, 8, 10};\n        int[] b = {2, 3, 9};\n        mergeSortedArrays2(a, b);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'b822bfcf-ffa1-4032-b89a-4581ea6ca30e',
                  isFolder: false,
                  name: 'MissingAndDuplicateNumber.java',
                  code: 'public class MissingAndDuplicateNumber {\n    //    Without changing the input array\n    public static void findMissingRepeatingNumbers(int[] arr) {\n//        Mathematical equation technique\n        int n = arr.length;\n        long S = 0;\n        long S2 = 0;\n        long SN = (long) n * (n + 1) /2;\n        long S2N = n * (n + 1) * (2L * n + 1) /6;\n        for (int i : arr) {\n            S += i;\n            S2 += (long) i *i;\n        }\n        long val1 = S - SN; // (X - Y)\n        long val2 = S2 - S2N; // (X - Y) (X + Y)\n        long x = (val2/val1 + val1)/2;\n        long y = x - val1;\n        System.out.println("x: " + x + " y: " + y);\n\n//        int[] count = new int[arr.length];\n//        for (int i : arr) {\n//            count[i - 1]++;\n//        }\n//        int missing = -1, duplicate = -1;\n//        for (int i = 0; i < count.length; i++) {\n//            if (count[i] == 0)\n//                missing = i+1;\n//            else if (count[i] == 2)\n//                duplicate = i+1;\n//            if (missing != -1 && duplicate != -1) break;\n//        }\n//        System.out.println(Arrays.asList(duplicate, missing));\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 1, 2, 5, 3};\n        findMissingRepeatingNumbers(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '41fdf0b1-935d-4f7a-a766-4d3f182b9c56',
                  isFolder: false,
                  name: 'PascalsTriangle.java',
                  code: "import java.util.Arrays;\n\npublic class PascalsTriangle {\n    //    static int fact(int x) {\n//        int product = 1;\n//        for (int i = 2; i <= x; i++)\n//            product *= i;\n//        return product;\n//    }\n    static int getNCR(int n, int r) {\n//        int numerator = fact(n);\n//        int denominator = fact(r) * fact(n-r);\n//        return (int) (numerator / denominator);\n        long res = 1;\n        for (int i = 0; i < r; i++) {\n            res *= n - i;\n            res /= i + 1;\n        }\n        return (int) res;\n    }\n\n    //    Type 1:  Given row r and column c. Print the element at position (r, c) in Pascal's triangle.\n    public static int getTriangleValue(int row, int col) {\n        return getNCR(row - 1, col - 1);\n    }\n\n    //    Type 2: Given the row number n. Print the n-th row of Pascal's triangle.\n    public static int[] printRowPascalsTriangle(int n) {\n        int[] arr = new int[n];\n        int ans = 1;\n        arr[0] = ans;\n        for (int i = 1; i < n; i++) {\n            ans *= n - i;\n            ans /= i;\n            arr[i] = ans;\n        }\n//        for (int i = 0; i < n; i++) {\n//            ans[i] = getNCR(n-1, i);\n//        }\n        return arr;\n    }\n\n    //    Type 3: Given the number of rows n. Print the first n rows of Pascal's triangle.\n    public static void printPascalsTriangle(int n) {\n        int[][] ans = new int[n][];\n        for (int i = 1; i <= n; i++) {\n            ans[i-1] = printRowPascalsTriangle(i);\n        }\n        for (int[] a: ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n\n    public static void main(String[] args) {\n        int ans = getTriangleValue(5, 3);\n        System.out.println(ans);\n        int[] row = printRowPascalsTriangle(5);\n        System.out.println(Arrays.toString(row));\n        printPascalsTriangle(9);\n    }\n}",
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '95b54230-4439-45a8-9507-6c592756ae0e',
                  isFolder: false,
                  name: 'ReversePairs.java',
                  code: 'public class ReversePairs {\n    public static int countPairs(int[] A, int low, int mid, int high) {\n        int count = 0;\n        int right = mid + 1;\n        for (int i = low; i <= mid; i++) {\n            while (right <= high && A[i] > 2*A[right]) {\n                right++;\n            }\n            count += right - mid - 1;\n        }\n        return count;\n    }\n\n    public static void merge(int[] A, int low, int mid, int high) {\n        int left = low, right = mid + 1, i = 0;\n        int[] temp = new int[high - low + 1];\n        while (left <= mid && right <= high) {\n            if (A[left] <= A[right])\n                temp[i++] = A[left++];\n            else\n                temp[i++] = A[right++];\n        }\n        while (left <= mid)\n            temp[i++] = A[left++];\n        while (right <= high)\n            temp[i++] = A[right++];\n        for (int j = 0; j < temp.length; j++)\n            A[j + low] = temp[j];\n    }\n\n    public static int mergeSort(int[] A, int low, int high) {\n        if (low == high) return 0;\n        int mid = (low + high) / 2;\n        int count = 0;\n        count += mergeSort(A, low, mid);\n        count += mergeSort(A, mid + 1, high);\n        count += countPairs(A, low, mid,  high);\n        merge(A, low, mid, high);\n        return count;\n    }\n\n    public static int reversePairsCount(int[] A, int n) {\n        // Write your code here.\n        return mergeSort(A, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 1, 2, 3, 1};\n        int count = reversePairsCount(arr,  5);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '73437da2-6c37-42ca-8e84-01a22e983ee2',
                  isFolder: false,
                  name: 'SubArraysWithXORK.java',
                  code: 'import java.util.HashMap;\n\npublic class SubArraysWithXORK {\n    public static int getSubArrayCountWithXORK (int[] arr, int k) {\n//        Best solution\n        int count = 0;\n        int xor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        for (int i = 0; i < arr.length; i++) {\n            xor ^= arr[i];\n            if (hm.containsKey(xor^k)) {\n                count += hm.get(xor^k);\n            }\n            hm.put(xor, hm.getOrDefault(xor, 0)+1);\n        }\n        return count;\n\n//        Better Solution\n//        int count = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int xor = 0;\n//            for (int j = i; j < arr.length; j++) {\n//                xor ^= arr[j];\n//                if (xor == k)\n//                    count++;\n//            }\n//        }\n//        return count;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 6, 7, 8, 9};\n        int count = getSubArrayCountWithXORK(arr, 5);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'f8027344-0470-4597-b14d-6047e9c0a41a',
                  isFolder: false,
                  name: 'ThreeSum.java',
                  code: 'import java.util.*;\n\npublic class ThreeSum {\n    public static List<List<Integer>> threeSum(int[] arr) {\n//        HashSet<List<Integer>> hs = new HashSet<>();\n//        for (int i = 0; i < arr.length; i++) {\n//            HashMap<Integer, Integer> hm = new HashMap<>();\n//            for (int j = i+1; j < arr.length; j++) {\n//                int temp = -1 * (arr[i] + arr[j]);\n//                if (hm.containsKey(temp)) {\n//                    List<Integer> tempArr = new ArrayList<>(Arrays.asList(arr[i], arr[j], temp));\n//                    tempArr.sort(null);\n//                    hs.add(tempArr);\n//                }\n//                hm.put(arr[j], j);\n//            }\n//        }\n//        return new ArrayList<>(hs);\n        int n = arr.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(arr);\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && arr[i] == arr[i-1]) continue;\n            int j = i + 1;\n            int k = n - 1;\n            while (j < k) {\n                int sum = arr[i] + arr[j] + arr[k];\n                if (sum < 0) {\n                    j++;\n                } else if (sum > 0) {\n                    k--;\n                } else {\n                    ans.add(Arrays.asList(arr[i], arr[j], arr[k]));\n                    j++;\n                    k--;\n                    while (j < k && arr[j] == arr[j-1]) j++;\n                    while (j < k && arr[k] == arr[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int[] arr = {-1, 0, 1, 0};\n        List<List<Integer>> ans = threeSum(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '45377fd0-703a-46df-98ff-3a08b203ed95',
                  isFolder: false,
                  name: 'ArrayMaxSumSubarray.java',
                  code: 'import java.util.Arrays;\n\npublic class ArrayMaxSumSubarray {\n    public static int[] getMaxSubarraySumArray(int[] arr) {\n        int start = -1, end = -1;\n        int sum = 0, maxSum = arr[0];\n        int temp = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum == 0) temp = i;\n            sum += arr[i];\n            if (maxSum < sum) {\n                maxSum = sum;\n                start = temp;\n                end = i;\n            }\n            if (sum < 0) sum = 0;\n        }\n\n        System.out.println(start + " " + end);\n        return Arrays.copyOfRange(arr, start, end+1);\n    }\n\n    public static int getMaxSubarraySumLength(int[] arr) {\n        int start = -1, end = -1, temp = 0;\n        int sum = 0, maxSum = arr[0];\n        for (int i = 0; i < arr.length; i++) {\n            if (sum == 0) temp = i;\n            sum += arr[i];\n            if (maxSum < sum) {\n                maxSum = sum;\n                start = temp;\n                end = i;\n            }\n            if (sum < 0) sum = 0;\n        }\n        return end - start+1;\n    }\n\n    public static int getMaxSubarraySum(int[] arr) {\n        int sum = 0, maxSum = arr[0];\n        for (int j : arr) {\n            sum += j;\n            if (maxSum < sum) maxSum = sum;\n            if (sum < 0) sum = 0;\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n//        TESTING\n//        int[] arr = {-4, 1, -2, 1, 5, -3, 1, 3, -1, -2};\n//        int[] arr = {-4, -1, -2, -1, -5, -3, 1, -3, -1, -2};\n        int[] arr = {-4, 1, 2, 1, -5, 3, 1, 3, 1, -2};\n//        int[] arr = {-4, 5, 7, -6, 10, -15, 3};\n//        int[] arr = {-3, 2, -1, 4, -2};\n//        int[] arr = {-1,2};\n//        int[] arr = {-2,-1};\n        int ans = getMaxSubarraySumLength(arr);\n        int[] ansArray = getMaxSubarraySumArray(arr);\n        int ansSum = getMaxSubarraySum(arr);\n        System.out.println("Length: " + ans);\n        System.out.println("Sum: " + ansSum);\n        System.out.println("Array: " + Arrays.toString(ansArray));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '9be4cfe5-b9b2-46e8-9634-cbcec254df7f',
                  isFolder: false,
                  name: 'LongestConsecutiveSequence.java',
                  code: 'import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class LongestConsecutiveSequence {\n    public static boolean found(int[] arr, int target) {\n        for (int i : arr)\n            if (target == i) return true;\n        return false;\n    }\n\n    public static int longestConsecutiveSequenceLength(int[] arr) {\n//        Brute force: O(N^2) time\n//        int longest = 1;\n//        for (int j : arr) {\n//            int count = 1;\n//            int x = j;\n//            while (found(arr, x+1)) {\n//                x++;\n//                count++;\n//            }\n//            longest = Math.max(longest, count);\n//        }\n//        return longest;\n\n//        Better Solution\n//        Arrays.sort(arr);\n//        int longest = 1;\n//        int currentCount = 0;\n//        int last = Integer.MIN_VALUE;\n//        for (int i = 0; i < arr.length; i++) {\n//            if (arr[i] - 1 == last) {\n//                currentCount++;\n//            } else if (arr[i] != last) {\n//                currentCount = 1;\n//            }\n//            longest = Math.max(longest, currentCount);\n//            last = arr[i];\n//        }\n//        return longest;\n\n//        Best\n        int longest = 1;\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : arr) {\n            hs.add(i);\n        }\n        for (int j : arr) {\n            if (!hs.contains(j - 1)) {\n                int count = 1;\n                int element = j;\n                while (hs.contains(element + 1)) {\n                    count++;\n                    element++;\n                }\n                longest = Math.max(longest, count);\n            }\n        }\n        return longest;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 9, 4, 5};\n        int ans = longestConsecutiveSequenceLength(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: 'd129c540-d96d-42f5-8d6b-1af4d1f461b6',
                  isFolder: false,
                  name: 'NextPermutation.java',
                  code: 'import java.util.Arrays;\n\npublic class NextPermutation {\n    // Reverse\n    public static void reverse(int[] arr, int start, int end) {\n        while (start < end) {\n            swap(arr, start++, end--);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int[] nextPermutation(int[] arr) {\n        int n = arr.length;\n        int bp = -1;\n        for (int i = n - 1; i > 0; i--) {\n            if (arr[i] > arr[i - 1]) {\n                bp = i - 1;\n                break;\n            }\n        }\n        if (bp == -1) {\n            reverse(arr, 0, n - 1);\n            return arr;\n        }\n//        Ceiling\n        for (int j = n - 1; j > bp; j--) {\n            if (arr[j] > arr[bp]) {\n                swap(arr, j, bp);\n                break;\n            }\n        }\n        reverse(arr, bp+1, n - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 2};\n        int[] ans = nextPermutation(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '3d5e7579-bd65-4238-b622-3f7ddea7f5c5',
                  isFolder: false,
                  name: 'RotateBy90.java',
                  code: 'import java.util.Arrays;\n\npublic class RotateBy90 {\n    public static  void reverse (int[] arr) {\n        int start = 0, end = arr.length - 1;\n        while (start < end) {\n            int temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n    public static void rotateMatrix(int[][] mat) {\n        // Brute force solution\n//        int[][] newMat = new int[mat.length][mat[0].length];\n//        for (int r = 0; r < mat.length; r++) {\n//            for (int c = 0; c < mat[r].length; c++) {\n//                newMat[c][mat[r].length - r - 1] = mat[r][c];\n//            }\n//        }\n//        return newMat;\n//                if (r != c) System.out.println("r: "+r + " c: " + c + " A: " + mat[r][c] + " B: " + mat[c][r]);\n        // Best solution\n        for (int r = 0; r < mat.length; r++) {\n            for (int c = r; c < mat[r].length; c++) {\n                int temp = mat[r][c];\n                mat[r][c] = mat[c][r];\n                mat[c][r] = temp;\n            }\n        }\n        for (int[] row : mat) reverse(row);\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 9},\n        };\n        rotateMatrix(mat);\n        for (int[] a : mat) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: 'b58c9805-8f05-4123-be46-b77b728f6f66',
                  isFolder: false,
                  name: 'SetMatrixZero.java',
                  code: 'import java.util.Arrays;\n\npublic class SetMatrixZero {\n    //    Helper functions\n    public static void setRow(int[][] mat, int index) {\n        for (int i = 0; i < mat.length; i++)\n            mat[index][i] = -1;\n    }\n\n    public static void setCol(int[][] mat, int index) {\n        for (int i = 0; i < mat.length; i++)\n            mat[i][index] = -1;\n    }\n\n    public static int[][] setMatrixZero(int[][] mat) {\n//        Brute force\n//        for (int i = 0; i < mat.length; i++) {\n//            for (int j = 0; j < mat[i].length; j++) {\n//                if (mat[i][j] == 0) {\n//                    setRow(mat, i);\n//                    setCol(mat, j);\n//                }\n//            }\n//        }\n//        for (int i = 0; i < mat.length; i++)\n//            for (int j = 0; j < mat[i].length; j++)\n//                if (mat[i][j] == -1) mat[i][j] = 0;\n\n//        Better\n//        int[] rows = new int[mat.length];\n//        int[] cols = new int[mat[0].length];\n//        for (int i = 0; i < mat.length; i++) {\n//            for (int j = 0; j < mat[i].length; j++) {\n//                if (mat[i][j] == 0) {\n//                    rows[i] = -1;\n//                    cols[j] = -1;\n//                }\n//            }\n//        }\n//        for (int i = 0; i < mat.length; i++)\n//            for (int j = 0; j < mat[i].length; j++)\n//                if (cols[j] == -1 || rows[i] == -1) mat[i][j] = 0;\n\n//        Best\n        int col0 = 1;\n        for (int i = 0; i < mat.length; i++) {\n            if (mat[i][0] == 0) col0 = 0; // One column\n            // Rest of the columns\n            for (int j = 1; j < mat[i].length; j++) {\n                if (mat[i][j] == 0) {\n                    mat[i][0] = 0;\n                    mat[0][j] = 0;\n                }\n            }\n        }\n        for (int r = mat.length  - 1; r >= 0; r--) {\n            for (int c = mat[r].length - 1; c > 0; c--) {\n                if (mat[r][0] == 0 || mat[0][c] == 0) mat[r][c] = 0;\n            }\n            // First column\n            if (col0 == 0) {\n                mat[r][0] = 0;\n            }\n        }\n\n        return mat;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 1, 1, 1},\n                {1, 0, 0, 1},\n                {1, 1, 0, 1},\n                {1, 1, 1, 1}\n        };\n        int[][] ans = setMatrixZero(mat);\n        for (int[] a : ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: 'd12a1ea1-0930-4e87-9435-d3532981042e',
                  isFolder: false,
                  name: 'SpiralMatrix1.java',
                  code: 'import java.util.Arrays;\n\npublic class SpiralMatrix1 {\n    public static int[] printSpiralMatrix(int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n        int rStart = 0, rEnd = n - 1;\n        int cStart = 0, cEnd = m - 1;\n        int[] ans = new int[n*m];\n        int index = 0;\n        while (rStart <= rEnd && cStart <= cEnd) {\n//            LR\n            for (int i = cStart; i <= cEnd; i++) {\n                ans[index++] = mat[rStart][i];\n            }\n            rStart++;\n//            TB\n            for (int i = rStart; i <= rEnd; i++) {\n                ans[index++] = mat[i][cEnd];\n            }\n            cEnd--;\n            if (index == n*m) break;\n//            RL\n            for (int i = cEnd; i >= cStart; i--) {\n                ans[index++] = mat[rEnd][i];\n            }\n            rEnd--;\n//            BT\n            for (int i = rEnd; i >= rStart; i--) {\n                ans[index++] = mat[i][cStart];\n            }\n            cStart++;\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int[][] mat = {\n                { 1, 2, 3 },\n                { 4, 5, 6 },\n                { 7, 8, 9 }\n        };\n        int[] ans = printSpiralMatrix(mat);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '054c3b9b-3db0-4cae-9b8e-2810eb2761a5',
                  isFolder: false,
                  name: 'SubArraysWithGivenSum.java',
                  code: 'import java.util.HashMap;\n\npublic class SubArraysWithGivenSum {\n    public static int getSubArraysWithGivenSum(int[] arr, int k) {\n        // This solution wont handle negative numbers\n//        int l = 0, r = 0;\n//        int count = 0;\n//        int sum = 0;\n//        while (r < arr.length) {\n//            sum += arr[r];\n//            while (l <= r && sum > k)\n//                sum -= arr[l++];\n//            if (sum == k) count++;\n//            r++;\n//        }\n//        return count;\n//        This can handle positive and negative numbers\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        int count = 0, sum = 0;\n        for (int j : arr) {\n            sum += j;\n            if (hm.containsKey(sum - k))\n                count += hm.get(sum - k);\n            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, -3, 1, 1, 1, 4, 2, -3};\n        int ans = getSubArraysWithGivenSum(arr, 3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
              ],
            },
            {
              id: '9a47306b-e28a-4671-803d-2e4bacee502f',
              isFolder: true,
              name: 'Binary Search',
              content: [
                {
                  id: '7d8befb0-8022-4101-953e-9163b494e608',
                  isFolder: false,
                  name: 'CeilAndFloor.java',
                  code: 'import java.util.*;\nimport java.io.*;\n\npublic class CeilAndFloor {\n    public static int floor(int[] arr, int target, int n) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int ceil(int[] arr, int target, int n) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static int ceilingInSortedArray(int n, int x, int[] arr) {\n        // Write your code here.\n        Arrays.sort(arr);\n        int ceilElement = ceil(arr, x, n);\n        int floorElement = floor(arr, x, n);\n        if (ceilElement != n) {\n            ceilElement = arr[ceilElement];\n        } else {\n            ceilElement = -1;\n        }\n        if (floorElement != -1) {\n            floorElement = arr[floorElement];\n        }\n\n        System.out.print(floorElement + " ");\n        return ceilElement;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {48, 26, 2, 6, 10, 48, 11, 21, 47, 50, 50, 45, 43, 27};\n        int ans = ceilingInSortedArray(arr.length, 51, arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'c429ec04-6687-4534-b4ac-657e0fca6b07',
                  isFolder: false,
                  name: 'CountOccurrencesSortedArrayWithDuplicates.java',
                  code: 'public class CountOccurrencesSortedArrayWithDuplicates {\n    public static int count(int[] arr, int n, int x) {\n        //Your code goes here\n        int first = bs(arr, x, true);\n        if (first == -1)\n            return 0;\n        int second = bs(arr, x, false);\n        return second - first + 1;\n    }\n\n    public static int bs(int[] arr, int target, boolean lookLeft) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) {\n                ans = mid;\n                if (lookLeft)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 1, 2, 2, 3, 3};\n        int count = count(arr, arr.length,1);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'f86491cd-39cf-4d0d-bcce-caa343adbdf5',
                  isFolder: false,
                  name: 'FindMinimumRotatedSortedArray.java',
                  code: 'public class FindMinimumRotatedSortedArray {\n    public static int getMinimumInRotatedSortedArray(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n//            Condition to handle duplicates\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                end--;\n                continue;\n            }\n            if (arr[mid] > arr[end]) {\n                // left sorted\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                // right sorted\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n\n    public static int getPivot(int[] arr) {\n//        PIVOT: Index of the point till where the array is rotated (MAX Element)\n        int start = 0;\n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (mid < end && arr[mid] > arr[mid + 1]) return mid;\n            if (mid > start && arr[mid - 1] > arr[mid]) return mid - 1;\n            if (arr[mid] > arr[end])\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 1, 3, 3, 3, 3, 3};\n        int ans = getMinimumInRotatedSortedArray(arr);\n        System.out.println(ans);\n        int pivot = getPivot(arr);\n        System.out.println(pivot + 1);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '0487314e-19dd-4cd8-9c9e-6d3fb3afa9e9',
                  isFolder: false,
                  name: 'FindPeakElement.java',
                  code: 'public class FindPeakElement {\n    public static int getPeakIndex(int[] arr) {\n//        Brute force solution\n//        int n = arr.length;\n//        if (n == 1 || arr[0] > arr[1]) return 0;\n//        if (arr[n-1] > arr[n-2]) return n-1;\n//        for (int i = 1; i < arr.length - 1; i++) {\n//            if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {\n//                return i;\n//            }\n//        }\n//        return -1;\n//        Optimised approach\n        int n = arr.length;\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            boolean isLeftBig = mid > start && arr[mid - 1] > arr[mid];\n            boolean isRightBig = mid < end && arr[mid + 1] > arr[mid];\n            if (!isLeftBig && !isRightBig) return mid;\n            if (isLeftBig) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1,2,1,3,4};\n        int ans = getPeakIndex(arr);\n        System.out.println(arr[ans]);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'ab91fb55-c410-4364-8a1a-638a14b26e2c',
                  isFolder: false,
                  name: 'FirstAndLastPosition.java',
                  code: 'import java.util.* ;\nimport java.io.*;\npublic class FirstAndLastPosition {\n    public static int lower_bound(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) >= k) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static int upper_bound(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) > k) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public  static int bSearchFirstLast(ArrayList<Integer> arr, int target, boolean lookLeft) {\n        int start = 0;\n        int end = arr.size() - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) == target) {\n                ans = mid;\n                if (lookLeft)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n            else  if (arr.get(mid) > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return ans;\n    }\n\n    public static int[] firstAndLastPosition(ArrayList<Integer> arr, int n, int k) {\n        // Write your code here.\n//        int first = lower_bound(arr, n, k);\n//        int last = upper_bound(arr, n, k) - 1;\n        int first = bSearchFirstLast(arr, k, true);\n        int last = bSearchFirstLast(arr, k, false);\n        return new int[] {first, last};\n    }\n\n};',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'e81512f4-16b1-44db-a561-63b696b9fd67',
                  isFolder: false,
                  name: 'LowerBound.java',
                  code: 'public class LowerBound {\n//    Brute force is Linear search or a simple for loop\n\n//    If the arr has duplicates go left\n    public static int lowerBound(int []arr, int n, int x) {\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] >= x)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 3, 3, 5};\n//        int[] arr = {1, 2, 2, 2, 2, 2};\n        int ans = lowerBound(arr, arr.length, 2);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '7a881559-4470-4694-a16f-9a52142fc443',
                  isFolder: false,
                  name: 'SearchIndexPosition.java',
                  code: 'public class SearchIndexPosition {\n    public static int searchInsert(int [] arr, int m){\n        // Write your code here.\n        int start = 0; \n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] >= m) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 4, 7};\n        int ans = searchInsert(arr, 9);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'ab087472-9938-48df-b40e-87e531980c34',
                  isFolder: false,
                  name: 'SearchInRotatedArray1.java',
                  code: 'import java.util.*;\n\npublic class SearchInRotatedArray1 {\n    public static int search(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int midValue = arr.get(mid);\n            if (midValue == k) return mid;\n            if (midValue < arr.get(end)) {\n                if (k > midValue && k <= arr.get(end))\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            } else {\n                if (k >= arr.get(start) && k < midValue)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(8, 9, 4, 5));\n        int search = search(arr, 4, 8);\n        System.out.println(search);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: 'd4b94833-044f-4ccd-8e4e-8d965999e4db',
                  isFolder: false,
                  name: 'SearchInRotatedArray2.java',
                  code: 'public class SearchInRotatedArray2 {\n    public static boolean searchInARotatedSortedArrayII(int[] arr, int k) {\n        int start = 0;\n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] == k) return true;\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                start++;\n                end--;\n                continue;\n            }\n            if (arr[mid] < arr[end]) { //Right sorted\n                if (k > arr[mid] && k <= arr[end])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            } else { // Left sorted\n                if (k >= arr[start] && k < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 1, 3, 3, 3, 3};\n        boolean found = searchInARotatedSortedArrayII(arr, 10);\n        System.out.println(found);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '1e59cf9a-699c-4a9e-b5bb-e3af7f494df2',
                  isFolder: false,
                  name: 'SingleNonDuplicateElementSortedArray.java',
                  code: 'public class SingleNonDuplicateElementSortedArray {\n    public static int singleNonDuplicate(int[] arr) {\n//        Write the code here\n//        int n = arr.length;\n//        for (int i = 0; i < n; i++) {\n//            if (i == 0) {\n//                if (arr[0] != arr[1])\n//                    return 0;\n//            } else if (i == n - 1) {\n//                if (arr[n-1] != arr[n-2])\n//                    return n-1;\n//            } else {\n//                if (arr[i-1] != arr[i] && arr[i+1] != arr[i])\n//                    return i;\n//            }\n//        }\n//        return -1;\n        int n = arr.length;\n        if (n == 1) return arr[0];\n        if (arr[0] != arr[1]) return arr[0];\n        if (arr[n-1] != arr[n-2]) return arr[n-1];\n        int start = 1;\n        int end = n-2;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] != arr[mid + 1] && arr[mid] != arr[mid - 1]) return arr[mid];\n            if ((mid%2==0 && arr[mid] == arr[mid+1]) || (mid%2==1 && arr[mid] == arr[mid - 1])) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6};\n        int ans = singleNonDuplicate(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '90900c85-6120-4f23-b4ad-893fc16ef414',
                  isFolder: false,
                  name: 'SortedArrayRotationCount.java',
                  code: 'public class SortedArrayRotationCount {\n    public static int findKRotation(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        int idx = 0;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n//            For removing duplicates\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                if (ans > arr[mid]) {\n                    ans = arr[mid];\n                    idx = mid;\n                }\n                end--;\n                continue;\n            }\n            if (arr[mid] > arr[end]) {\n                if (ans > arr[start]) {\n                    ans = arr[start];\n                    idx = start;\n                }\n                start = mid + 1;\n            } else {\n                if (ans > arr[mid]) {\n                    ans = arr[mid];\n                    idx = mid;\n                }\n                end = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 4, 4, 4, 4, 4, 4, 4};\n        int ans = findKRotation(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '208699ae-47ef-42a9-bd01-45c37eff427f',
                  isFolder: false,
                  name: 'UpperBound.java',
                  code: 'public class UpperBound {\n    public static int upperBound(int[] arr, int x, int n) {\n        // Write your code here.\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] <= x) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 14, 16, 23};\n        int ans = upperBound(arr, 12, arr.length);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '10c84222-452e-46e2-bb76-f7b78e491500',
                  isFolder: false,
                  name: 'FindPeakElementInGrid.java',
                  code: 'import java.util.Arrays;\n\npublic class FindPeakElementInGrid {\n    public static int[] findPeakGrid(int [][]mat) {\n// Brute force solution\n//        int n = mat.length;\n//        int m = mat[0].length;\n//        int max = Integer.MIN_VALUE;\n//        int[] ans = {-1, -1};\n//        for (int i = 0; i < n; i++) {\n//            for (int j = 0; j < m; j++) {\n//                if (mat[i][j] > max) {\n//                    max = mat[i][j];\n//                    ans[0] = i;\n//                    ans[1] = j;\n//                }\n//            }\n//        }\n//        return ans;\n\n        // Optimal solution\n        int start = 0;\n        int end = mat[0].length - 1;\n        while (start <= end) {\n            int maxRow = 0;\n            int mid = start + (end - start)/2;\n            for (int i = 0; i < mat.length; i++) {\n                if (mat[maxRow][mid] < mat[i][mid])\n                    maxRow = i;\n            }\n            boolean leftBig = mid > start && mat[maxRow][mid] < mat[maxRow][mid-1];\n            boolean rightBig = mid < end && mat[maxRow][mid] < mat[maxRow][mid+1];\n            if (!leftBig && !rightBig) return new int[]{maxRow, mid};\n            if (leftBig) end = mid - 1;\n            else start = mid + 1;\n        }\n        return new int[]{-1, -1};\n    }\n\n    public static void main(String[] args) {\n        int[][] values = {\n                {6},\n                {1},\n                {10}\n        };\n        int[] ans = findPeakGrid(values);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '1029b778-e6ca-4601-83e1-d88e82cb1c05',
                  isFolder: false,
                  name: 'MatrixMaximumOnesRow.java',
                  code: 'import java.util.ArrayList;\n\npublic class MatrixMaximumOnesRow {\n    public static int maximumOnesRow(ArrayList<ArrayList<Integer>> matrix, int n, int m) {\n        //\t  Brute force O(m*n)\n//        int maxRow = 0;\n//        int maxCount = 0;\n//        for (int i = 0; i < n; i++) {\n//            int count = 0;\n//            for (int j = 0; j < m; j++) {\n//                if (matrix.get(i).get(j) == 1) count++;\n//            }\n//            if (count > maxCount) {\n//                maxCount = count;\n//                maxRow = i;\n//            }\n//        }\n//        return maxRow;\n\n//        Optimal solution\n        int lastIdx = m - 1;\n        int maxRow = -1;\n        for (int i = 0; i < n; i++) {\n            if (lastIdx < 0) break;\n            if (matrix.get(i).get(lastIdx) == 1) {\n                while (lastIdx >= 0 && matrix.get(i).get(lastIdx) == 1) {\n                    lastIdx--;\n                }\n                maxRow = i;\n            }\n        }\n        return maxRow;\n    }\n\n    public static void main(String[] args) {\n        int[][] values = {\n                {0, 0, 1},\n                {0, 0, 1},\n                {0, 1, 1}\n        };\n\n        // Create a 2D ArrayList and populate it with values from the array\n        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();\n        for (int[] row : values) {\n            ArrayList<Integer> arrayListRow = new ArrayList<>();\n            for (int num : row) {\n                arrayListRow.add(num);\n            }\n            matrix.add(arrayListRow);\n        }\n        int ans = maximumOnesRow(matrix, 3,3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: 'd3a2c650-66b5-4cd6-8074-8d72fef0aa0f',
                  isFolder: false,
                  name: 'MatrixMedian.java',
                  code: 'public class MatrixMedian {\n    public static int getCount(int[] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static int findMedian(int[][] M, int m, int n) {\n        // Write your code here\n        int start = 1;\n        int end = 1000000000;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i = 0; i < M.length; i++) {\n                count += getCount(M[i], mid);\n            }\n            if (count <= (n*m)/2) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int row = 3, col = 3;\n        int[][] arr = {{1, 3, 8},\n                {2, 3, 4},\n                {1, 2, 5}};\n        System.out.println("The median of the row-wise sorted matrix is: "+ findMedian(arr, row, col));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '835b6eca-4bb9-46f5-83d0-6fd0e985ede9',
                  isFolder: false,
                  name: 'Search2DMatrixRowsSorted.java',
                  code: 'import java.util.ArrayList;\n\npublic class Search2DMatrixRowsSorted {\n    //    A Row-wise sorted matrix where the first element of each row is\n//    greater than the last element of previous row\n    static boolean searchMatrix(ArrayList<ArrayList<Integer>> mat, int target) {\n        // Optimised\n        int n = mat.size();\n        int m = mat.get(0).size();\n        int start = 0, end = n*m - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int element = mat.get(mid/m).get(mid%m);\n            if (element == target) return true;\n            if (element > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        int[][] values = {\n                {1, 2, 4},\n                {6, 7, 8},\n                {9, 10, 34}\n        };\n\n        // Create a 2D ArrayList and populate it with values from the array\n        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();\n        for (int[] row : values) {\n            ArrayList<Integer> arrayListRow = new ArrayList<>();\n            for (int num : row) {\n                arrayListRow.add(num);\n            }\n            matrix.add(arrayListRow);\n        }\n        boolean ans = searchMatrix(matrix, 78);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: 'ade460f6-b99b-4e82-bd1c-18ae1b7412a4',
                  isFolder: false,
                  name: 'SearchRowColSortedMatrix.java',
                  code: 'import java.util.ArrayList;\n\npublic class SearchRowColSortedMatrix {\n    public static int bS(int[] arr, int target) {\n        int start = 0, end = arr.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target) end = mid - 1;\n            else start = mid + 1;\n        }\n        return -1;\n    }\n    public static boolean searchElement(int [][]mat, int target) {\n//        Better solution\n//        int n = mat.length;\n//        int m = mat[0].length;\n//        // Write your code here.\n//        for (int i = 0; i < n; i++) {\n//            if (mat[i][m-1] >= target) {\n//                int result = bS(mat[i], target);\n//                if (result != -1) return true;\n//                break;\n//            }\n//        }\n//        return false;\n        int j = mat[0].length - 1;\n        int i = 0;\n        while (i < mat.length && j >= 0) {\n            System.out.println(mat[i][j]);\n            if (mat[i][j] == target) return true;\n            if (mat[i][j] < target) i++;\n            else if (mat[i][j] > target) j--;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[][] matrix = {\n                {1, 2, 4},\n                {6, 7, 8},\n                {9, 10, 34}\n        };\n        boolean ans = searchElement(matrix, 11);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: 'a522ef29-b394-486f-b8eb-7b1238378250',
                  isFolder: false,
                  name: 'AggressiveCows.java',
                  code: 'import java.util.Arrays;\npublic class AggressiveCows {\n    public static boolean isPossible(int[] stalls, int k, int minDiff) {\n        int totalCows = 1;\n        int last = stalls[0];\n        for (int i = 1; i < stalls.length; i++) {\n            if (stalls[i] - last >= minDiff) {\n                totalCows++;\n                last = stalls[i];\n            }\n            if (totalCows >= k) return true;\n        }\n        return false;\n    }\n    public static int aggressiveCows(int []stalls, int k) {\n        int n = stalls.length;\n        Arrays.sort(stalls);\n//        Brute force\n//        int maxDifference = stalls[n-1] - stalls[0];\n//        for (int i = 1; i <= maxDifference; i++) {\n//            if (!isPossible(stalls, k, i)) return i-1;\n//        }\n//        return maxDifference;\n\n//        Optimised approach\n        int start = 1, end = stalls[n-1] - stalls[0];\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(stalls, k, mid)) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return end;\n    }\n    public static void main(String[] args) {\n        int[] stalls = {4,2,1,3,6};\n        int k = 2;\n        int ans = aggressiveCows(stalls, k);\n        System.out.println("The maximum possible minimum distance is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '61afa449-b04c-4d8f-888a-f690d42bb3ac',
                  isFolder: false,
                  name: 'BookAllocation.java',
                  code: 'import java.util.*;\npublic class BookAllocation {\n    public static boolean isPossible(ArrayList<Integer> arr, int j, int m) {\n        int students = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr.get(i) <= j) {\n                sum += arr.get(i);\n            } else {\n                sum = arr.get(i);\n                students++;\n            }\n        }\n        return students <= m;\n    }\n    public static int findPages(ArrayList<Integer> arr, int n, int m) {\n//        Brute force\n//        if (m > n) return -1;\n//        int min = arr.get(0);\n//        int max = arr.get(0);\n//        for (int i = 1; i < n; i++) {\n//            min = Math.max(min, arr.get(i));\n//            max += arr.get(i);\n//        }\n//        for (int j = min; j <= max; j++) {\n//            if (isPossible(arr, j, m)) return j;\n//        }\n//        return -1;\n\n//        Optimized\n        if (m > n) return -1;\n        int start = arr.get(0);\n        int end = arr.get(0);\n        for (int i = 1; i < n; i++) {\n            start = Math.max(start, arr.get(i));\n            end += arr.get(i);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, mid, m))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(25, 46, 28, 49, 24));\n        int n = 5;\n        int m = 4;\n        int ans = findPages(arr, n, m);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '3704e9a9-3e4d-488c-a946-85a3f776bd01',
                  isFolder: false,
                  name: 'CapacityToShipPackages.java',
                  code: 'public class CapacityToShipPackages {\n    public static boolean isPossible(int[] arr, int d, int capaciity) {\n        int total = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] <= capaciity) {\n                sum += arr[i];\n            } else {\n                total++;\n                sum = arr[i];\n            }\n        }\n        return total <= d;\n    }\n\n    public static int leastWeightCapacity(int[] arr, int d) {\n        // Write your code here.\n//        Brute force\n//        int max = arr[0];\n//        int min = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            max += arr[i];\n//            min = Math.max(arr[i], min);\n//        }\n//        for (int i = min; i <= max; i++) {\n//            if (isPossible(arr, d, i)) return i;\n//        }\n//        return -1;\n\n//        Optimised approach\n        int start = arr[0], end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end += arr[i];\n            start = Math.max(arr[i], start);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, d, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 4, 5, 2, 3, 4, 5, 6};\n        int ans = leastWeightCapacity(arr, 5);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'f783c79f-5726-4fc3-90b7-87866cc4f72b',
                  isFolder: false,
                  name: 'FindSmallestDivisor.java',
                  code: 'public class FindSmallestDivisor {\n    public static boolean isPossible(int[] arr, int limit, int divisor) {\n        int total = 0;\n        for (int i = 0; i < arr.length; i++) {\n            total += (arr[i] + divisor - 1) / divisor;\n        }\n        return total <= limit;\n    }\n    public static int smallestDivisor(int[] arr, int limit) {\n        // Write your coder here\n//        Brute force\n//        int maxi = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            maxi = Math.max(maxi, arr[i]);\n//        }\n//        for (int ans = 1; ans <= maxi; ans++) {\n//            if (isPossible(arr, limit, ans)) return ans;\n//        }\n//        return -1;\n\n//        Optimal approach\n        int start = 1;\n        int end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end = Math.max(end, arr[i]);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, limit, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int ans = smallestDivisor(arr, 8);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '99589c15-4909-4403-84d2-ee7f734aa47f',
                  isFolder: false,
                  name: 'KokoEatingBananas.java',
                  code: 'public class KokoEatingBananas {\n    public static boolean isPossible(int[] v, int h, int rate) {\n        int hourCount = 0;\n        for (int i = 0; i < v.length; i++) {\n            hourCount += (v[i] + rate - 1)/rate;\n            if (hourCount > h) return false;\n        }\n        return hourCount <= h;\n    }\n    public static int minimumRateToEatBananas(int []v, int h) {\n        // Write Your Code Here\n//        Brute force\n//        int max = v[0];\n//        for (int i: v) {\n//            max = Math.max(max, i);\n//        }\n//        for (int ans = 1; ans <= max; ans++) {\n//            if (isPossible(v, h, ans)) return ans;\n//        }\n//        return -1;\n\n//        Best approach: Binary search\n        int start = 1;\n        int end = v[0];\n        for (int i = 1; i < v.length; i++) {\n            end = Math.max(end, v[i]);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(v, h, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] v = {7, 15, 6, 3};\n        int h = 8;\n        int ans = minimumRateToEatBananas(v,h);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '599c1547-f46b-4c06-b625-1e48fbf069a2',
                  isFolder: false,
                  name: 'KthElementOf2SortedArrays.java',
                  code: 'import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class KthElementOf2SortedArrays {\n    public static int kthElement(ArrayList<Integer> a, ArrayList<Integer> b, int n, int m, int k) {\n//        Brute force solution\n//        int[] temp = new int[n + m];\n//        int left = 0, right = 0, i = 0;\n//        while (left < n && right < m) {\n//            if (a.get(left) <= b.get(right))\n//                temp[i++] = a.get(left++);\n//            else\n//                temp[i++] = b.get(right++);\n//        }\n//        while (left < n) temp[i++] = a.get(left++);\n//        while (right < m) temp[i++] = b.get(right++);\n//        return temp[k-1];\n\n//        Better solution\n//        int left = 0, right = 0, i = 0;\n//        while (left < n && right < m) {\n//            if (a.get(left) <= b.get(right)) {\n//                if (i == k - 1) return a.get(left);\n//                left++;\n//            } else {\n//                if (i == k - 1) return b.get(right);\n//                right++;\n//            }\n//            i++;\n//        }\n//        while (left < n) {\n//            if (i == k - 1) return a.get(left);\n//            left++;\n//            i++;\n//        }\n//        while (right < m) {\n//            if (i == k - 1) return b.get(right);\n//            right++;\n//            i++;\n//        }\n//        return Math.max(a.get(n-1), b.get(m-1));\n\n//        Optimal approach\n        if (n > m) return kthElement(b, a, m, n, k);\n        int start = Math.max(0, k-m), end = Math.min(k,n);\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int mid2 = k - mid;\n            int l1 = mid > 0 ? a.get(mid - 1) : Integer.MIN_VALUE;\n            int l2 = mid2 > 0 ? b.get(mid2 - 1) : Integer.MIN_VALUE;\n            int r1 = mid < n? a.get(mid) : Integer.MAX_VALUE;\n            int r2 = mid2 < m? b.get(mid2) : Integer.MAX_VALUE;\n            if (l1 <= r2 && l2 <= r1) return Math.max(l1, l2);\n            if (l1 > r2) end = mid - 1;\n            else start = mid + 1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr1 = new ArrayList<>(Arrays.asList(2, 3, 6, 7, 9));\n        ArrayList<Integer> arr2 = new ArrayList<>(Arrays.asList(1, 4, 8, 10));\n        int m = arr1.size();\n        int n = arr2.size();\n        int k = 5;\n        System.out.println("The element at the kth position in the final sorted array is " + kthElement(arr1, arr2, m, n, k));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '2be14eb9-2f9a-4f4d-ae6b-aa57b8e4b3f2',
                  isFolder: false,
                  name: 'KthMissingPositiveNumber.java',
                  code: 'public class KthMissingPositiveNumber {\n    public static int missingK(int[] arr, int n, int k) {\n//        Brute force solution\n//        for (int i = 0; i < n; i++) {\n//            if (arr[i] > k) break;\n//            k++;\n//        }\n//        return k;\n\n//        Optimised approach\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int missing = arr[mid] - (mid + 1);\n            if (missing < k) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start + k;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 4, 5, 7};\n        int ans = missingK(arr, arr.length, 3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'd71407bb-4226-4e2c-b300-1a8d1997dd02',
                  isFolder: false,
                  name: 'MedianOfTwoSortedArrays.java',
                  code: 'public class MedianOfTwoSortedArrays {\n    public static double median(int[] a, int[] b) {\n//        Brute force solution\n//        Use another array ans add all elements in sorted order, then calculate median\n//        int n1 = a.length;\n//        int n2 = b.length;\n//        int[] temp = new int[n1 + n2];\n//        int left = 0, right = 0, i = 0;\n//        while (left < n1 && right < n2) {\n//            if (a[left] <= b[right]) {\n//                temp[i++] = a[left++];\n//            } else {\n//                temp[i++] = b[right++];\n//            }\n//        }\n//        while (left < n1) {\n//            temp[i++] = a[left++];\n//        }\n//        while (right < n2) {\n//            temp[i++] = b[right++];\n//        }\n////        returning median\n//        int m1 = temp.length / 2;\n//        if (temp.length % 2 == 0) {\n//            int m2 = m1 - 1;\n//            return (temp[m1] + temp[m2]) / 2.0;\n//        }\n//        return temp[m1];\n\n//        Better solution\n//        We don\'t need to store all the elements just medians elements are needed to calculate median\n//        int n1 = a.length, n2 = b.length;\n//        int left = 0, right = 0, i = 0;\n//        int m1 = (n1 + n2) / 2;\n//        int mid1 = -1,  mid2 = -1;\n//        while (left < n1 && right < n2) {\n//            if (a[left] <= b[right]) {\n//                if (i == m1 - 1) mid1 = a[left];\n//                else if (i == m1) mid2 = a[left];\n//                left++;\n//            } else {\n//                if (i == m1 - 1) mid1 = b[right];\n//                else if (i == m1) mid2 = b[right];\n//                right++;\n//            }\n//            i++;\n//        }\n//        while (left < n1) {\n//            if (i == m1 - 1) mid1 = a[left];\n//            else if (i == m1) mid2 = a[left];\n//            i++;\n//            left++;\n//        }\n//        while (right < n2) {\n//            if (i == m1 - 1) mid1 = b[right];\n//            else if (i == m1) mid2 = b[right];\n//            i++;\n//            right++;\n//        }\n//        if ((n1 + n2) % 2 == 1) return mid2;\n//        return (double)(mid1 + mid2) / 2.0;\n\n//        Optimal solution\n//        Use binary search to get the mid value of the merged array (without merging)\n        int n1 = a.length, n2 = b.length;\n        if (n1 > n2) return median(b, a);\n        int n = n1 + n2;\n        int minElements = (n + 1) / 2;\n        int start = 0, end = n1;\n        while (start <= end) {\n            int mid1 = start + (end - start) / 2;\n            int mid2 = minElements - mid1;\n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE;\n            int r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\n            if (mid1 > 0) l1 = a[mid1 - 1];\n            if (mid2 > 0) l2 = b[mid2 - 1];\n            if (mid1 < n1) r1 = a[mid1];\n            if (mid2 < n2) r2 = b[mid2];\n            if (l1 <= r2 && l2 <= r1) {\n                double median = Math.max(l1, l2);\n                if (n % 2 == 0) {\n                    median += Math.min(r1, r2);\n                    return median / 2.0;\n                }\n                return median;\n            }\n            if (l1 > r2) end = mid1 - 1;\n            else start = mid1 + 1;\n        }\n        return 0.0;\n    }\n\n    public static void main(String[] args) {\n        int[] a = {2, 4, 6};\n        int[] b = {1, 3};\n        System.out.println("The median of two sorted arrays is " + median(a, b));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '1880fd20-8804-45dc-a1bc-a2ff9b9caf87',
                  isFolder: false,
                  name: 'MinimiseMaximumDistanceBetweenGasStations.java',
                  code: 'import java.util.*;\n\npublic class MinimiseMaximumDistanceBetweenGasStations {\n    public static double minimiseMaxDistance(int []arr, int k){\n//        Brute force\n//        1. Make a sections array to store the count of added gas stations in each section\n//        int[] sections = new int[arr.length - 1];\n//        for (int i = 0; i < k; i++) {\n//            double maxVal = -1;\n//            int maxIdx = -1;\n//            for (int j = 0; j < sections.length; j++) {\n//                double distance = arr[j+1] - arr[j];\n//                double sectionLength = distance/(sections[j]+1);\n//                if (sectionLength > maxVal) {\n//                    maxVal = sectionLength;\n//                    maxIdx = j;\n//                }\n//            }\n//            sections[maxIdx]++;\n//        }\n//        2. Iterate sections to get the maxLength of the difference\n//        double maxLength = 0;\n//        for (int i  = 0; i < sections.length; i++) {\n//            double distance = arr[i+1] - arr[i];\n//            double len = distance / (sections[i]+ 1);\n//            maxLength = Math.max(maxLength, len);\n//        }\n//        return maxLength;\n\n//        Optimised approach - Priority queue\n//        Add all sections current length to the pq\n//        Iterate on range k and update the highest element pair in pq\n//        return the pq.peek();\n        PriorityQueue<Map.Entry<Double, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByKey(Collections.reverseOrder()));\n        for (int i = 0; i < arr.length - 1; i++) {\n            pq.add(new AbstractMap.SimpleEntry<>((double) arr[i+1] - arr[i], i));\n        }\n        int[] sections = new int[arr.length - 1];\n        for (int j = 0; j < k; j++) {\n            int idx = pq.remove().getValue();\n            sections[idx]++;\n            double distance = arr[idx+1] - arr[idx];\n            double sectionLength = distance / (sections[idx] + 1);\n            pq.add(new AbstractMap.SimpleEntry<>(sectionLength, idx));\n        }\n        return pq.remove().getKey();\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int k = 4;\n        double ans = minimiseMaxDistance(arr, k);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '61f8bc32-c690-49be-a11b-7ed3b91614bf',
                  isFolder: false,
                  name: 'NthRoot.java',
                  code: 'public class NthRoot {\n    public static int getNthPower(int num, int pow, int m) {\n        long ans = 1;\n        for (int i = 0; i < pow; i++) {\n            ans *= num;\n            if (ans > m) return 1;\n        }\n        if (ans == m) return 0;\n        return -1;\n    }\n    public static int getNthRoot(int n, int m) {\n//        for (int i = 1; i < m; i++) {\n//            int x = getNthPower(i, n);\n//            if (x == m) return i;\n//        }\n//        return -1;\n\n        int start = 0;\n        int end = m;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int res = getNthPower(mid, n, m);\n            if (res == 0) return mid;\n            if (res == 1) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        int n = 9;\n        int m = 262144;\n        int ans = getNthRoot(n,m);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '4eba1559-f427-4fee-950d-daeba39cc5d4',
                  isFolder: false,
                  name: 'PaintersPartition.java',
                  code: 'import java.util.ArrayList;\n\npublic class PaintersPartition {\n    public static boolean isPossible(ArrayList<Integer> arr, int k, int maxArea) {\n        int sum = 0;\n        int totalPainters = 1;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr.get(i) <= maxArea) {\n                sum += arr.get(i);\n            } else {\n                sum = arr.get(i);\n                totalPainters++;\n            }\n        }\n        return totalPainters <= k;\n    }\n    public static int findLargestMinDistance(ArrayList<Integer> arr, int k) {\n        int min = arr.get(0);\n        int max = arr.get(0);\n        for (int i = 1; i < arr.size(); i++) {\n            min = Math.max(min, arr.get(i));\n            max += arr.get(i);\n        }\n\n//        Brute force\n//        for (int i = min; i <= max; i++) {\n//            if (isPossible(arr, k, i)) return i;\n//        }\n//        return -1;\n\n//        Optimised solution\n        int start = min, end = max;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, k, mid))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n\n    }\n    public static void main(String[] args) {\n\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'a61c6c9b-4c1d-432c-8bc3-d30ebbbfaaa0',
                  isFolder: false,
                  name: 'RoseGarden.java',
                  code: 'public class RoseGarden {\n    public static boolean isPossible(int[] arr, int r, int b, int d) {\n        int totalBouquets = 0;\n        int rCount = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] <= d) {\n                rCount++;\n            } else {\n                totalBouquets += rCount / r;\n                rCount = 0;\n            }\n        }\n        totalBouquets += rCount / r;\n        return totalBouquets >= b;\n    }\n\n    public static int roseGarden(int[] arr, int r, int b) {\n//        Brute force\n//        int max = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            max = Math.max(max, arr[i]);\n//        }\n//        for (int ans = 1; ans <= max; ans++) {\n//            if (isPossible(arr, r, b, ans)) return ans;\n//        }\n//        return -1;\n\n//        Optimised approach\n        if (b*r > arr.length) return -1;\n        int start = arr[0];\n        int end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end = Math.max(arr[i], end);\n            start = Math.min(arr[i], start);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, r, b, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 6, 8, 13, 17, 6, 16};\n        int ans = roseGarden(arr, 2, 2);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '9399e79a-4f85-40ea-9234-aed0321bfac9',
                  isFolder: false,
                  name: 'SplitArrayLargestSum.java',
                  code: 'public class SplitArrayLargestSum {\n\n    public static boolean isPossible(int[] arr, int limit, int splits) {\n        int totalSplits = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] <= limit) {\n                sum += arr[i];\n            } else {\n                sum = arr[i];\n                totalSplits++;\n            }\n            if (totalSplits > splits) return false;\n        }\n        return true;\n    }\n\n    public static int largestSubarraySumMinimized(int []arr, int k) {\n        // Write Your Code Here\n//        Brute same as book allocation problem\n        int n = arr.length;\n        if (k > n) return -1;\n        int start = arr[0];\n        int end = arr[0];\n        for (int i = 1; i < n; i++) {\n            start = Math.max(start, arr[i]);\n            end += arr[i];\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, mid, k))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] a = {10, 20, 30, 40};\n        int k = 2;\n        int ans = largestSubarraySumMinimized(a, k);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '498c4dd6-9c64-48dc-a9bf-37279467988f',
                  isFolder: false,
                  name: 'SquareRoot.java',
                  code: 'public class SquareRoot {\n    public static int getSQRT(int x) {\n//        Brute force\n//        int ans = 1;\n//        for (int i = 1; i <= x; i++) {\n//            if (i*i <= x) {\n//                ans = i;\n//            } else {\n//                break;\n//            }\n//        }\n//        return ans;\n\n//        Optimised approach\n        int start = 1;\n        int end = x;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int root = x/mid;\n            if (mid == root) {\n                return mid;\n            }\n            if (mid > root) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return end;\n    }\n    public static void main(String[] args) {\n        int num = 21;\n        int ans = getSQRT(num);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
              ],
            },
            {
              id: 'e878ed31-dcd6-4cfb-93cd-e396e789226a',
              isFolder: false,
              name: 'AdvancedMaths.java',
              code: 'import java.util.*;\n\npublic class AdvancedMaths {\n    public static List< Integer > countPrimes(int n) {\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        boolean[] check = new boolean[n+1];\n        check[0] = true;\n        check[1] = true;\n        for (int i = 2; i <= n; i++) {\n            if (!check[i]) {\n                if (n%i == 0) {\n                    ans.add(i);\n                }\n                for (int j = i*2; j <= n; j += i) {\n                    check[j] = true;\n                }\n            }\n        }\n        return ans;\n    }\n\n//    https://www.codingninjas.com/studio/problems/power-of-numbers_8157729\n    public static long fastExponentiation(int n, int p) {\n        if (p == 0) return 1;\n        else if (p == 1) return n;\n        else {\n            long R = fastExponentiation(n, p/2)%(long)(10e9+7);\n            if (p%2 == 0) return (R*R)%1000000007;\n            else return (((R*n)%1000000007)*R)%1000000007;\n        }\n    }\n    public static int power(int N, int R){\n        // Write your code here.\n        int ans = (int) fastExponentiation(N, R);\n        return ans;\n    }\n\n//    https://www.codingninjas.com/studio/problems/subsequences-of-string_985087\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences("hq");\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '42e16eaf-cd84-4eae-8bc1-2def19b30660',
              isFolder: false,
              name: 'InterviewProblems.java',
              code: 'public class InterviewProblems {\n    public static int getCount(int n) {\n        return LearnBitManipulationQuestions.getCount(n);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/flip-bits_8160405\n    public static int flipBits(int A, int B) {\n        // Write your code here.\n        int Xor = A ^ B;\n        return getCount(Xor);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/one-odd-occurring_4606074\n    public static int missingNumber(int n, int[] arr) {\n        // Write your code here.\n        int ans = 0;\n        for (int num : arr) {\n            ans ^= num;\n        }\n        return ans;\n    }\n\n    //    https://www.codingninjas.com/studio/problems/l-to-r-xor_8160412\n    public static int getXOR(int n) {\n        if (n % 4 == 0) return n;\n        if (n % 4 == 1) return 1;\n        if (n % 4 == 2) return n + 1;\n        return 0;\n    }\n\n    public static int findXOR(int L, int R) {\n        // Write your code here.\n        int lXor = getXOR(L - 1);\n        int rXor = getXOR(R);\n        return lXor ^ rXor;\n    }\n\n    public static int[] twoOddNum(int []arr){\n        int xor = 0;\n        for (int j : arr) {\n            xor ^= j;\n        }\n        int pos = 0;\n        while ((xor & 1) == 0) {\n            pos++;\n            xor >>= 1;\n        }\n        int xor1 = 0, xor2 = 0;\n        for (int num : arr) {\n            if (((num >> pos) & 1) == 1) xor1 ^= num;\n            else xor2 ^= num;\n        }\n        return new int[]{Math.max(xor1, xor2), Math.min(xor1, xor2)};\n    }\n\n    public static void main(String[] args) {\n\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '82a27874-e98d-4649-9ddd-61260f81f4d1',
              isFolder: false,
              name: 'LearnBitManipulationQuestions.java',
              code: 'public class LearnBitManipulationQuestions {\n    public static int[] bitManipulation(int num, int i) {\n        int[] ans = new int[3];\n        int mask = 1 << (i - 1);\n        // 1. get ith bit\n        ans[0] = (num & mask) != 0 ? 1 : 0;\n        // 2. set ith bit\n        num = num | mask;\n        ans[1] = num;\n        // 3. clear ith bit\n        ans[2] = num & ~mask;\n        return ans;\n    }\n\n    public static boolean isKthBitSet(int n, int k) {\n        int mask = 1 << (k - 1);\n        return (n & mask) != 0;\n    }\n\n    public static String oddEven(int N) {\n        // Write your code here.\n        return (N & 1) == 0 ? "even" : "odd";\n    }\n\n    public static boolean isPowerOfTwo(int n) {\n        // Write your code here.\n        return (n & (n - 1)) == 0;\n    }\n\n    //    Count set bits in range 1 - N\n    public static int getCount(int n) {\n        int count = 0;\n        while (n != 0) {\n            n = (n & (n - 1));\n            count++;\n        }\n        return count;\n    }\n\n    public static int countSetBits(int n) {\n        //Write your code here\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            count += getCount(i);\n        }\n        return count;\n    }\n\n    //    https://www.codingninjas.com/studio/problems/set-the-rightmost-unset-bit_8160456\n    public static int setBits(int N) {\n        // Write your code here\n        int n = N;\n        if ((n & (n + 1)) == 0) return N;\n        int idx = 0;\n        while (n > 0) {\n            if ((n & 1) == 0) break;\n            idx++;\n            n >>= 1;\n        }\n        return N | (1 << idx);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/swap-two-numbers_1380853\n    public static void swapNumber(int[] a, int[] b) {\n        // Write your code here.\n        a[0] = a[0] ^ b[0];\n        b[0] = a[0] ^ b[0];\n        a[0] = a[0] ^ b[0];\n    }\n\n//    https://www.codingninjas.com/studio/problems/flip-bits_8160405\n    public static int flipBits(int A, int B){\n        // Write your code here.\n        int Xor = A^B;\n        return getCount(Xor);\n    }\n\n//    https://www.codingninjas.com/studio/problems/one-odd-occurring_4606074\n    public static int missingNumber(int n, int []arr){\n        // Write your code here.\n        int ans = 0;\n        for (int num : arr) {\n            ans ^= num;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n//        int n = 11;\n//        int i = 2;\n//        int[] ans = bitManipulation(n, i);\n//        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: 'a9068598-155d-4c5f-9ab7-804bfeedf774',
              isFolder: false,
              name: 'SieveOfEratosthenes.java',
              code: 'import java.util.*;\npublic class SieveOfEratosthenes {\n    static List<Integer> getPrime(int n) {\n        List<Integer> ans = new ArrayList<>();\n        boolean[] check = new boolean[n+1];\n        check[0] = true;\n        check[1] = true;\n        for (int i = 2; i <= n; i++) {\n            if (!check[i]) {\n                ans.add(i);\n                for (int j = i*2; j <= n; j += i)\n                    check[j] = true;\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int n = 10;\n        System.out.println(getPrime(n));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: 'dadadfe6-63c8-4091-8695-956c4287d4c8',
              isFolder: true,
              name: 'LinkedList',
              content: [
                {
                  id: '94de6f6e-e822-45fa-9a0a-8d0eafe96516',
                  isFolder: false,
                  name: 'CopyListWithRandomPointer.java',
                  code: 'public class CopyListWithRandomPointer {\n    class Node {\n        int val;\n        Node next;\n        Node random;\n        public Node(int val) {\n            this.val = val;\n            this.next = null;\n            this.random = null;\n        }\n    }\n    public Node copyRandomList(Node head) {\n        // Optimised solution\n        if (head == null) return null;\n        // Step 1: Create a new linked list in between the nodes of current LL\n        Node curr = head;\n        while (curr != null) {\n            Node newNode = new Node(curr.val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            curr = newNode.next;\n        }\n        // Step 2: Assign random pointers to the deep copy\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n        // Step 3: Separate both the linked list and return Head\n        Node copy = head.next;\n        Node temp = copy;\n        curr = head;\n        while (temp != null) {\n            curr.next = temp.next;\n            curr = curr.next;\n            if (curr == null) break;\n            temp.next = curr.next;\n            temp = temp.next;\n        }\n        // curr.next = null;\n        return copy;\n    }\n}',
                  link: 'https://leetcode.com/problems/copy-list-with-random-pointer',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '7f709a57-cd9e-4ea9-a0ae-c9c8eae6b023',
                  isFolder: false,
                  name: 'FlattenLL.java',
                  code: 'public class FlattenLL {\n    public class Node {\n        public int data;\n        public Node next;\n        public Node child;\n\n        Node()\n        {\n            this.data = 0;\n            this.next = null;\n            this.child = null;\n        }\n        Node(int data)\n        {\n            this.data = data;\n            this.next = null;\n            this.child = null;\n        }\n        Node(int data, Node next, Node child)\n        {\n            this.data = data;\n            this.next = next;\n            this.child = child;\n        }\n    }\n\n    public static Node merge(Node left, Node right) {\n        Node temp = new Node(0);\n        Node tHead = temp;\n        while (left != null && right != null) {\n            if (left.data <= right.data) {\n                temp.child = left;\n                left = left.child;\n            } else {\n                temp.child = right;\n                right = right.child;\n            }\n            temp = temp.child;\n        }\n        if (left != null)\n            temp.child = left;\n        else\n            temp.child = right;\n        return tHead.child;\n    }\n    public static Node flatList(Node head) {\n        if (head == null || head.next == null) return head;\n        head.next = flatList(head.next);\n        head = merge(head, head.next);\n        return head;\n    }\n    public static Node flattenLinkedList(Node head) {\n        //Write your code here\n        return flatList(head);\n    }\n\n}',
                  link: 'https://www.codingninjas.com/studio/problems/flatten-a-linked-list_1112655',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '54cafdbb-470f-4c4c-bd01-c17024bceef8',
                  isFolder: false,
                  name: 'ReverseNodesInKGroups.java',
                  code: 'public class ReverseNodesInKGroups {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = head;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head, start = head, prev = head;\n        ListNode newHead = new ListNode(0, head);\n        ListNode temp = newHead;\n\n        while (curr != null) {\n            for (int i = 1; i <= k; i++) {\n                if (curr.next == null && i < k) return newHead.next;\n                prev = curr;\n                curr = curr.next;\n            }\n            prev.next = null;\n            temp.next = revLL(start);\n            start.next = curr;\n            temp = start;\n            start = curr;\n        }\n        return newHead.next;\n    }\n}',
                  link: 'https://leetcode.com/problems/reverse-nodes-in-k-group/',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '2ed3db7f-2ff3-4c98-a441-2bb92f643a23',
                  isFolder: false,
                  name: 'RotateList.java',
                  code: 'public class RotateList {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        int length = 1;\n        ListNode end = head;\n        while (end.next != null) {\n            length++;\n            end = end.next;\n        }\n        k = k%length;\n        if (k == 0) return head;\n        ListNode prev = null;\n        ListNode start = head;\n        for (int i = 0; i <length - k; i++) {\n            prev = start;\n            start = start.next;\n        }\n        prev.next = null;\n        end.next = head;\n        head = start;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/rotate-list/',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '59f936e5-2650-4a9e-b069-8e8e14d61f9c',
                  isFolder: false,
                  name: 'AddOneToNumberLL.java',
                  code: 'public class AddOneToNumberLL {\n    public static Node revLL(Node head) {\n\t\tNode prev = null;\n\t\tNode curr = head, next = head;\n\t\twhile (curr != null) {\n\t\t\tnext = curr.next;\n\t\t\tcurr.next = prev;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\treturn prev;\n\t}\n\n\tpublic static Node addNode(Node head) {\n\t\t// Write your code here.\n\t\thead = revLL(head);\n\t\tNode curr = head;\n\t\tint carry = 1;\n\t\twhile (curr.next != null) {\n\t\t\tcarry = curr.data + carry;\n\t\t\tcurr.data = carry % 10;\n\t\t\tcarry = carry / 10;\n\t\t\tif (carry == 0) break;\n\t\t\tcurr = curr.next;\n\t\t}\n\t\tif (carry != 0) {\n\t\t\tcurr.next = new Node(carry);\n\t\t}\n\t\thead = revLL(head);\n\t\treturn head;\n\t}\n}',
                  link: 'https://www.codingninjas.com/studio/problems/add-one-to-a-number-represented-as-linked-list_920557',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '8cf80464-f20d-4e24-b84d-e5fda2b398b3',
                  isFolder: false,
                  name: 'AddTwoNumbersLL.java',
                  code: 'public class AddTwoNumbersLL {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode sum = new ListNode(0);\n        ListNode sumHead = sum;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int d1 = l1 != null ? l1.val : 0;\n            int d2 = l2 != null ? l2.val : 0;\n            carry += d1 + d2;\n            sum.next = new ListNode(carry%10);\n            sum = sum.next;\n            carry /= 10;\n            l1 = l1 != null ? l1.next : null;\n            l2 = l2 != null ? l2.next : null;\n        }\n        return sumHead.next;\n    }\n}',
                  link: 'https://leetcode.com/problems/add-two-numbers/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '3d037548-bfc9-4129-b204-27239c1b584f',
                  isFolder: false,
                  name: 'DeleteMiddleNode.java',
                  code: 'public class DeleteMiddleNode {\n    public ListNode deleteMiddle(ListNode head) {\n        if (head.next == null) return null;\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = slow.next;\n        slow.next = null;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '622e3415-94ba-4a98-b681-769a1956d429',
                  isFolder: false,
                  name: 'IntersectionOfTwoLinkedLists.java',
                  code: 'public class IntersectionOfTwoLinkedLists {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode d1 = headA;\n        ListNode d2 = headB;\n        while (d1 != d2) {\n            d1 = d1 == null ? headB : d1.next;\n            d2 = d2 == null ? headA : d2.next;\n        }\n        return d1;\n    }\n}',
                  link: 'https://leetcode.com/problems/intersection-of-two-linked-lists/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '14d95854-eb56-4f24-bea4-c398fe167629',
                  isFolder: false,
                  name: 'LengthOfLoopInLL.java',
                  code: 'public class LengthOfLoopInLL {\n\n    public static int lengthOfLoop(Node head) {\n        // Write your code here\n        if (head == null || head.next == null) {\n            return 0;\n        }\n        int len = 1;\n        Node s = head, f = head, s2 = head;\n        while (f != null && f.next != null) {\n            s = s.next;\n            f = f.next.next;\n            if (f == s) {\n                while (s != s2) {\n                    s = s.next;\n                    s2 = s2.next;\n                }\n                s = s.next;\n                while (s != s2) {\n                    s = s.next;\n                    len++;\n                }\n            }\n        }\n        return len;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-length-of-loop_8160455',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'd6a362d9-24d6-4db0-8b6e-18ab512d9f5a',
                  isFolder: false,
                  name: 'OddEvenLinkedList.java',
                  code: 'public class OddEvenLinkedList {\n    public static ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenhead = even;\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        odd.next = evenhead;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/odd-even-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'ea11b2b5-cff1-435e-809a-165107f7ebc0',
                  isFolder: false,
                  name: 'PalindromeLinkedList.java',
                  code: '// Definition for singly-linked list.\nclass PalindromeLinkedList {\n    public static ListNode revLL(ListNode head) {\n        ListNode curr = head, prev = null, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n        ListNode slow = head, curr = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        slow = revLL(slow);\n        while (slow != null) {\n            if (slow.val != curr.val) return false;\n            slow = slow.next;\n            curr = curr.next;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println("Hello");\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '78756b13-b9b5-459d-aad0-06a965a3326c',
                  isFolder: false,
                  name: 'RemoveNthNodeFromLastOfLL.java',
                  code: 'public class RemoveNthNodeFromLastOfLL {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode curr = head;\n        int l = 1;\n        while (curr.next != null) {\n            curr = curr.next;\n            l++;\n        }\n        int len = l - n;\n        if (len == 0) {\n            head = head.next;\n        } else {\n            curr = head;\n            while (len != 1) {\n                len--;\n                curr = curr.next;\n            }\n            curr.next = curr.next.next;\n        }\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '5ab758bb-b75d-461d-8605-272a575dd794',
                  isFolder: false,
                  name: 'Sort012LinkedList.java',
                  code: 'public class Sort012LinkedList {\n    public static Node sortList(Node head) {\n        // Write your code here\n        Node zeroHead = new Node(0), onesHead = new Node(0), twosHead = new Node(0);\n        Node zero = zeroHead, ones = onesHead, twos = twosHead;\n        Node curr = head;\n        while (curr != null) {\n            if (curr.data == 0) {\n                zero.next = curr;\n                zero = zero.next;\n            } else if (curr.data == 1) {\n                ones.next = curr;\n                ones = ones.next;\n            } else {\n                twos.next = curr;\n                twos = twos.next;\n            }\n            curr = curr.next;\n        }\n        twos.next = null;\n        ones.next = twosHead.next;\n        zero.next = onesHead.next;\n        return zeroHead.next;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sort-linked-list-of-0s-1s-2s_1071937',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '94ef189a-e55a-46c5-9718-bad3046ddb33',
                  isFolder: false,
                  name: 'SortLinkedList.java',
                  code: 'public class SortLinkedList {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode(0);\n        ListNode tHead = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null)\n            temp.next = left;\n        else\n            temp.next = right;\n        return tHead.next;\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode s = head, f = head.next;\n        while (f != null && f.next != null) {\n            s = s.next;\n            f = f.next.next;\n        }\n        ListNode head2 = s.next;\n        s.next = null;\n        head = mergeSort(head);\n        head2 = mergeSort(head2);\n        return merge(head, head2);\n    }\n    public ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n}',
                  link: 'https://leetcode.com/problems/sort-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '32fc8cdd-7795-4b79-8dcd-632420b6370d',
                  isFolder: false,
                  name: 'DeleteAllCommonOccurances.java',
                  code: 'public class DeleteAllCommonOccurances {\n    public static Node deleteAllOccurrences(Node head, int k) {\n        // Write your code here.\n        while (head != null && head.data == k) {\n            head = head.next;\n        }\n        if (head == null) return null;\n        Node start = head, curr = head.next;\n        while (curr != null) {\n            if (curr.data != k) {\n                start.next = curr;\n                curr.prev = start;\n                start = curr;\n            }\n            curr = curr.next;\n        }\n        start.next = null;\n        return head;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/delete-all-occurrences-of-a-given-key-in-a-doubly-linked-list_8160461',
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: 'a1d3b6a0-3371-47b0-a94f-782f67fa8b32',
                  isFolder: false,
                  name: 'PairWithGivenSum.java',
                  code: 'import java.util.*;\n\npublic class PairWithGivenSum {\n    public static List<List<Integer>> findPairs (Node head, int k) {\n        Node start = head, end = head;\n        while (end.next != null && end.data + start.data <= k) {\n            end = end.next;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n        while (start != null && end != null && start.data < end.data) {\n            int s = start.data + end.data;\n            if (s > k)\n                end = end.prev;\n            else if (s < k)\n                start = start.next;\n            else {\n                output.add(new ArrayList<>(Arrays.asList(start.data, end.data)));\n                start = start.next;\n                end = end.prev;\n            }\n        }\n        return output;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-pairs-with-given-sum-in-doubly-linked-list_1164172',
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: '0f8a2912-77d9-4aea-99a3-5575e8e77fae',
                  isFolder: false,
                  name: 'RemoveDuplicatesSortedDLL.java',
                  code: '//  Link: https://www.codingninjas.com/studio/problems/remove-duplicates-from-a-sorted-doubly-linked-list_2420283\n\npublic class RemoveDuplicatesSortedDLL {\n    public static Node uniqueSortedList(Node head) {\n        // Write your code here.\n        if (head == null || head.next == null) return head;\n        Node start = head;\n        Node curr = head.next;\n        while (curr != null) {\n            if (start.data != curr.data) {\n                start.next = curr;\n                start = start.next;\n            }\n            curr = curr.next;\n        }\n        start.next = null;\n        return head;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
              ],
            },
            {
              id: 'f768a7f7-d96d-49e0-8cf7-308fc7bcc6e6',
              isFolder: false,
              name: 'Patterns.java',
              code: '// !ignore\nimport java.util.Scanner;\n\npublic class Patterns {\n    public static void printBlockPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printTriangleNumberPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(j + 1);\n            System.out.println();\n        }\n    }\n\n    public static void printTriangleNumberPattern2(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(i + 1);\n            System.out.println();\n        }\n    }\n\n    public static void printDownTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = n; j > i; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDownTriangleNumberPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++)\n                System.out.print(j + 1 - i);\n            System.out.println();\n        }\n    }\n\n    public static void printEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i - 1; j++)\n                System.out.print(" ");\n            for (int j = 0; j < 2 * i + 1; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDownEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++)\n                System.out.print(" ");\n            for (int j = 0; j < 2 * (n - i) - 1; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDiamondPattern(int n) {\n        printEQTrianglePattern(n);\n        printDownEQTrianglePattern(n);\n    }\n\n    public static void printHalfDiamondPattern(int n) {\n        printTrianglePattern(n);\n        printDownTrianglePattern(n - 1);\n    }\n\n    public static void print01TrianglePattern(int n) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                System.out.print((i + j) % 2 == 0 ? 1 : 0);\n            }\n            System.out.println();\n        }\n    }\n\n    public static void printHalfButterflyNumberPattern(int n) {\n        for (int i = 1; i <= n; i++) {\n//            Num\n            for (int j = 1; j <= i; j++)\n                System.out.print(j + " ");\n//            Space\n            for (int k = 0; k < (n - i) * 2; k++)\n                System.out.print("  ");\n//            Num\n            for (int j = i; j > 0; j--)\n                System.out.print(j + " ");\n            System.out.println();\n        }\n    }\n\n    public static void printNumberTrianglePattern(int n) {\n        int start = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(start++ + " ");\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (j + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printDownAlphabetTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i; j++)\n                System.out.print((char) (j + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetTrianglePattern2(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (i + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n//            Space\n            for (int j = n; j > i; j--) {\n                System.out.print(" ");\n            }\n//            Num\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (j + 65));\n//            Num\n            for (int j = i; j > 0; j--)\n                System.out.print((char) (j + 64));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetReverseTrianglePattern(int n) {\n        for (int i = n; i > 0; i--) {\n//            Num\n            for (int j = n - i; j >= 0; j--)\n                System.out.print((char) (n - j - 1 + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printInnerDiamondPattern(int n) {\n        for (int i = n; i > 0; i--) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < n - i; j++)\n                System.out.print("  ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < n - i; j++)\n                System.out.print("  ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printButterflyPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            for (int j = 0; j < n - i - 1; j++)\n                System.out.print("  ");\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n        for (int i = n - 1; i > 0; i--) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < 2 * (n - i); j++)\n                System.out.print(" ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printEmptyRectPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == n - 1 || j == 0 || j == n-1) {\n                    System.out.print("*");\n                } else {\n                    System.out.print(" ");\n                }\n            }\n            System.out.println();\n        }\n    }\n    public static void printNumberRectPattern(int n) {\n        for (int i = 0; i < 2*n -1; i++) {\n            for (int j = 0;  j < 2*n -1; j++) {\n                int down = 2*n -2 - i;\n                int right = 2*n -2 - j;\n                System.out.print(n - Math.min(Math.min(i, down), Math.min(j, right)));\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n//        printBlockPattern(n);\n//        printTrianglePattern(n);\n//        printTriangleNumberPattern(n);\n//        printTriangleNumberPattern2(n);\n//        printDownTrianglePattern(n);\n//        printDownTriangleNumberPattern(n);\n//        printEQTrianglePattern(n);\n//        printDownEQTrianglePattern(n);\n//        printDiamondPattern(n);\n//        printHalfDiamondPattern(n);\n//        print01TrianglePattern(n);\n//        printHalfButterflyNumberPattern(n);\n//        printNumberTrianglePattern(n);\n//        printAlphabetTrianglePattern(n);\n//        printDownAlphabetTrianglePattern(n);\n//        printAlphabetTrianglePattern2(n);\n//        printAlphabetEQTrianglePattern(n);\n//        printAlphabetReverseTrianglePattern(n);\n//        printInnerDiamondPattern(n);\n//        printButterflyPattern(n);\n        printEmptyRectPattern(n);\n//        printNumberRectPattern(n);\n        sc.close();\n    }\n}',
              link: null,
              notes: '',
              tags: ['Pattern'],
            },
            {
              id: 'df2b696a-5d58-48ec-aecf-3c6ce3f9d66f',
              isFolder: true,
              name: 'Recursion',
              content: [
                {
                  id: 'd14e106e-de2c-4768-a4bf-a4ac56f08729',
                  isFolder: false,
                  name: 'CountGoodNumbers.java',
                  code: 'public class CountGoodNumbers {\n    public static long power(long num, long n) {\n        if (n == 0) return 1;\n        if (n == 1) return num;\n        long r = power(num, n/2);\n        if (n%2 == 0) return (r*r)%1000000007;\n        return (r*r*num)%1000000007;\n    }\n    public int countGoodNumbers(long n) {\n        long primePower = power(4, n/2);\n        long evenPower = power(5, n/2);\n        if (n%2 == 1)\n            evenPower *= 5;\n        return (int)((evenPower * primePower)%1000000007);\n    }\n}',
                  link: 'https://leetcode.com/problems/count-good-numbers/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'a3ed4b60-0735-4ed6-8747-de20b0155095',
                  isFolder: false,
                  name: 'Pow.java',
                  code: 'public class Pow {\n    public static double fastExpo(double x, int n) {\n        if (n == 0) return 1;\n        if (n == 1) return x;\n        double r = fastExpo(x, n/2);\n        return n%2 == 0 ? r*r : r*x*r;\n    }\n    public double myPow(double x, int n) {\n        // if (n == 0) return 1;\n        // double ans = x;\n        // for (int i = 2; i <= Math.abs(n); i++)\n        //     ans = ans * x;\n        // if (n < 0) {\n        //     ans = 1/ans;\n        // }\n        // return ans;\n        boolean isNegative = n < 0;\n        n = Math.abs(n);\n        double fast = fastExpo(x, n);\n        return isNegative ? 1/fast : fast;\n    }\n}',
                  link: 'https://leetcode.com/problems/powx-n/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'ef8305d9-0ee0-4c1e-8d8b-07f9222d48fd',
                  isFolder: false,
                  name: 'RecursiveATOI.java',
                  code: "public class RecursiveATOI {\n    public static int solve(char[] arr, int i, double num, boolean isNegative, boolean signed) {\n        if (i >= arr.length || signed && ((arr[i] == '+' || arr[i] == '-') || !Character.isDigit(arr[i]))) {\n            num = isNegative ? -num : num;\n            if (num > Integer.MAX_VALUE)\n                num = Integer.MAX_VALUE;\n            else if (num < Integer.MIN_VALUE)\n                num = Integer.MIN_VALUE;\n            return (int) num;\n        }\n        if (arr[i] == '+' || arr[i] == '-') {\n            isNegative = arr[i] == '-';\n            signed = true;\n        } else if (arr[i] - '0' >= 0 && arr[i] - '0' <= 9) {\n            num = num * 10 + (arr[i] - '0');\n            signed = true;\n        } else if (Character.isDigit(arr[i]) && arr[i] != ' ') {\n            i = arr.length;\n        }\n        i++;\n        return solve(arr, i, num, isNegative, signed);\n    }\n\n    public static int myAtoi(String s) {\n        char[] arr = s.toCharArray();\n        return solve(arr, 0, 0, false, false);\n    }\n\n    public static void main(String[] args) {\n        String s = \"  -0012a42\";\n        System.out.println(myAtoi(s));\n    }\n}",
                  link: 'https://leetcode.com/problems/string-to-integer-atoi/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'b028ef5b-7bec-455e-808e-d7be83a69d9d',
                  isFolder: false,
                  name: 'ReverseStack.java',
                  code: 'import java.util.Stack;\n\npublic class ReverseStack {\n    public static void insertElement(int element, Stack<Integer> s) {\n        if (s.isEmpty()) {\n            s.push(element);\n        } else {\n            int top = s.pop();\n            insertElement(element, s);\n            s.push(top);\n        }\n    }\n    public static void reverseStack(Stack<Integer> s) {\n        if (s.isEmpty()) return;\n        int element = s.pop();\n        reverseStack(s);\n        insertElement(element, s);\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> s = new Stack<>();\n        s.push(30);\n        s.push(-5);\n        s.push(18);\n        s.push(14);\n        s.push(-3);\n\n        System.out.println("Stack elements before sorting: ");\n        SortStack.printStack(s);\n        reverseStack(s);\n        System.out.println(" \\n\\nStack elements after sorting:");\n        SortStack.printStack(s);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/reverse-stack-using-recursion_631875',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '2feb5282-e560-4a22-ba47-f25210cbf9e1',
                  isFolder: false,
                  name: 'SortStack.java',
                  code: 'import java.util.*;\n\npublic class SortStack {\n    static void insertElement(int element, Stack<Integer> s) {\n        if (s.isEmpty() || s.peek() <= element) {\n            s.push(element);\n        } else {\n            int top = s.pop();\n            insertElement(element, s);\n            s.push(top);\n        }\n    }\n\n    static void sortStack(Stack<Integer> s) {\n        if (s.isEmpty()) return;\n        int element = s.pop();\n        sortStack(s);\n        insertElement(element, s);\n    }\n\n    // Utility Method to print contents of stack\n    static void printStack(Stack<Integer> s) {\n        ListIterator<Integer> lt = s.listIterator();\n        // forwarding\n        while (lt.hasNext())\n            lt.next();\n        // printing from top to bottom\n        while (lt.hasPrevious())\n            System.out.print(lt.previous() + " ");\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> s = new Stack<>();\n        s.push(30);\n        s.push(-5);\n        s.push(18);\n        s.push(14);\n        s.push(-3);\n\n        System.out.println("Stack elements before sorting: ");\n        printStack(s);\n        sortStack(s);\n        System.out.println(" \\n\\nStack elements after sorting:");\n        printStack(s);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sort-stack_1229505',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '3e50c3dd-f669-442c-9b9c-f123eac4dab1',
                  isFolder: false,
                  name: 'CombinationSum.java',
                  code: 'import java.util.*;\n\npublic class CombinationSum {\n    public static void solve(int[] arr, int target, List<List<Integer>> ans, List<Integer> temp, int idx) {\n        if (arr.length == idx) {\n            if (target == 0) ans.add(new ArrayList<>(temp));\n            return;\n        }\n        if (arr[idx] <= target) {\n            temp.add(arr[idx]);\n            solve(arr, target - arr[idx], ans, temp, idx);\n            temp.remove(temp.size() - 1);\n        }\n        solve(arr, target, ans, temp, idx + 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13,3,2,17};\n        int target = 14;\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, target, ans, new ArrayList<>(), 0);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'e6b3a489-aba4-445d-b84f-d216af47313e',
                  isFolder: false,
                  name: 'CombinationSum2.java',
                  code: 'import java.util.*;\npublic class CombinationSum2 {\n    public static void solve(int[] arr, int k, int sum, int idx, HashSet<List<Integer>> hs, List<Integer> temp) {\n        if (sum > k || arr.length == idx) return;\n        if (sum == k) {\n            List<Integer> list = new ArrayList<>(temp);\n            Collections.sort(list);\n            hs.add(list);\n            return;\n        }\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i] == arr[i-1]) continue;\n            if (arr[i] > k) return;\n            temp.add(arr[i]);\n            solve(arr, k, sum + arr[i], idx + 1, hs, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public static List<List<Integer>> combinationSum2(int[] arr, int target) {\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n        HashSet<List<Integer>> hs = new HashSet<>();\n        solve(arr, target, 0, 0, hs, new ArrayList<>());\n        return new ArrayList<>(hs);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10,1,2,7,6,1,5};\n        int target = 8;\n        System.out.println(combinationSum2(arr, target));\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum-ii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'f3204a1f-0bd4-4189-8b81-5f6e902167f1',
                  isFolder: false,
                  name: 'CombinationSum3.java',
                  code: 'import java.util.*;\n\npublic class CombinationSum3 {\n    public static void solve(int k, int n, HashSet<Integer> hs, List<List<Integer>> ans, List<Integer> temp, int idx,\n            HashSet<List<Integer>> ansHs) {\n        if (n < 0)\n            return;\n        if (n == 0) {\n            if (temp.size() == k)\n                ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i <= 9; i++) {\n            if (i > n)\n                return;\n            temp.add(i);\n            solve(k, n - i, hs, ans, temp, i + 1, ansHs);\n            temp.remove(temp.size() - 1);\n        }\n    }\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> ans = new ArrayList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        solve(k, n, hs, ans, new ArrayList<>(), 1, new HashSet<>());\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum-iii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'd6c9902d-a08c-4913-a13a-58d130467104',
                  isFolder: false,
                  name: 'GenerateAllBinaryStrings.java',
                  code: 'import java.util.*;\n\npublic class GenerateAllBinaryStrings {\n    public static void getAllStrings(int n, List<String> ans, StringBuilder sb, boolean hadOne) {\n        if (n == 0) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (hadOne) {\n            sb.append(0);\n            getAllStrings(n - 1, ans, sb, false);\n            sb.deleteCharAt(sb.length() - 1);\n        } else {\n            sb.append(0);\n            getAllStrings(n - 1, ans, sb, false);\n            sb.deleteCharAt(sb.length() - 1);\n            sb.append(1);\n            getAllStrings(n - 1, ans, sb, true);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n\n    public static List<String> generateString(int n) {\n        // Write your code here.\n        List<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getAllStrings(n, ans, sb, false);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        List<String> ans = generateString(n);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/-binary-strings-with-no-consecutive-1s._893001',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '0562dc69-a656-46a2-bff7-e11f6cd19abd',
                  isFolder: false,
                  name: 'GenerateParentheses.java',
                  code: 'import java.util.*;\n\npublic class GenerateParentheses {\n    public static void solve(int n, List<String> ans, StringBuilder sb, int closeCount, int openCount) {\n        if (openCount == n && closeCount == n) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (openCount < n) {\n            sb.append("(");\n            solve(n, ans, sb, closeCount, openCount + 1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        if (closeCount < openCount) {\n            sb.append(")");\n            solve(n, ans, sb, closeCount + 1, openCount);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n    public static List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        solve(n, ans, sb, 0, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        int n = 3;\n        System.out.println(generateParenthesis(n));\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/generate-all-parenthesis_920445',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'b1454485-28ab-4df8-9301-2b7d45b18991',
                  isFolder: false,
                  name: 'MoreSubsequences.java',
                  code: '// Link: https://www.codingninjas.com/studio/problems/more-subsequence_8842355\nimport java.util.*;\npublic class MoreSubsequences {\n    public static void solve(String s, StringBuilder sb, HashSet<String> ans, int idx) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        solve(s, sb, ans, idx + 1);\n\n        sb.append(s.charAt(idx));\n        solve(s, sb, ans, idx + 1);\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    public static int generateSubsequences(String s) {\n        // Write your code here\n        HashSet<String> ans = new HashSet<>();\n        solve(s, new StringBuilder(), ans, 0);\n        return ans.size();\n    }\n\n    public static String moreSubsequence(int n, int m, String a, String b) {\n        // Write your code here\n        return generateSubsequences(a) >= generateSubsequences(b) ? a : b;\n    }\n\n    public static void main(String[] args) {\n        String ans = moreSubsequence(9, 9, "cbfbdhcac", "bcbcfbeag");\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '26c0b9a3-2d56-492c-9e1d-84e1f90fe910',
                  isFolder: false,
                  name: 'PhoneKeypadCombination.java',
                  code: 'import java.util.*;\n\npublic class PhoneKeypadCombination {\n   public List<String> letterCombinations(String s) {\n        List<String> ans = new ArrayList<>();\n        if (s.length() == 0) return ans;\n        String[] mappings = {"", "", "abc","def", "ghi", "jkl","mno", "pqrs", "tuv","wxyz"};\n        solve(s, 0, ans, new StringBuilder(), mappings);\n        return ans;\n    }\n    void solve(String s, int idx, List<String> ans, StringBuilder sb, String[] mappings) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        char ch = s.charAt(idx);\n        String map = mappings[ch - \'0\'];\n        for (int i = 0; i < map.length(); i++) {\n            sb.append(map.charAt(i));\n            solve(s, idx + 1, ans, sb, mappings);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '1dbfce7e-e2ff-4818-8dfc-363d8baff07a',
                  isFolder: false,
                  name: 'SubarraysWithKSum.java',
                  code: 'import java.util.*;\n\npublic class SubarraysWithKSum {\n    public static void solve(int[] arr, long k, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        if (idx == arr.length) {\n            if (k == 0) ans.add(new ArrayList<>(temp));\n            return;\n        }\n        temp.add(arr[idx]);\n        solve(arr, k - arr[idx], idx + 1, ans, temp);\n        temp.remove(temp.size() - 1);\n        solve(arr, k, idx + 1, ans, temp);\n    }\n\n//    Count total subsequences\n    public static int solveCount(int[] arr, long k, int sum, int idx) {\n        if (sum > k || idx == arr.length && sum != k) return 0;\n        if (sum == k) return 1;\n        return solveCount(arr, k, sum + arr[idx], idx + 1) + solveCount(arr, k, sum, idx + 1);\n    }\n\n    public static void subArraysWithSumK(int[] arr, long k) {\n        // Write your code here\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(arr);\n        solve(arr, k, 0, ans, new ArrayList<>());\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 1, 1, 1};\n        long k = 3;\n        subArraysWithSumK(arr, k);\n    }\n}',
                  link: "https://www.codingninjas.com/studio/problems/subarrays-with-sum-%E2%80%98k'_6922076",
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'c416f35d-7d3f-40ea-bd52-69aa4cb92925',
                  isFolder: false,
                  name: 'SubsetSum.java',
                  code: '//  Link: https://www.codingninjas.com/studio/problems/subset-sum_3843086\n\nimport java.util.ArrayList;\n\npublic class SubsetSum {\n    public static void solve(int[] arr, int idx, int sum, ArrayList<Integer> ans) {\n        if (idx == arr.length) {\n            ans.add(sum);\n            return;\n        }\n        // Exclude\n        solve(arr, idx + 1, sum, ans);\n        // Include\n        solve(arr, idx + 1, sum + arr[idx], ans);\n    }\n    public static ArrayList<Integer> subsetSum(int nums[]) {\n        // Write your code here..\n        ArrayList<Integer> ans = new ArrayList<>();\n        solve(nums, 0, 0, ans);\n        ans.sort(null);\n        return ans;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '8de2e20d-5a85-4433-9299-e2690f8b1f1d',
                  isFolder: false,
                  name: 'SubsetSum2.java',
                  code: 'import java.util.*;\npublic class SubsetSum2 {\n    public static void solve(int[] arr, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        ans.add(new ArrayList<>(temp));\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i - 1] == arr[i]) continue;\n            temp.add(arr[i]);\n            solve(arr, i + 1, ans, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(nums, 0, ans, new ArrayList<>());\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/subsets-ii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '71568a21-1217-434e-bbfa-0905b7eb0c72',
                  isFolder: false,
                  name: 'ExpressionAddOperators.java',
                  code: 'import java.util.*;\n\npublic class ExpressionAddOperators {\n    public static List<String> addOperators(String num, int target) {\n        List<String> ans = new ArrayList<>();\n        if (num == null || num.length() == 0) return ans;\n        solve(target, num, ans, "", 0, 0, 0);\n        return ans;\n    }\n\n    static void solve(int target, String num, List<String> ans, String path, int idx, long res, long prev) {\n        if (idx == num.length()) {\n            if (res == target) ans.add(path);\n            return;\n        }\n        for (int i = idx; i < num.length(); i++) {\n            if (i != idx && num.charAt(idx) == \'0\') break;\n            long curr = Long.parseLong(num.substring(idx, i+1));\n            if (idx == 0)\n                solve(target, num, ans, path + curr, i + 1, curr, curr);\n            else {\n                solve(target, num, ans, path + "+" + curr, i + 1, res + curr, curr);\n                solve(target, num, ans, path + "-" + curr, i + 1, res - curr, -curr);\n                solve(target, num, ans, path + "*" + curr, i + 1, res - prev + prev * curr, prev * curr);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String num = "232";\n        int target = 8;\n        System.out.println(addOperators(num, target));\n    }\n}',
                  link: 'https://leetcode.com/problems/expression-add-operators/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '1e5457cb-cd7b-4401-87f9-9b529de13d3e',
                  isFolder: false,
                  name: 'MNodesColoring.java',
                  code: 'public class MNodesColoring {\n    public static boolean isPossible(int[][] mat, int node, int n, int[] colors, int color) {\n        for (int i = 0; i < n; i++) {\n            if (mat[node][i] == 1 && color == colors[i]) return false;\n        }\n        return true;\n    }\n    public static boolean solve(int[][] mat, int m, int node, int n, int[] colors) {\n        if (node == n) return true;\n        for (int i = 1; i <= m; i++) {\n            if (isPossible(mat, node, n, colors, i)) {\n                colors[node] = i;\n                if (solve(mat, m, node + 1, n, colors)) return true;\n                colors[node] = 0;\n            }\n        }\n        return false;\n    }\n    public static String graphColoring(int [][]mat, int m) {\n        // Write your code here\n        int n = mat.length;\n        return solve(mat, m, 0, n, new int[n]) ? "YES" : "NO";\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/m-coloring-problem_981273',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '83722712-4cf3-4173-846f-b68f93acb484',
                  isFolder: false,
                  name: 'NQueensProblem.java',
                  code: 'import java.util.Arrays;\n\npublic class NQueensProblem {\n\n    public static boolean safeToPlace(int i, int j, int[][] mat) {\n        int row = i, col = j;\n        while (row >= 0 && col >= 0) if (mat[row--][col--] == 1) return false;\n        row = i;\n        col = j;\n        while (col >= 0) if (mat[row][col--] == 1) return false;\n        col = j;\n        while (row < mat.length && col >= 0) if (mat[row++][col--] == 1) return false;\n        return true;\n    }\n\n    public static boolean solve(int[][] board, int col) {\n        if (col == board.length) {\n            for (int[] row : board)\n                System.out.println(Arrays.toString(row));\n            return true;\n        }\n\n        for (int row = 0; row < board.length; row++) {\n            if (safeToPlace(row, col, board)) {\n                board[row][col] = 1;\n                if (solve(board, col + 1)) return true;\n                board[row][col] = 0;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        int[][] board = new int[n][n];\n        solve(board, 0);\n    }\n}',
                  link: 'https://leetcode.com/problems/n-queens/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'eeed9bc7-abe6-4242-aed8-8ab445d1474a',
                  isFolder: false,
                  name: 'PalindromePartitioning.java',
                  code: 'import java.util.*;\npublic class PalindromePartitioning {\n    boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n\n    void solve(String s, List<List<String>> ans, List<String> temp, int idx) {\n        if (idx == s.length()) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            if (!isPalindrome(s, idx, i)) continue;\n            temp.add(s.substring(idx, i+1));\n            solve(s, ans, temp, i + 1);\n            temp.remove(temp.size() - 1);\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> ans = new ArrayList<>();\n        solve(s, ans, new ArrayList<>(), 0);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-partitioning/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'da4567b1-21cb-4b45-ae34-08eda07ea1e4',
                  isFolder: false,
                  name: 'RatInAMaze.java',
                  code: 'import java.util.*;\n\npublic class RatInAMaze {\n    public static void func(int[][] mat, int i, int j, String path, List<String> paths, String directions, int[] di, int[] dj, boolean[][] visited) {\n        int m = mat.length; // rows\n        int n = mat[0].length; // cols\n        if (i < 0 || j < 0 || j >= n || i >= m || mat[i][j] == 0 || visited[i][j]) return;\n        if (i == m - 1 && j == n - 1) {\n            paths.add(path);\n            return;\n        }\n        for (int x = 0; x < 4; x++) {\n            visited[i][j] = true;\n            func(mat, i + di[x], j + dj[x], path + directions.charAt(x), paths, directions, di, dj, visited);\n            visited[i][j] = false;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 0, 0, 0},\n                {1, 1, 0, 1},\n                {1, 1, 0, 0},\n                {0, 1, 1, 1},\n        };\n        List<String> paths = new ArrayList<>();\n        boolean[][] visited = new boolean[mat.length][mat[0].length];\n        String directions = "DLRU";\n        int[] di = {1, 0, 0, -1};\n        int[] dj = {0, -1, 1, 0};\n        func(mat, 0, 0, "", paths, directions, di, dj, visited);\n        System.out.println(paths);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/rat-in-a-maze-_8842357',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'c5e70440-e5b8-483a-a174-03851d1ea8dd',
                  isFolder: false,
                  name: 'SudokuSolver.java',
                  code: "public class SudokuSolver {\n    public static void printBoard(char[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            if (i % 3 == 0 && i != 0) {\n                System.out.println(\"- - - - - - - - - - - - - \");\n            }\n            for (int j = 0; j < board[i].length; j++) {\n                if (j % 3 == 0 && j != 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(board[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static boolean isPossible(char[][] board, int r, int c, char ch) {\n        for (int i = 0; i < 9; i++) {\n            if (board[r][i] == ch || board[i][c] == ch) return false;\n        }\n        int row = r / 3;\n        int col = c / 3;\n        for (int i = row * 3; i < (row + 1) * 3; i++) {\n            for (int j = col * 3; j < (col + 1) * 3; j++) {\n                if (board[i][j] == ch) return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean solve(char[][] board) {\n        for (int row = 0; row < board.length; row++) {\n            for (int col = 0; col < board[row].length; col++) {\n                if (board[row][col] == '.') {\n                    for (char ch = '1'; ch <= '9'; ch++) {\n                        if (isPossible(board, row, col, ch)) {\n                            board[row][col] = ch;\n                            if (solve(board)) return true;\n                            board[row][col] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void solveSudoku(char[][] board) {\n        if (solve(board)) {\n            printBoard(board);\n        };\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},\n                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},\n                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},\n                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},\n                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},\n                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},\n                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},\n                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},\n                {'.', '.', '.', '.', '8', '.', '.', '7', '9'}\n        };\n        solveSudoku(board);\n    }\n}",
                  link: 'https://leetcode.com/problems/sudoku-solver/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '53057c72-28d5-4b16-b96f-404b30625448',
                  isFolder: false,
                  name: 'WordBreak.java',
                  code: 'import java.util.List;\n\npublic class WordBreak {\n    static boolean check(String s, String b) {\n        return s.length() >= b.length() && s.startsWith(b);\n    }\n\n    static boolean solve(String s, List<String> words, int idx, int[] dp) {\n        if (idx == s.length())\n            return true;\n        for (int i = 0; i < words.size(); i++) {\n            if (!check(s.substring(idx), words.get(i)))\n                continue;\n            int x = idx + words.get(i).length();\n            if (dp[x] == 0 ? solve(s, words, x, dp) : dp[x] > 0)\n                return true;\n            dp[x] = -1;\n        }\n        return false;\n    }\n\n    public boolean wordBreak(String s, List<String> words) {\n        int[] dp = new int[s.length() + 1];\n        return solve(s, words, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/word-break/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '0b549435-7327-4098-a3da-e4964ec78b71',
                  isFolder: false,
                  name: 'WordSearch.java',
                  code: "public class WordSearch {\n    static boolean solve(String word, int idx, int i, int j, int[] dx, int[] dy, boolean[][] visited, char[][] board) {\n        if (idx == word.length()) return true;\n        char ch = word.charAt(idx);\n        if (i < 0 || j < 0 || i == board.length || j == board[0].length || visited[i][j] || board[i][j] != ch) return false;\n        System.out.println(board[i][j]);\n        for (int x = 0; x < 4; x++) {\n            visited[i][j] = true;\n            if (solve(word, idx + 1, i + dx[x], j + dy[x], dx, dy, visited, board)) {\n                return true;\n            }\n            visited[i][j] = false;\n        }\n        return false;\n    }\n\n    public static boolean exist(char[][] board, String word) {\n        // DLRU\n        int[] dx = {0, -1, 1, 0};\n        int[] dy = {1, 0, 0, -1};\n        boolean[][] visited = new boolean[board.length][board[0].length];\n\n        char ch = word.charAt(0);\n        for (int i = 0; i < board.length; i++)\n            for (int j = 0; j < board[i].length; j++)\n                if (board[i][j] == ch && solve(word, 0, i, j, dx, dy, visited, board)) return true;\n        return false;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n                {'A', 'B', 'C', 'E'},\n                {'S', 'F', 'C', 'S'},\n                {'A', 'D', 'E', 'E'}\n        };\n        String word = \"ABCCED\";\n        System.out.println(exist(board, word));\n    }\n}",
                  link: 'https://leetcode.com/problems/word-search/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
              ],
            },
            {
              id: 'e24543c7-fce8-4568-8a97-a64d90ce7fab',
              isFolder: true,
              name: 'Strings',
              content: [
                {
                  id: '94ecb959-05af-43bb-8f66-4ec692847c78',
                  isFolder: false,
                  name: 'IsomorphicStrings.java',
                  code: 'import java.util.*;\n\npublic class IsomorphicStrings {\n    public static boolean isIsomorphic(String s, String t) {\n        //    Brute force\n        //        Instead of char array use Stack array\n\n        //    Optimal approach\n        char[] mapST = new char[128];\n        char[] mapTS = new char[128];\n        for (int i = 0; i < s.length(); i++) {\n            char sChar = s.charAt(i);\n            char tChar = t.charAt(i);\n            if (mapST[sChar] != 0 && mapST[sChar] != tChar\n                    || mapTS[tChar] != 0 && mapTS[tChar] != sChar) {\n                return false;\n            }\n            mapST[sChar] = tChar;\n            mapTS[tChar] = sChar;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        String s = "edd";\n        String t = "add";\n        System.out.println(isIsomorphic(s, t));\n    }\n}',
                  link: 'https://leetcode.com/problems/isomorphic-strings/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '80069f80-7c97-450b-ad26-263c026f9627',
                  isFolder: false,
                  name: 'LargestOddNumberInString.java',
                  code: 'class LargestOddNumberInString {\n    public String largestOddNumber(String num) {\n        for (int i = num.length() - 1; i >= 0; i--) {\n            int value = num.charAt(i) - \'0\';\n            if (value % 2 == 1) return num.substring(0, i+1);\n        }\n        return "";\n    }\n}',
                  link: 'https://leetcode.com/problems/largest-odd-number-in-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '03f0c6f8-dff3-46e4-a6db-348a2c052841',
                  isFolder: false,
                  name: 'LongestCommonPrefix.java',
                  code: 'import java.util.*;\n\npublic class LongestCommonPrefix {\n    public static String longestCommonPrefix(String[] strs) {\n//        Brute force\n//        Arrays.sort(strs);\n//        String f = strs[0], l = strs[strs.length - 1];\n//        int len = Math.min(f.length(), l.length());\n//        int i = 0;\n//        while (i < len) {\n//            if (f.charAt(i) != l.charAt(i)) break;\n//            i++;\n//        }\n//        return f.substring(0, i);\n//        Optimal solution\n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (!strs[i].startsWith(prefix)) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        String[] strs = {"flower", "flow", "flight"};\n        System.out.println(longestCommonPrefix(strs));\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-common-prefix/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'dadd3968-cafb-4d96-880d-bab451c9e7ec',
                  isFolder: false,
                  name: 'RemoveOutermostParentheses.java',
                  code: "import java.util.*;\n\npublic class RemoveOutermostParentheses {\n    public static String removeOuterParentheses(String s) {\n//        Brute force approach\n//        StringBuilder sb = new StringBuilder();\n//        Stack<Character> stack = new Stack<>();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (ch == '(') {\n//                if (stack.size() > 0) {\n//                    sb.append(ch);\n//                }\n//                stack.push(ch);\n//            } else if (ch == ')') {\n//                stack.pop();\n//                if (stack.size() > 0) {\n//                    sb.append(ch);\n//                }\n//            }\n//        }\n//        return sb.toString();\n\n//        Optimal approach\n        int counter = 0;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') {\n                if (counter > 0) {\n                    sb.append(ch);\n                }\n                counter++;\n            } else if (ch == ')') {\n                if (counter > 1) {\n                    sb.append(ch);\n                }\n                counter--;\n            }\n        }\n        return sb.toString();\n    }\n}",
                  link: 'https://leetcode.com/problems/remove-outermost-parentheses/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '8602b1d4-d704-4382-900b-c5f70103fee2',
                  isFolder: false,
                  name: 'ReverseWordsInAString.java',
                  code: 'public class ReverseWordsInAString {\n    public static String reverseWords(String s) {\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == \' \') i--;\n            // first character\n            j = i;\n            while (i >= 0 && s.charAt(i) != \' \') i--;\n            if (i == - 1) {\n                sb.append(s, 0, j+1);\n            } else {\n                sb.append(s, i+1, j+1).append(" ");\n            }\n        }\n        return sb.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        String s = "the sky is blue";\n        System.out.println(reverseWords(s));\n    }\n}',
                  link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '5951c0b7-b7f8-4456-978e-0f315c6498ab',
                  isFolder: false,
                  name: 'RotateStrings.java',
                  code: 'import java.util.*;\npublic class RotateStrings {\n    public static boolean rotateString(String s, String goal) {\n//        Brute force solution\n//        if (s.length() != goal.length()) return false;\n//        if (s.equals(goal)) return true;\n//        StringBuilder sb = new StringBuilder(goal);\n//        for (int i = 0; i < s.length(); i++) {\n//            sb.append(sb.charAt(0)).replace(0,1,"");\n//            if (s.contentEquals(sb)) return true;\n//        }\n//        return false;\n\n//        Trick solution\n        return (s + s).contains(goal);\n\n//        Queue solution\n//        if (s.length() != goal.length()) return false;\n//        Queue<Character> q1 = new LinkedList<>();\n//        Queue<Character> q2 = new LinkedList<>();\n//        for (int i = 0; i < s.length(); i++) {\n//            q1.add(s.charAt(i));\n//            q2.add(goal.charAt(i));\n//        }\n//        int k = s.length() - 2;\n//        while (k != 0) {\n//            q1.add(q1.remove());\n//            if (q1.equals(q2)) return true;\n//            k--;\n//        }\n//        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(rotateString("abcde","cdeab"));\n    }\n}',
                  link: 'https://leetcode.com/problems/rotate-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '46042466-a116-4f8f-93d3-94e15edae5a9',
                  isFolder: false,
                  name: 'ValidAnagram.java',
                  code: "public class ValidAnagram {\n    public static boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) return false;\n        }\n        return true;\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-anagram/description/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'fbbfc270-b9a4-4fb9-b2a3-fec7d74a6d7f',
                  isFolder: false,
                  name: 'CountWithKDifferentCharacters.java',
                  code: "import java.util.*;\n\npublic class CountWithKDifferentCharacters {\n    public static int helper(String str, int k) {\n        int[] bucket = new int[26];\n        int result = 0,  i = 0, j = 0, c = 0;\n        while (j < str.length()) {\n            int idx = str.charAt(j) - 'a';\n            bucket[idx]++;\n            if (bucket[idx] == 1) c++;\n            while (c > k) {\n                int idx2 = str.charAt(i) - 'a';\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) c--;\n                i++;\n            }\n            result += j - i + 1;\n            j++;\n        }\n        return result;\n    }\n    public static int countSubStrings(String str, int k) {\n        // Brute force solution: Generate all substrings and check the count of substrings containing k different characters\n//        int count = 0;\n//        for (int i = 0; i < str.length(); i++) {\n//            for (int j = i; j < str.length(); j++) {\n//                String s = str.substring(i, j+1);\n//                HashSet<Character> hs = new HashSet<>();\n//                for (int x = 0; x < s.length(); x++) {\n//                    hs.add(s.charAt(x));\n//                }\n//                if (hs.size() == k) count++;\n//            }\n//        }\n//        return count;\n\n        // Better solution: Use 2 nested loops (subarray trick) and array instead of HashSet\n//        int count = 0;\n//        for (int i = 0; i < str.length(); i++) {\n//            int[] bucket = new int[26];\n//            int c = 0;\n//            for (int j = i; j < str.length(); j++) {\n//                char ch = str.charAt(j);\n//                bucket[ch - 'a']++;\n//                if (bucket[ch - 'a'] == 1) c++;\n//                if (c == k) count++;\n//            }\n//        }\n//        return count;\n\n        // Optimal solution: To get the exact k we need the difference of atmost k and atmost k-1\n        return helper(str, k) - helper(str, k-1);\n    }\n\n    public static void main(String[] args) {\n        String s = \"aacfssa\";\n        int k = 3;\n        int count = countSubStrings(s, k);\n        System.out.println(count);\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/count-with-k-different-characters_1214627',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: 'ad1a1ca8-875e-411f-8d07-bb25837acf87',
                  isFolder: false,
                  name: 'LongestPalindromicSubstring.java',
                  code: 'public class LongestPalindromicSubstring {\n    public static boolean isPalindrome(String str) {\n        int i = 0;\n        while (i < str.length() / 2) {\n            if (str.charAt(i) != str.charAt(str.length() - i - 1)) return false;\n            i++;\n        }\n        return true;\n    }\n\n    public static int expandFromMid(int left, int right, String s) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    public String longestPalindrome(String s) {\n//        Brute force\n//        String maxL = "";\n//        for (int i = 0; i < s.length(); i++) {\n//            for (int j = i; j < s.length(); j++) {\n//                if (s.charAt(i) == s.charAt(j)) {\n//                    String sub = s.substring(i, j + 1);\n//                    if (sub.length() > maxL.length() && isPalindrome(sub)) {\n//                        maxL = sub;\n//                    }\n//                }\n//            }\n//        }\n//        return maxL;\n\n//        Optimized approach: Go to each element and try to expand outwards, store max\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = expandFromMid(i, i, s);\n            int len2 = expandFromMid(i, i + 1, s);\n            int len = Math.max(len1, len2);\n            if (len > end - start + 1) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-palindromic-substring/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '061cb907-8f0d-4beb-b530-4c5bd9f2ce6f',
                  isFolder: false,
                  name: 'MaximumNestingDepthOfParentheses.java',
                  code: "class MaximumNestingDepthOfParentheses {\n    public int maxDepth(String s) {\n        int maxLength = 0, count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') count++;\n            else if (ch == ')') count--;\n            maxLength = Math.max(maxLength, count);\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '849d27b7-a138-4f76-8e69-c70aa55d37be',
                  isFolder: false,
                  name: 'ReverseWordsInAString.java',
                  code: "public class ReverseWordsInAString {\n    public String reverseWords(String s) {\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == ' ') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != ' ') i--;\n            if (i == - 1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n}",
                  link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: 'ac4d2251-6a29-4605-bb6c-026d36388357',
                  isFolder: false,
                  name: 'RomanToIntegers.java',
                  code: "import java.util.HashMap;\n\npublic class RomanToIntegers {\n    public static int romanToInt(String s) {\n        HashMap<Character, Integer> hm = new HashMap<>();\n        hm.put('I', 1);\n        hm.put('V', 5);\n        hm.put('X', 10);\n        hm.put('L', 50);\n        hm.put('C', 100);\n        hm.put('D', 500);\n        hm.put('M', 1000);\n        char[] sArr = s.toCharArray();\n        int sum = 0;\n        for (int i = 0; i < sArr.length; i++) {\n            if (i < sArr.length - 1 && hm.get(sArr[i]) >= hm.get(sArr[i+1])) {\n                sum += hm.get(sArr[i]);\n            } else {\n                sum -= hm.get(sArr[i]);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        String s = \"III\";\n        System.out.println(romanToInt(s));\n    }\n}",
                  link: 'https://leetcode.com/problems/roman-to-integer/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '4dde28e0-eb17-4b84-9553-d5e38cf530a2',
                  isFolder: false,
                  name: 'SortCharacterByFrequency.java',
                  code: 'import java.util.*;\n\npublic class SortCharacterByFrequency {\n    public static HashMap<Character, Integer> getFrequencyMap(char[] s) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length; i++) {\n            map.put(s[i], map.getOrDefault(s[i], 0) + 1);\n        }\n        return map;\n    }\n\n    public static void addFrequencyChar(StringBuilder sb, int times, char ch) {\n        while (times != 0) {\n            sb.append(ch);\n            times--;\n        }\n    }\n\n    public static String frequencySort(String s) {\n//      Brute force solution\n//        HashMap<Character, Integer> hm = getFrequencyMap(s.toCharArray());\n//        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue(Collections.reverseOrder()));\n//        pq.addAll(hm.entrySet());\n//        StringBuilder sb = new StringBuilder();\n//        while (!pq.isEmpty()) {\n//            Map.Entry<Character, Integer> map = pq.poll();\n//            addFrequencyChar(sb, map.getValue(), map.getKey());\n//        }\n//        return sb.toString();\n\n//        Optimized Solution\n        HashMap<Character, Integer> hm = getFrequencyMap(s.toCharArray());\n        List<Character>[] list = new List[s.length() + 1];\n        for (Map.Entry<Character, Integer> map: hm.entrySet()) {\n            int i = map.getValue();\n            if (list[i] == null)\n                list[i] = new ArrayList<>();\n            list[i].add(map.getKey());\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = s.length(); i > 0; i--)\n            if (list[i] != null)\n                for (char ch : list[i]) addFrequencyChar(sb, i, ch);\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(frequencySort("treerrrazt"));\n    }\n}',
                  link: 'https://leetcode.com/problems/sort-characters-by-frequency/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '242b8c06-c158-486e-91a6-ba4d335e34fc',
                  isFolder: false,
                  name: 'StringToIntegerATOI.java',
                  code: "public class StringToIntegerATOI {\n    public int myAtoi(String s) {\n        boolean isNegative = false;\n        char[] sArray = s.toCharArray();\n        int n = sArray.length;\n        int i = 0;\n        while (i < n && sArray[i] == ' ') i++;\n        if (i < n && sArray[i] == '-') {\n            isNegative = true;\n            i++;\n        } else if (i < n && sArray[i] == '+') i++;\n        double num = 0;\n        while (i < n && sArray[i] - '0' >= 0 && sArray[i] - '0' <= 9) {\n            num = num*10 + (sArray[i] - '0');\n            i++;\n        }\n        num = isNegative ? -num : num;\n        if (num > Integer.MAX_VALUE)\n            num = Integer.MAX_VALUE;\n        else if (num < Integer.MIN_VALUE)\n            num = Integer.MIN_VALUE;\n        return (int)num;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n    }\n}",
                  link: 'https://leetcode.com/problems/string-to-integer-atoi/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '9739d650-756a-41d7-a1b1-e490155c9729',
                  isFolder: false,
                  name: 'SumOfBeautyOfAllSubstrings.java',
                  code: "public class SumOfBeautyOfAllSubstrings {\n    public static int calcBeauty(String sub) {\n        int[] count = new int[26];\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\n        for (int i = 0; i < sub.length(); i++) {\n            int idx = sub.charAt(i) - 'a';\n            count[idx]++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                low = Math.min(low, count[i]);\n            }\n            high = Math.max(high, count[i]);\n        }\n        int c = high - low;\n        return Math.max(c, 0);\n    }\n\n    public static int beautySum(String s) {\n        int sum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int[] count = new int[26];\n            int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\n            for (int j = i; j < s.length(); j++) {\n                count[s.charAt(j) - 'a']++;\n                for (int c : count) {\n                    if (c != 0)\n                        low = Math.min(low, c);\n                    high = Math.max(high, c);\n                }\n                sum += high - low;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        String s = \"xzvfsppsjfbxdwkqe\";\n        int ans = beautySum(s);\n        System.out.println(ans);\n    }\n}",
                  link: 'https://leetcode.com/problems/sum-of-beauty-of-all-substrings/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};

export default data;
