const data = {
  id: '5db6a19a-c068-46f5-800a-ebe59a258706',
  isFolder: true,
  name: 'DSA',
  content: [
    {
      id: '2692f972-ec4b-4173-9af1-5e1b6c14d6cb',
      isFolder: true,
      name: 'Concepts',
      content: [
        {
          id: '46f9fcea-ff14-452c-ba2c-e553094a6876',
          isFolder: false,
          name: 'DoublyLinkedList.java',
          code: 'public class DoublyLinkedList {\n    private Node head;\n    private Node tail;\n    private int length = 0;\n\n    class Node {\n        int value;\n        Node next;\n        Node prev;\n\n        Node(int val) {\n            this.value = val;\n        }\n    }\n\n    DoublyLinkedList() {\n        head = tail = null;\n    }\n\n    DoublyLinkedList(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n\n    public static void printList(DoublyLinkedList list) {\n        Node temp = list.head;\n        if (list.length == 0) {\n            System.out.println("<List empty>");\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.length; i++) {\n            sb.append(temp.value);\n            if (temp.next != null) {\n                sb.append(" <--> ");\n            }\n            temp = temp.next;\n        }\n        System.out.println(sb.toString());\n    }\n\n    public void append(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            tail.next = temp;\n            temp.prev = tail;\n            tail = temp;\n        }\n        length++;\n    }\n\n    public Node removeLast() {\n        if (length == 0) return null;\n        Node temp = tail;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            tail = tail.prev;\n            tail.next = temp.prev = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public void prepend(int val) {\n        Node temp = new Node(val);\n        if (length == 0) {\n            head = tail = temp;\n        } else {\n            temp.next = head;\n            head.prev = temp;\n            head = temp;\n        }\n        length++;\n    }\n\n    public Node removeFirst() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            head.prev = null;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n\n    public Node get(int index) {\n        if (index < 0 || index >= length) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean insert(int index, int val) {\n        if (index < 0 || index > length) return false;\n        if (index == 0) {\n            prepend(val);\n        } else if (index == length) {\n            append(val);\n        } else {\n            Node before = get(index - 1);\n            Node after = before.next;\n            Node temp = new Node(val);\n            before.next = temp;\n            temp.next = after;\n            after.prev = temp;\n            temp.prev = before;\n        }\n        length++;\n        return true;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) {\n            length--;\n            return removeFirst();\n        }\n        if (index == length - 1) {\n            length--;\n            return removeLast();\n        }\n        Node temp = get(index);\n        if (temp != null) {\n            Node before = temp.prev;\n            Node after = temp.next;\n            before.next = after;\n            after.prev = before;\n            length--;\n            return temp;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        DoublyLinkedList list = new DoublyLinkedList(1);\n        list.append(2);\n        list.append(3);\n        list.append(9);\n        list.append(12);\n        System.out.println(list.remove(1));\n//        list.insert(4, 91);\n//        System.out.println(list.set(2, 99));\n//        System.out.println(list.get(2).value);\n//        System.out.println(list.removeFirst().value);\n        DoublyLinkedList.printList(list);\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: '5e543e0c-068d-4eb8-89da-bb9d7b7be379',
          isFolder: false,
          name: 'Queue.java',
          code: 'public class Queue {\n    class Node {\n        int value;\n        Node next;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    Node head;\n    Node tail;\n    int length;\n    Queue(int val) {\n        Node newNode = new Node(val);\n        head = tail = newNode;\n        length++;\n    }\n    Queue() {\n        head = tail = null;\n        length = 0;\n    }\n    Node enqueue(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n        return newNode;\n    }\n\n    Node dequeue() {\n        if (length == 0) return null;\n        Node temp = head;\n        if (length == 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        return temp;\n    }\n\n    public static void main(String[] args) {\n        Queue q = new Queue(10);\n        q.enqueue(4);\n        q.enqueue(19);\n        System.out.println(q.dequeue().value);\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: 'a0d95b4b-060d-46e1-87fd-97544b37f48a',
          isFolder: false,
          name: 'SinglyLinkedList.java',
          code: 'public class SinglyLinkedList {\n    static class Node {\n        int value;\n        Node next;\n        Node (int val) {\n            this.value = val;\n        }\n    }\n    int length;\n    private Node head;\n    private Node tail;\n    SinglyLinkedList(int value) {\n        Node newNode = new Node(value);\n        head = tail = newNode;\n        length = 1;\n    }\n    SinglyLinkedList() {\n        head = tail = null;\n        length = 0;\n    }\n\n//    Methods\n    public void prepend(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            newNode.next = head;\n            head = newNode;\n        }\n        length++;\n    }\n    public void append(int val) {\n        Node newNode = new Node(val);\n        if (length == 0) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        length++;\n    }\n    public Node removeLast() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            Node pre = head;\n            while (temp.next != null) {\n                pre = temp;\n                temp = temp.next;\n            }\n            tail = pre;\n            tail.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node removeFirst() {\n        Node temp = head;\n        if (length <= 1) {\n            head = tail = null;\n        } else {\n            head = head.next;\n            temp.next = null;\n        }\n        length--;\n        return temp;\n    }\n    public Node get(int index) {\n        if (index >= length || index < 0) return null;\n        Node temp = head;\n        for (int i = 0; i < index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n    public boolean set(int index, int val) {\n        Node temp = get(index);\n        if (temp != null) {\n            temp.value = val;\n            return true;\n        }\n        return false;\n    }\n\n    public void insert(int index, int val) {\n        if (index < 0 || index > length) return;\n        else if (index == 0) {\n            prepend(val);\n            return;\n        } else if (index == length) {\n            append(val);\n            return;\n        }\n        Node temp = head;\n        for (int i = 0; i < index - 1; i++) {\n            temp = temp.next;\n        }\n        Node newNode = new Node(val);\n        newNode.next = temp.next;\n        temp.next = newNode;\n        length++;\n        return;\n    }\n\n    public Node remove(int index) {\n        if (index < 0 || index >= length) return null;\n        if (index == 0) return removeFirst();\n        if (index == length - 1) return removeLast();\n        Node prev = get(index - 1);\n        Node temp = prev.next;\n        prev.next = temp.next;\n        temp.next = null;\n        length--;\n        return temp;\n    }\n\n    public void reverse() {\n        Node temp = head;\n        head = tail;\n        tail = temp;\n        Node prev = null;\n        Node next = null;\n        for (int i = 0; i < length; i++) {\n            next = temp.next;\n            temp.next = prev;\n            prev = temp;\n            temp = next;\n        }\n    }\n\n    public int getLength() {\n        return length;\n    }\n    public String getString() {\n        Node temp = head;\n        StringBuilder sb = new StringBuilder();\n        while (temp != null) {\n            sb.append(temp.value).append(" ");\n            temp = temp.next;\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.append(1);\n        list.append(3);\n        list.append(5);\n        list.append(6);\n        System.out.println(list.getString());\n        list.reverse();\n        System.out.println(list.getString());\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: 'ce57a232-93d1-4ea7-9abe-497d6677c1ab',
          isFolder: false,
          name: 'Stack.java',
          code: '// Using Singly linked list\n\npublic class Stack {\n    class Node {\n        Node next;\n        int value;\n        Node(int val) {\n            this.value = val;\n        }\n    }\n    private Node top;\n    private int height;\n    Stack(int val) {\n        top = new Node(val);\n        height = 1;\n    }\n//    Peek\n    public Node peek() {\n        return top;\n    }\n//    Push\n    public void push(int val) {\n        Node newNode = new Node(val);\n        if (height == 0) {\n            top = newNode;\n        } else {\n            newNode.next = top;\n            top = newNode;\n        }\n        height++;\n    }\n//    Pop\n    public Node pop() {\n        if (isEmpty()) {\n            return null;\n        }\n        Node temp = top;\n        top = top.next;\n        temp.next = null;\n        height--;\n        return temp;\n    }\n//    isEmpty\n    public boolean isEmpty() {\n        return height == 0;\n    }\n\n    public static void main(String[] args) {\n        Stack myStack = new Stack(10);\n        myStack.push(19);\n        myStack.push(13);\n        myStack.push(41);\n        myStack.push(25);\n//        System.out.println(myStack.pop().value);\n//        System.out.println(myStack.peek().value);\n        System.out.println(myStack.isEmpty());\n    }\n}',
          link: null,
          notes: '',
          tags: ['DataStructures'],
        },
        {
          id: '84933823-bc14-4dcc-8891-354f106e69af',
          isFolder: false,
          name: 'BinarySearch.java',
          code: '// BS on 1D Arrays\npublic class BinarySearch {\n    //    Iterative Binary Search\n    public static int binarySearch(int[] A, int target) {\n        int start = 0;\n        int end = A.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (A[mid] == target) return mid;\n            if (A[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return -1;\n    }\n\n    //    Recursive Binary search\n    public static int binarySearch(int[] A, int target, int start, int end) {\n        if (start > end)\n            return -1;\n        int mid = start + (end - start) / 2;\n        if (A[mid] == target)\n            return mid;\n        if (A[mid] > target)\n            return binarySearch(A, target, start, mid - 1);\n        else\n            return binarySearch(A, target, mid + 1, end);\n    }\n\n    static int orderAgnosticBS(int arr[], int target) {\n        boolean isAscending = arr[0] > arr[arr.length - 1];\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = ((end - start) / 2) + start;\n            if (target == arr[mid]) return mid;\n            if (isAscending) {\n                if (target > arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return -1;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Search'],
        },
        {
          id: '6e5f4bac-3556-4389-a537-c23d2de8da16',
          isFolder: false,
          name: 'LinearSearch.java',
          code: 'public class LinearSearch {\n    static int linearSearch(int arr[], int target) {\n        for (int i = 0; i <= arr.length; i++) {\n            if (target == arr[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Search'],
        },
        {
          id: '3faddb48-d6e2-48c2-82ec-43a67a32b893',
          isFolder: false,
          name: 'BubbleSort.java',
          code: 'public class BubbleSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n      boolean swapped = false;\n      for (int j = 0; j < n - i - 1; j++) {\n        if (arr[j] > arr[j + 1]) {\n          swap(arr, j, j + 1);\n          swapped = true;\n        }\n      }\n      if (!swapped) break;\n    }\n  }\n  \n  public static void bubbleSortRecursive(int[] arr, int n) {\n    if (n == 1) return;\n    boolean swapped = false;\n    for (int j = 0; j < n - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        swapped = true;\n      }\n    }\n    if (!swapped) return;\n    bubbleSortRecursive(arr, n - 1);\n  }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '6b2629da-288a-410b-8483-07fb704c6f13',
          isFolder: false,
          name: 'CyclicSort.java',
          code: 'public class CyclicSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n\n  public static void cyclicSort(int[] arr) {\n    int i = 0;\n    while (i < arr.length) {\n      if (arr[i] != arr[arr[i] - 1])\n        swap(arr, i, arr[i] - 1);\n      else\n        i++;\n    }\n  }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: 'a83941b6-74f5-4a9d-a56f-b56ed699a1d4',
          isFolder: false,
          name: 'InsertionSort.java',
          code: 'public class InsertionSort {\n  public static void swap(int[] arr, int idx1, int idx2) {\n    int temp = arr[idx1];\n    arr[idx1] = arr[idx2];\n    arr[idx2] = temp;\n  }\n  public static void insertionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 1; i < n - 1; i++) {\n      for (int j = i; j > 0; j--) {\n        if (arr[j] >= arr[j - 1])\n          break;\n        swap(arr, j, j-1);\n      }\n    }\n  }\n\n  public static void insertionSortRecursive(int[] arr, int i) {\n    if (i == arr.length-1) return;\n    for (int j = i; j > 0; j--) {\n      if (arr[j] >= arr[j - 1])\n        break;\n      swap(arr, j, j-1);\n    }\n    insertionSortRecursive(arr, i+1);\n  }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '2f7ed040-8ccd-4271-8bfd-4fa7f6fecb71',
          isFolder: false,
          name: 'MergeSort.java',
          code: 'public class MergeSort {\n  public static void mergeArray(int[] arr, int low, int mid, int high) {\n    int[] temp = new int[high - low + 1];\n    int left = low, right = mid + 1, i = 0;\n    while (left <= mid && right <= high) {\n      if (arr[left] <= arr[right])\n        temp[i++] = arr[left++];\n      else\n        temp[i++] = arr[right++];\n    }\n\n    while (left <= mid)\n      temp[i++] = arr[left++];\n\n    while (right <= high)\n      temp[i++] = arr[right++];\n\n    for (int j = 0; j < i; j++)\n      arr[j + low] = temp[j];\n  }\n\n  public static void mergeSort(int[] arr, int low, int high) {\n    if (low == high) {\n      return;\n    }\n    int mid = low + (high - low) / 2;\n    mergeSort(arr, low, mid);\n    mergeSort(arr, mid + 1, high);\n    mergeArray(arr, low, mid, high);\n  }\n\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: 'a69b459c-774f-4d2d-872e-b9f39b045d5c',
          isFolder: false,
          name: 'QuickSort.java',
          code: 'public class QuickSort {\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int partition(int[] A, int low, int high) {\n        int pivot = A[low];\n        int i = low, j = high;\n        while (i < j) {\n            while (A[i] <= pivot && i < high) i++;\n            while (A[j] > pivot && j > low) j--;\n            if (i < j) swap(A, i, j);\n        }\n        swap(A, j, low);\n        return j;\n    }\n    public static void quickSort(int[] A, int low, int high) {\n        if (low < high) {\n            int pIdx = partition(A, low, high);\n            quickSort(A, low, pIdx-1);\n            quickSort(A, pIdx+1, high);\n        }\n    }\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: '48efa8fd-85ca-49aa-8b5f-ff8f76be711c',
          isFolder: false,
          name: 'SelectionSort.java',
          code: 'public class SelectionSort {\n  public static void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++) {\n      int minIdx = i;\n      for (int j = i + 1; j < n; j++)\n        if (arr[minIdx] > arr[j])\n          minIdx = j;\n      if (i != minIdx) {\n        int temp = arr[i];\n        arr[i] = arr[minIdx];\n        arr[minIdx] = temp;\n      }\n    }\n  }\n\n}',
          link: null,
          notes: '',
          tags: ['Sorting'],
        },
        {
          id: 'c6024666-266c-4972-831c-c9686fb73f49',
          isFolder: false,
          name: 'CycleDetectionArray.java',
          code: "// AKA Floyd's algorithm, cycle detection in an array, find the duplicate number in an array of [1 - N]\npublic class CycleDetectionArray {\n    public static int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
          link: 'https://leetcode.com/problems/find-the-duplicate-number',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '8c9a55bd-53ce-40e5-82e5-92c5993ceb96',
          isFolder: false,
          name: 'CycleDetectionLinkedList.java',
          code: '// Detect loop or cycle in a linked list\npublic class CycleDetectionLinkedList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(0);\n        ListNode temp = head;\n        temp.next = new ListNode(2);\n        temp = temp.next;\n        temp.next = new ListNode(4);\n        temp = temp.next;\n        temp.next = new ListNode(1);\n        temp = temp.next;\n        temp.next = new ListNode(0);\n//        Created a cycle\n        temp.next.next  = head.next.next;\n    }\n}',
          link: 'https://leetcode.com/problems/linked-list-cycle',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: 'e8789859-154a-4b7d-9978-ec9fffe8c952',
          isFolder: false,
          name: 'DutchNationalFlagAlgorithm.java',
          code: "// Dutch's national flag algorithm\n\nimport java.util.Arrays;\n\npublic class DutchNationalFlagAlgorithm {\n    public static int[] sort012(int[] arr) {\n        int low = 0, mid = 0, high = arr.length - 1;\n        while (mid <= high) {\n            if (arr[mid] == 0) {\n                int temp = arr[low];\n                arr[low] = arr[mid];\n                arr[mid] = temp;\n                low++;\n                mid++;\n            } else if (arr[mid] == 1) mid++;\n            else {\n                int temp = arr[high];\n                arr[high] = arr[mid];\n                arr[mid] = temp;\n                high--;\n            }\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 0, 1, 2};\n        int[] ans = sort012(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
          link: 'https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '9dd3184c-baac-4284-b7b6-b9eb0d855951',
          isFolder: false,
          name: 'FastExponentiation.java',
          code: 'public class FastExponentiation {\n    public static int power(int a, int n) {\n        if (n == 0) return 1;\n        else if (n == 1) return a;\n\n        int r = power(a, n/2);\n\n        if (n%2 == 0) return r*r;\n        return r*a*r;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: 'a69d17bd-8ccf-4e22-b8b1-99869a22974e',
          isFolder: false,
          name: 'GCD.java',
          code: 'public class GCD {\n//    a = big, b = small\n    public static int getGCD(int a, int b) {\n        if (a%b == 0) return b;\n        return getGCD(b, a%b);\n    }\n\n    public static void main(String[] args) {\n        int ans = getGCD(51, 24);\n        System.out.println(ans);\n    }\n}',
          link: null,
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '58307272-f72d-4f7f-8607-4f9f4add60d6',
          isFolder: false,
          name: 'KadanesAlgorithm.java',
          code: "// Largest Sum Contiguous Subarray (Kadane's Algorithm)\npublic class KadanesAlgorithm {\n    public static int maxSum(int[] nums) {\n        int sum = 0;\n        int maxSum = 0;\n        for (int num : nums) {\n            sum += num; // Increment\n            maxSum = Math.max(maxSum, sum); // Maximise\n            if (sum < 0) sum = 0; // Check to reset\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, -3, 4, -1, -2, 1, 5, -3};\n        int ans = maxSum(arr);\n        System.out.println(ans);\n    }\n}",
          link: 'https://www.geeksforgeeks.org/largest-sum-contiguous-subarray',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: 'cbfc6c4b-7ca6-4017-a384-45ba7aeb44d4',
          isFolder: false,
          name: 'MooresVotingAlgorithm.java',
          code: '//  Boyer-Moore Majority Voting Algorithm: used to find the majority element among the given elements that have more than N/ 2 occurrences.\npublic class MooresVotingAlgorithm {\n    public static int findMajority(int[] N) {\n        int element = -1, count = 0;\n        for (int j : N) {\n            if (count == 0) {\n                element = j;\n                count = 1;\n            } else if (element == j) count++;\n            else count--;\n        }\n        return element;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 2, 2, 1, 1, 2, 3, 4};\n        int majority = findMajority(arr);\n        System.out.println(" The majority element is : " + majority);\n    }\n}',
          link: 'https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm',
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: 'd1621b44-6e34-47f3-8227-8cc5d093b9cc',
          isFolder: false,
          name: 'SieveOfEratosthenes.java',
          code: 'import java.util.*;\n\npublic class SieveOfEratosthenes {\n    public static int sieve(int n) {\n        List<Integer> ans = new ArrayList<>();\n        if (n <= 2) return 0;\n        int count = 0;\n        boolean[] M = new boolean[n];\n        for (int i = 2; i < n; i++) {\n            if (!M[i]) {\n                ans.add(i);\n                count++;\n                for (int j = 2* i; j < n; j += i) {\n                    M[j] = true;\n                }\n            }\n        }\n        System.out.println(ans);\n        return count;\n    }\n}',
          link: null,
          notes: '',
          tags: ['Special Algorithms'],
        },
        {
          id: '736b751c-cbb7-4694-a9a2-be4d32314d4a',
          isFolder: false,
          name: 'SubsequencesOfAString.java',
          code: 'import java.util.*;\n\npublic class SubsequencesOfAString {\n    public static ArrayList<String> subsequences(String str) {\n        // Using power set technique\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n}',
          link: 'https://www.codingninjas.com/studio/problems/subsequences-of-string_985087',
          notes: '',
          tags: ['Special Algorithms'],
        },
      ],
    },
    {
      id: '0e4d97ac-044c-498e-aa2e-d565d168f274',
      isFolder: true,
      name: 'DSAPrepQuestions',
      content: [
        {
          id: 'ae150060-4cb1-4ef5-a5ae-e0d6119c5202',
          isFolder: true,
          name: 'Combined',
          content: [
            {
              id: '5f1d5e80-0638-4057-be00-254c959528e9',
              isFolder: false,
              name: 'AddToArrayFormOfInteger.java',
              code: 'import java.util.*;\n\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            num[i] += k;\n            k = num[i] / 10;\n            ans.add(0, num[i] % 10);\n        }\n        while (k != 0) {\n            ans.add(0, k % 10);\n            k /= 10;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/add-to-array-form-of-integer',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '7f629480-2842-4737-9cdf-64f92a35ae02',
              isFolder: false,
              name: 'CellWithOddValuesInMatrix.java',
              code: 'public class CellWithOddValuesInMatrix {\n    public int oddCells(int m, int n, int[][] I) {\n        // M = rows, N = cols\n        boolean[] row = new boolean[m];\n        boolean[] col = new boolean[n];\n        int r=0, c=0;\n        for (int i = 0; i < I.length; i++) {\n            row[I[i][0]] ^= true;\n            col[I[i][1]] ^= true;\n        }\n        for (int j = 0; j < n; j++)\n            if (col[j]) c++;\n\n        for (int j = 0; j < m; j++)\n            if (row[j]) r++;\n\n        // r(n-c) + c(m-r)\n        // rn + cm - rc - rc\n        return r*n + c*m - 2*r*c;\n    }\n}',
              link: 'https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '9cd045eb-0443-4825-9ebc-94b2955d9a5c',
              isFolder: false,
              name: 'GoodArray.java',
              code: 'public class GoodArray {\n    public boolean isGoodArray(int[] N) {\n        int ans = N[0];\n        for (int i = 1; i < N.length; i++)\n            ans = GCD(N[i], ans);\n        return ans == 1;\n    }\n    public int GCD(int a, int b) {\n        if (a%b == 0) return b;\n        return GCD(b, a%b);\n    }\n}',
              link: 'https://leetcode.com/problems/check-if-it-is-a-good-array/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '1e230408-2108-4387-8691-e871fa411295',
              isFolder: false,
              name: 'IsStringASubSequence.java',
              code: 'public class IsStringASubSequence {\n    public static boolean check(String s1, String s2) {\n        int i = 0, j = 0;\n        return checkRecursively(s1, s2, i, j);\n\n        // int i = 0, j = 0;\n        // while (i < A.length() && j < B.length()) {\n        //     if (A.charAt(i) == B.charAt(j)) i++;\n        //     j++;\n        // }\n        // return i >= A.length();\n    }\n    public static boolean checkRecursively(String s1, String s2, int i, int j) {\n        if (i >= s1.length()) return true;\n        if (j >= s2.length()) return false;\n        if (s1.charAt(i) == s2.charAt(j)) {\n            return checkRecursively(s1, s2, i+1, j+1);\n        }\n        return checkRecursively(s1, s2, i, j+1);\n    }\n    public static void main(String[] args) {\n        String s1 = "ABCD";\n        String s2 = "ADB";\n        System.out.println(check(s1, s2));\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/check-for-subsequence4930/1',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '28e4a3bd-2eaa-43bd-8450-5596c23f5242',
              isFolder: false,
              name: 'JumpGame.java',
              code: 'public class JumpGame {\n    public boolean canJump(int[] nums) {\n        int n = nums.length - 1;\n        int goal = n;\n        for (int i = n; i >= 0; i--) {\n            if (i + nums[i] >= goal)\n                goal = i;\n        }\n        return goal == 0;\n    }\n}',
              link: 'https://leetcode.com/problems/jump-game/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'a207f64b-2adb-4c1e-bfce-89b6ff1a5f16',
              isFolder: false,
              name: 'LeftMostRepeatingCharacter.java',
              code: "public class LeftMostRepeatingCharacter {\n    public static int indexLeftMostRepeatedCharacter (String str) {\n//        Brute force approach: O(N^2)\n//        Use 2 nested loops to check every character's occurrence it found break loop and return index\n//        for (int i = 0; i < str.length(); i++) {\n//            char ch = str.charAt(i);\n//            for (int j = i+1; j < str.length(); j++) {\n//                if (str.charAt(j) == ch) return i;\n//            }\n//        }\n//        return -1;\n\n//        Better Solution: O(2N)\n//        Uses 1 integer array to store count of all characters in 1 iteration, then in next iteration is count is > 1 that's the index else -1\n//        int[] bucket = new int[26];\n//        for (int i = 0; i < str.length(); i++) {\n//            bucket[str.charAt(i) - 'a']++;\n//        }\n//        for (int j = 0; j < str.length(); j++) {\n//            if (bucket[str.charAt(j) - 'a'] > 1) return j;\n//        }\n//        return -1;\n\n//        Best Solution: O(N)\n//        Use the bucket concept along with a min index value variable that will hold the min possible value of index as I traverse the array\n        int[] bucket = new int[26];\n        int minIdx = Integer.MAX_VALUE;\n        for (int i = str.length() - 1; i >= 0; i--) {\n            int idx = str.charAt(i) - 'a';\n            bucket[idx]++;\n            if (bucket[idx] > 1) {\n                minIdx = i;\n            }\n        }\n        if (minIdx == Integer.MAX_VALUE) return -1;\n        return minIdx;\n    }\n    public static void main(String[] args) {\n//        Only considering lowercase alphabets\n        String s = \"geeksforgeeks\";\n        int ans = indexLeftMostRepeatedCharacter(s);\n        System.out.println(ans);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '5c1a04dc-ff30-4349-93fc-25967c1512ba',
              isFolder: false,
              name: 'LongestOddEvenSubarray.java',
              code: "public class LongestOddEvenSubarray {\n    public static int longestOddEvenCount (int[] arr) {\n//        Brute force\n//        int count = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int c = 1;\n//            for (int j = i+1; j < arr.length; j++) {\n//                if (arr[j]%2 == 0 && arr[j-1]%2!= 0 || arr[j]%2 != 0 && arr[j-1]%2== 0) {\n//                    c++;\n//                } else {\n//                    break;\n//                }\n//            }\n//            count = Math.max(c, count);\n//        }\n//        return count;\n\n//        Optimised: Kadane's algorithm\n        int count = 1;\n        int max = 1;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i]%2 == 0 && arr[i-1]%2!= 0 || arr[i]%2 != 0 && arr[i-1]%2== 0) {\n                count++;\n                max = Math.max(count, max);\n            } else {\n                count = 1;\n            }\n        }\n        return max;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 10, 20, 6, 3, 8};\n        int count = longestOddEvenCount(arr);\n        System.out.println(count);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'd0eb4cce-2537-4306-9f1d-d8c8b958bfb9',
              isFolder: false,
              name: 'MaxCircularSubarraySum.java',
              code: "public class MaxCircularSubarraySum {\n    public static int normalSubarrayMaxSum(int[] arr) {\n        int sum = arr[0];\n        int maxSum = arr[0];\n        int n = arr.length;\n        for (int i = 1; i < n; i++) {\n            sum += arr[i];\n            maxSum = Math.max(sum, maxSum);\n            if (sum < 0) sum = 0;\n        }\n        return maxSum;\n    }\n\n    public static int maxCircularSubarraySum(int[] arr) {\n//        Brute force approach\n//        int n = arr.length;\n//        int sum = arr[0];\n//        for (int i = 0; i < n; i++) {\n//            int curr_sum = arr[i];\n//            int curr_max = arr[i];\n//            for (int j = 1; j < n; j++) {\n//                curr_sum += arr[(i+j)%n];\n//                curr_max = Math.max(curr_sum, curr_max);\n//            }\n//            sum = Math.max(sum, curr_max);\n//        }\n//        return sum;\n\n//        Optimised approach\n        int normalSum = normalSubarrayMaxSum(arr);\n        if (normalSum < 0) return normalSum;\n        int circularSum = arr[0];\n        int sum = arr[0];\n        int wholeSum = arr[0];\n//        We can also invert the array and get normal max sum using same function instead of modifying kadane's algorithm\n//        In that case we add it with wholeSum\n        for (int i = 1; i < arr.length; i++) {\n            wholeSum += arr[i];\n            sum += arr[i];\n            circularSum = Math.min(circularSum, sum);\n            if (sum > 0) sum = 0;\n        }\n        return Math.max(normalSum, wholeSum - circularSum);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-10, -5, -5, -1, -2, -4};\n        int ans = maxCircularSubarraySum(arr);\n        System.out.println(ans);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'aec5bdac-4564-46a8-aa75-d52034b670cb',
              isFolder: false,
              name: 'NumberOfGoodPairs.java',
              code: 'import java.util.*;\n\npublic class NumberOfGoodPairs {\n    public static int numIdenticalPairs(int[] nums) {\n        // O(n) solution\n        int numberOfGoodPairs = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i: nums) {\n            if (hm.containsKey(i)) {\n                numberOfGoodPairs += hm.get(i);\n            }\n            hm.put(i, hm.getOrDefault(i, 0) + 1);\n        }\n        return numberOfGoodPairs;\n\n        // O(n^2) solution\n        // int numberOfGoodPairs = 0;\n        // for (int i=0; i < nums.length -1; i++) {\n        //     for (int j=i+1; j < nums.length; j++) {\n        //         if (nums[i] == nums[j]) {\n        //             numberOfGoodPairs++;\n        //         }\n        //     }\n        // }\n        // return numberOfGoodPairs;\n    }\n}',
              link: 'https://leetcode.com/problems/number-of-good-pairs/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '26c0b5fb-1852-42e6-ad2d-2262429ed8b8',
              isFolder: false,
              name: 'NumbersSmallerThanCurrentNumber.java',
              code: 'public class NumbersSmallerThanCurrentNumber {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] counts = new int[102];\n        for (int num : nums)\n            counts[num]++;\n        for (int j = 1; j < counts.length; j++)\n            counts[j] += counts[j - 1];\n        int[] ans = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0)\n                ans[i] = 0;\n            else\n                ans[i] = counts[nums[i] - 1];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'd134d303-9ad0-4899-b507-f725cc0df5ad',
              isFolder: false,
              name: 'SpiralMatrix3.java',
              code: 'public class SpiralMatrix3 {\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\n        int[] directions = {0, 1, 0, -1, 0};\n        int[][] ans = new int[rows*cols][2];\n        ans[0] = new int[] {rStart, cStart};\n        int len = 0, d = 0, ptr = 1;\n        while (ptr < ans.length) {\n            if (d == 0 || d == 2) len++;\n            for (int i = 0; i < len; i++) {\n                rStart += directions[d];\n                cStart += directions[d+1];\n                if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {\n                    ans[ptr++] = new int[] {rStart, cStart};\n                }\n            }\n            d = ++d%4;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/spiral-matrix-iii/',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: '49c90a44-0d51-434a-aeee-f032fa7f122f',
              isFolder: false,
              name: 'WavePrint.java',
              code: 'import java.util.Arrays;\n\npublic class WavePrint {\n    public static int[] wavePrint(int arr[][], int nRows, int mCols) {\n        // Write your code here.\n        int[] ans = new int[nRows*mCols];\n        int ptr = 0;\n        for (int i = 0; i < mCols; i++) {\n            if ((i&1) == 0) {\n                // TB\n                for (int j = 0; j < nRows; j++) {\n                    ans[ptr++] = arr[j][i];\n                }\n            } else {\n                // BT\n                for (int j = nRows - 1; j >= 0; j--) {\n                    ans[ptr++] = arr[j][i];\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1,2,3,4},\n                {5,6,7,8},\n                {9,10,11,12}\n        };\n        int[] ans = wavePrint(mat, mat.length, mat[0].length);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/print-like-a-wave_893268',
              notes: '',
              tags: ['Arrays'],
            },
            {
              id: 'ca76150b-1ef4-457b-8651-0511da85231b',
              isFolder: false,
              name: 'ArrangingCoins.java',
              code: 'public class ArrangingCoins {\n    public static int arrangeCoins(int n) {\n//        Brute force solution\n//        if (n <= 1) return n;\n//        int i;\n//        for (i = 0; i < n; i++) {\n//            long ans = ((long) i *(i+1))/2;\n//            if (ans > n) break;\n//        }\n//        return i-1;\n\n//        Better solution\n//        long start = 0, end = n;\n//        while (start <= end) {\n//            long mid = start + (end - start)/2;\n//            long val = (mid * (mid+1))/2;\n//            if (val == n) return (int) mid;\n//            if (val > n) {\n//                end = mid - 1;\n//            } else {\n//                start = mid + 1;\n//            }\n//        }\n//        return (int) end;\n\n//        Optimised solution\n//         Equation: k(k+1)/2 = n\n//         k^2 + k = 2*n\n//         k^2 + k + 1/4 = 2*n + 1/4\n//         (k + 1/2)^2 = 2n + 1/4\n//         k = sqrt(2n + 1/4) - 1/2\n        return (int) (Math.sqrt(2L*n + 0.25) - 0.5);\n    }\n\n    public static void main(String[] args) {\n        int ans = arrangeCoins(1804289383);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/arranging-coins/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'f9d39e4c-1b04-41bf-8a6b-eb3ab9f15747',
              isFolder: false,
              name: 'FindRightInterval.java',
              code: 'import java.util.*;\npublic class FindRightInterval {\n    public static int[] findRightInterval(int[][] intervals) {\n        int[][] copy = new int[intervals.length][2];\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            copy[i] = intervals[i];\n            hm.put(intervals[i][0], i);\n        }\n        Arrays.sort(copy, Comparator.comparingInt(a -> a[0]));\n        int[] ans = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            int pos = search(copy, intervals[i][1]);\n            ans[i] = pos == -1 ? pos : hm.get(copy[pos][0]);\n        }\n        return ans;\n    }\n    public static int search(int[][] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid][0] == target) return mid;\n            if (arr[mid][0] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        if (start == arr.length) return -1;\n        return start;\n    }\n}',
              link: 'https://leetcode.com/problems/find-right-interval/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '6f35f7c1-9f08-4eeb-b2b3-5e76143d564c',
              isFolder: false,
              name: 'FrequencyOfMostFrequentElement.java',
              code: 'import java.util.*;\n\npublic class FrequencyOfMostFrequentElement {\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums);\n        int l = 0, r = 0;\n        long maxLen = 1, total = 0;\n        while (r < nums.length) {\n            total += nums[r];\n            while ((long) nums[r] * (r - l + 1) > total + k) {\n                total -= nums[l++];\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n            r++;\n        }\n        return (int) maxLen;\n    }\n}',
              link: 'https://leetcode.com/problems/frequency-of-the-most-frequent-element/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'e11d2145-2676-4c87-afd2-fec1223b26ef',
              isFolder: false,
              name: 'MaxValueAtGivenIndexInBoundedArray.java',
              code: 'public class MaxValueAtGivenIndexInBoundedArray {\n    public long getFormulaSum(int count, long mid) {\n        long c = Math.min(count, mid-1);\n        return c*mid - c*(c+1)/2 + Math.max(count - (mid-1), 0); // Adds extra 1s if any\n    }\n    public int maxValue(int n, int index, int maxSum) {\n        long start = 1;\n        long end = maxSum;\n        long result = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long totalSum = getFormulaSum(index, mid);\n            totalSum += mid;\n            totalSum += getFormulaSum(n-index-1, mid);\n            if (totalSum <= maxSum) {\n                result = mid;\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return (int)result;\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '466a2b0a-4ee0-44ed-8600-b3b14df6a6d7',
              isFolder: false,
              name: 'MinAbsoluteSumDifference.java',
              code: 'import java.util.*;\npublic class MinAbsoluteSumDifference {\n    public int minAbsoluteSumDiff(int[] N, int[] M) {\n        int[] abs = new int[N.length];\n        long maxSum = 0;\n        for (int i = 0; i < N.length; i++) {\n            abs[i] = Math.abs(N[i] - M[i]);\n            maxSum += abs[i];\n        }\n        Arrays.sort(N);\n        int max = 0;\n        for (int j = 0; j < N.length; j++) {\n            int minValue = Math.abs(M[j] - bSearch(N, M[j]));\n            int diff = abs[j] - minValue;\n            max = Math.max(max, diff);\n        }\n        return (int)((maxSum - max) % 1000000007);\n    }\n    public static int bSearch(int[] N, int target){\n        int start = 0, end = N.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (N[mid] == target) return N[mid];\n            if (N[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        if (start == N.length) start--;\n        if (end == -1) end++;\n        int diff1 = Math.abs(target - N[start]);\n        int diff2 = Math.abs(target - N[end]);\n        if (diff1 > diff2) return N[end];\n        return N[start];\n    }\n}',
              link: 'https://leetcode.com/problems/minimum-absolute-sum-difference/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '4001c4a1-9ab8-40a2-8c8e-7cfc47c62c63',
              isFolder: false,
              name: 'ReachANumber.java',
              code: 'public class ReachANumber {\n    public static long formula(long n) {\n        return (n*(n+1))>>1;\n    }\n\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        long start = 1, end = target;\n        int steps = 0;\n        while (start <= end) {\n            long mid = start + (end - start)/2;\n            long distance = formula(mid);\n            if (distance >= target) {\n                steps = (int) mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        long dist = formula(steps) - target;\n        if ((dist&1) != 0) {\n            return steps + ((steps&1) == 0 ? 1 : 2);\n        }\n        return steps;\n    }\n}',
              link: 'https://leetcode.com/problems/reach-a-number/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '5ab12d11-936c-4e00-859a-5e62d54231a9',
              isFolder: false,
              name: 'CousinsInBinaryTree.java',
              code: 'import java.util.*;\npublic class CousinsInBinaryTree {\n    static class Pair {\n        int val, parent, lvl;\n        Pair (int v, int p, int lvl) {\n            this.val = v;\n            this.parent = p;\n            this.lvl = lvl;\n        }\n    }\n    public boolean isCousins(TreeNode root, int x, int y) {\n        if (root.val == x || root.val == y) return false;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        int lvl = 0, idx = 0;\n        Pair[] ans = new Pair[2];\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                if (node.left != null) {\n                    q.add(node.left);\n                    if (node.left.val == x || node.left.val == y) {\n                        ans[idx++] = new Pair(node.left.val, node.val, lvl+1);\n                    }\n                }\n                if (node.right != null) {\n                    q.add(node.right);\n                    if (node.right.val == x || node.right.val == y) {\n                        ans[idx++] = new Pair(node.right.val, node.val, lvl+1);\n                    }\n                }\n            }\n            if (idx == 2) break;\n            lvl++;\n        }\n        return ans[0].parent != ans[1].parent && ans[0].lvl == ans[1].lvl;\n    }\n}',
              link: 'https://leetcode.com/problems/cousins-in-binary-tree/',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '46eba25d-3ef0-451b-8c03-e8b8505c98f8',
              isFolder: false,
              name: 'DiagonalTraversalBT.java',
              code: 'import java.util.*;\npublic class DiagonalTraversalBT {\n    public ArrayList<Integer> diagonal(TreeNode root) {\n        //add your code here.\n        ArrayList<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            TreeNode curr = q.poll();\n            while (curr != null) {\n                ans.add(curr.val);\n                if (curr.left != null) {\n                    q.add(curr.left);\n                }\n                curr = curr.right;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/diagonal-traversal-of-binary-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '7e6cfb95-1706-42f8-8eb3-cba73f563481',
              isFolder: false,
              name: 'KSumPaths.java',
              code: 'import java.util.*;\npublic class KSumPaths {\n    void solve(int sum, TreeNode root, int k, HashMap<Integer, Integer> hm, int[] count) {\n        if (root == null) return;\n        sum += root.val;\n        if (hm.containsKey(sum - k)) {\n            count[0] += hm.get(sum - k);\n        }\n        hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n        solve(sum, root.left, k, hm, count);\n        solve(sum, root.right, k, hm, count);\n        hm.put(sum, hm.get(sum) - 1);\n    }\n    public int sumK(TreeNode root,int k) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        int[] count = new int[1];\n        solve(0, root, k, hm, count);\n        return count[0];\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/k-sum-paths/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '3e051812-e07e-4e0a-acaa-316d56235bd0',
              isFolder: false,
              name: 'KthAncestorInBinaryTree.java',
              code: 'import java.util.*;\npublic class KthAncestorInBinaryTree {\n    public boolean solve(TreeNode root, int node, List<Integer> temp) {\n        if (root == null) return false;\n        temp.add(root.val);\n        if (root.val == node || solve(root.left, node, temp) || solve(root.right, node, temp)) return true;\n        temp.remove(temp.size() - 1);\n        return false;\n    }\n    public int kthAncestor(TreeNode root, int k, int node) {\n        List<Integer> temp = new ArrayList<>();\n        if (!solve(root, node, temp) || k > temp.size() - 1 || root.val == node)\n            return -1;\n        return temp.get(temp.size() - k - 1);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/kth-ancestor-in-a-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '74ed658b-2fd2-4824-9e7b-08618e542fa1',
              isFolder: false,
              name: 'LongestPathRootToLeafSum.java',
              code: 'public class LongestPathRootToLeafSum {\n    public static void solve(TreeNode root, int[] ans, int sum, int length) {\n        if (root == null) {\n            if (length > ans[1]) {\n                ans[1] = length;\n                ans[0] = sum;\n            } else if (length == ans[1]) {\n                ans[0] = Math.max(sum, ans[0]);\n            }\n            return;\n        }\n        solve(root.left, ans, sum + root.val, length + 1);\n        solve(root.right, ans, sum + root.val, length + 1);\n    }\n    public int sumOfLongRootToLeafPath(TreeNode root) {\n        //code here\n        // { maxSum, maxLength }\n        int[] ans = new int[2];\n        solve(root, ans, 0, 0);\n        return ans[0];\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/sum-of-the-longest-bloodline-of-a-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '63715d13-5423-4f9b-a093-314b33cbd0c0',
              isFolder: false,
              name: 'MaximumSumOfNonAdjacentNodes.java',
              code: 'public class MaximumSumOfNonAdjacentNodes {\n    static class Pair {\n        int f, s;\n\n        Pair(int f, int s) {\n            this.f = f;\n            this.s = s;\n        }\n    }\n\n    //Function to return the maximum sum of non-adjacent nodes.\n    static Pair solve(TreeNode root) {\n        if (root == null) {\n            return new Pair(0, 0);\n        }\n        Pair l = solve(root.left);\n        Pair r = solve(root.right);\n        int first = root.val + l.s + r.s;\n        int second = Math.max(l.f, l.s) + Math.max(r.f, r.s);\n        return new Pair(first, second);\n    }\n\n    static int getMaxSum(TreeNode root) {\n        // add your code here\n        // Pair(include, exclude)\n        Pair p = solve(root);\n        return Math.max(p.f, p.s);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/maximum-sum-of-non-adjacent-nodes/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '6bb48d22-f8cc-4430-af83-16679fc9af7f',
              isFolder: false,
              name: 'PopulatingNextRightPointersInEachNode.java',
              code: 'import java.util.*;\n\npublic class PopulatingNextRightPointersInEachNode {\n    // Definition for a Node.\n    public static class Node {\n        public int val;\n        public Node left;\n        public Node right;\n        public Node next;\n\n        public Node() {}\n\n        public Node(int _val) {\n            val = _val;\n        }\n\n        public Node(int _val, Node _left, Node _right, Node _next) {\n            val = _val;\n            left = _left;\n            right = _right;\n            next = _next;\n        }\n    };\n    public Node connect(Node root) {\n        if (root == null) return null;\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Node node = q.poll();\n                if (!q.isEmpty() && i != size - 1) {\n                    node.next = q.peek();\n                }\n                if (node.left != null) q.add(node.left);\n                if (node.right != null) q.add(node.right);\n            }\n        }\n        return root;\n    }\n}',
              link: 'https://leetcode.com/problems/populating-next-right-pointers-in-each-node/',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: 'b8c00c39-b777-42bd-961b-f4c6b73b0892',
              isFolder: false,
              name: 'SumAtKLevel.java',
              code: 'import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class SumAtKLevel {\n    public static int sumAtKLevel(TreeNode root, int k) {\n        Queue<TreeNode> q = new LinkedList<>();\n        int sum = 0;\n        int lvl = 0;\n        q.add(root);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode temp = q.poll();\n                if (temp != null) {\n                    if (lvl == k) {\n                        sum += temp.val;\n                    }\n                    if (temp.left != null) q.add(temp.left);\n                    if (temp.right != null) q.add(temp.right);\n                }\n            }\n            lvl++;\n        }\n        return sum;\n    }\n\n//    public static void main(String[] args) {\n////        Tree building\n//        BinarySearchTree tree = new BinarySearchTree();\n//        int[] input = {7, 3, 5, 11, 17, 1, 8};\n//        for (int j : input) tree.insert(j);\n//        int k = 0;\n//        int ans = sumAtKLevel(tree.buildTree(), k);\n//        System.out.println(ans);\n//    }\n}',
              link: null,
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '2a2edc6b-caf3-4fd7-8761-9b55e2070fea',
              isFolder: false,
              name: 'SumTree.java',
              code: 'public class SumTree {\n    int solve(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return root.val;\n        int l = solve(root.left);\n        int r = solve(root.right);\n        if (l == - 1 || r == - 1 || root.val != (l + r)) return -1;\n        return l + r + root.val;\n    }\n    boolean isSumTree(TreeNode root) {\n        return solve(root) != -1;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/problems/sum-tree/1',
              notes: '',
              tags: ['Binary Trees'],
            },
            {
              id: '307d73dd-93d6-4cab-8342-28084d6615bc',
              isFolder: false,
              name: 'KClosestNumbers.java',
              code: 'import java.util.*;\n\npublic class KClosestNumbers {\n    static class Pair {\n        int val;\n        int key;\n        Pair(int v, int k) {\n            this.val = v;\n            this.key = k;\n        }\n    }\n\n    public static List<Integer> findClosestElements(int[] arr, int k, int x) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.key == a.key ? b.val - a.val : b.key - a.key);\n        for (int num : arr) {\n            pq.add(new Pair(num, Math.abs(x - num)));\n            if (pq.size() > k) pq.poll();\n        }\n        List<Integer> ans = new ArrayList<>();\n        while (!pq.isEmpty()) ans.add(pq.poll().val);\n        Collections.sort(ans);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int k = 4, x = 3;\n        List<Integer> ans = findClosestElements(arr, k, x);\n        System.out.println("Final: " + ans);\n    }\n}',
              link: 'https://leetcode.com/problems/find-k-closest-elements/',
              notes: '',
              tags: ['Heaps'],
            },
            {
              id: 'b644b781-3626-4232-af0d-c9356a91542f',
              isFolder: false,
              name: 'KClosestPointsToOrigin.java',
              code: 'import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class KClosestPointsToOrigin {\n    static class Pair {\n        int key;\n        int x, y;\n\n        Pair(int coor_x, int coor_y, int k) {\n            this.key = k;\n            this.x = coor_x;\n            this.y = coor_y;\n        }\n    }\n\n    public static int[][] kClosest(int[][] points, int k) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.key - a.key);\n        for (int[] point : points) {\n            int x = point[0];\n            int y = point[1];\n            pq.add(new Pair(x, y, x * x + y * y));\n            if (pq.size() > k) pq.poll();\n        }\n        int[][] ans = new int[pq.size()][2];\n        int idx = 0;\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            ans[idx++] = new int[]{p.x, p.y};\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] points = {{3, 3}, {5, -1}, {-2, 4}};\n        int k = 2;\n        int[][] ans = kClosest(points, k);\n        for (int[] arr : ans) {\n            System.out.println(Arrays.toString(arr));\n        }\n    }\n}',
              link: null,
              notes: '',
              tags: ['Heaps'],
            },
            {
              id: 'ee12962a-6fde-42f6-afb6-dbfcb91f521d',
              isFolder: false,
              name: 'SquareRootWithPrecision.java',
              code: 'public class SquareRootWithPrecision {\n    public static int sqrt(int n) {\n        int start = 0, end = n;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            int root = mid * mid;\n            if (root == n) return mid;\n            if (root > n)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int getClosestSqrt(double n, int val, int num) {\n        int start = 0, end = 9;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            double x = n + mid / (double) val;\n            double root = x * x;\n            if (root < num)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return end;\n    }\n\n    public static double getSquareRootWithPrecision(int n, int p) {\n        double num = sqrt(n);\n        int increment = 10;\n        for (int i = 0; i < p; i++) {\n            int x = getClosestSqrt(num, increment, n); // log10\n            num += (double) x / increment;\n            increment *= 10;\n        }\n        return num;\n    }\n\n    public static void main(String[] args) {\n        int n = 40;\n        int p = 3;\n        double ans = getSquareRootWithPrecision(n, p);\n        System.out.printf("%.{%d}f", p, ans);\n    }\n}',
              link: 'https://www.geeksforgeeks.org/find-square-root-number-upto-given-precision-using-binary-search/',
              notes: '',
              tags: ['Maths'],
            },
            {
              id: 'be8968ea-a072-4f16-861d-1ea1ac1128f8',
              isFolder: false,
              name: 'XorOfRange.java',
              code: 'public class XorOfRange {\n    public static void main(String[] args) {\n        int n = 9;\n        int ans1 = computeXor(n);\n        int ans2 = computeXorEfficient(n);\n        System.out.println(ans1 + "  " + ans2);\n    }\n\n    static int computeXor(int n) {\n        if (n == 0) return 0;\n        int uni = 0;\n        for (int i = 1; i <= n; i++) {\n            uni = uni ^ i;\n        }\n        return uni;\n    }\n\n    static int computeXorEfficient(int n) {\n        int rem = n % 4;\n        switch (rem) {\n            case 0 -> {\n                return n;\n            }\n            case 1 -> {\n                return 1;\n            }\n            case 2 -> {\n                return n + 1;\n            }\n        }\n        return 0;\n    }\n}',
              link: 'https://www.geeksforgeeks.org/find-xor-of-numbers-from-the-range-l-r/',
              notes: '',
              tags: ['Maths'],
            },
            {
              id: 'ede47373-9c8f-4635-9d0c-392a1e225890',
              isFolder: false,
              name: 'CircularTour.java',
              code: 'public class CircularTour {\n    int tour(int[] petrol, int[] distance) {\n        // Your code here\n        int start = 0, b = 0, d = 0;\n        for (int i = 0; i < petrol.length; i++) {\n            b += petrol[i] - distance[i];\n            if (b < 0) {\n                d += b;\n                start = i + 1;\n                b = 0;\n            }\n        }\n        return b + d > 0 ? start : -1;\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/circular-tour-1587115620/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '7521fcab-6682-40e4-aefa-19b73a1ba7f3',
              isFolder: false,
              name: 'FirstNonRepeatingCharacterInAStream.java',
              code: "import java.util.*;\npublic class FirstNonRepeatingCharacterInAStream {\n    public String FirstNonRepeating(String A) {\n        // code here\n        StringBuilder sb = new StringBuilder();\n        Queue<Character> q = new LinkedList<>();\n        int[] bucket = new int[26];\n        for (int i = 0; i < A.length(); i++) {\n            char ch = A.charAt(i);\n            q.offer(ch);\n            bucket[ch - 'a']++;\n            while (!q.isEmpty() && bucket[q.peek() - 'a'] > 1) q.poll();\n            sb.append(q.isEmpty() ? '#' : q.peek());\n        }\n        return sb.toString();\n    }\n}",
              link: 'https://practice.geeksforgeeks.org/problems/first-non-repeating-character-in-a-stream1216/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: 'e98fa827-e125-4fc9-8134-f03e50659a13',
              isFolder: false,
              name: 'NegativeNumberInWindowOfSizeK.java',
              code: 'import java.util.*;\npublic class NegativeNumberInWindowOfSizeK {\n    public long[] printFirstNegativeInteger(long A[], int N, int k) {\n        Queue<Integer> q = new LinkedList<>();\n        long[] ans = new long[N - k + 1];\n        int i = 0;\n        for (int j = 0; j < N; j++) {\n            if (A[j] < 0) q.offer(j);\n            if (j - i + 1 == k) {\n                if (!q.isEmpty() && q.peek() < i) q.poll();\n                ans[i] = q.isEmpty() ? 0 : A[q.peek()];\n                i++;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/first-negative-integer-in-every-window-of-size-k3345/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '92851d09-d011-46d9-aa80-46ae5dce558c',
              isFolder: false,
              name: 'ReverseFirstKElementsOfQueue.java',
              code: 'import java.util.*;\npublic class ReverseFirstKElementsOfQueue {\n    public Queue<Integer> modifyQueue(Queue<Integer> q, int k) {\n        // add code here.\n        Stack<Integer> st = new Stack<>();\n        // k = k % q.size();\n        for (int i = 0; i < k; i++) st.push(q.poll());\n        while (!st.isEmpty()) q.offer(st.pop());\n        int n = q.size();\n        for (int i = 0; i < n - k; i++) q.offer(q.poll());\n        return q;\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/reverse-first-k-elements-of-queue/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '1e49303c-9173-46b5-bb21-c3ee2da04753',
              isFolder: false,
              name: 'ReverseQueue.java',
              code: 'import java.util.*;\n\npublic class ReverseQueue {\n    //Function to reverse the queue. (Did it with recursion as well but stackoverflow)\n    public Queue<Integer> rev(Queue<Integer> q){\n        //add code here.\n        Stack<Integer> st = new Stack<>();\n        while (!q.isEmpty()) st.push(q.poll());\n        while (!st.isEmpty()) q.offer(st.pop());\n        return q;\n    }\n\n    public static void main(String[] args) {\n        Queue<Integer> q = new LinkedList<>();\n\n    }\n}',
              link: 'https://practice.geeksforgeeks.org/problems/queue-reversal/1',
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '03a28d65-4c4c-4361-84f6-57dc446b8e11',
              isFolder: false,
              name: 'SlidingWindowMaximum.java',
              code: 'import java.util.*;\n\npublic class SlidingWindowMaximum {\n    public static int[] maxInEachWindow(int[] arr, int k) {\n        int n = arr.length;\n        int[] ans = new int[n - k + 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        int i = 0;\n        for (int j = 0; j < n; j++) {\n            if (!dq.isEmpty() && i > dq.peekFirst()) dq.pollFirst();\n            while (!dq.isEmpty() && arr[j] > arr[dq.peekLast()]) dq.pollLast();\n            dq.offerLast(j);\n            if (j - i + 1 == k) {\n                ans[i++] = arr[dq.peekFirst()];\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 8, 5, 12, 15, 7, 6};\n        int k = 3;\n        int[] ans = maxInEachWindow(arr, k);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Queue'],
            },
            {
              id: '026ea1f5-e1f1-423f-8311-cfe537c9180e',
              isFolder: false,
              name: 'SumMinMaxElementsSubarraysSizeK.java',
              code: 'import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class SumMinMaxElementsSubarraysSizeK {\n    public static int SumOfKsubArray(int[] arr, int k) {\n        int n = arr.length;\n        int ans = 0;\n        Deque<Integer> dq1 = new ArrayDeque<>();\n        Deque<Integer> dq2 = new ArrayDeque<>();\n        int i = 0;\n        for (int j = 0; j < n; j++) {\n            if (!dq1.isEmpty() && i > dq1.peekFirst()) dq1.pollFirst();\n            if (!dq2.isEmpty() && i > dq2.peekFirst()) dq2.pollFirst();\n            while (!dq1.isEmpty() && arr[j] < arr[dq1.peekLast()]) dq1.pollLast();\n            while (!dq2.isEmpty() && arr[j] > arr[dq2.peekLast()]) dq2.pollLast();\n            dq1.offerLast(j);\n            dq2.offerLast(j);\n            if (j - i + 1 == k) {\n                ans += arr[dq1.peekFirst()];\n                ans += arr[dq2.peekFirst()];\n                i++;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 5, -1, 7, -3, -1, -2};\n        int k = 3;\n        int ans = SumOfKsubArray(arr, k);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Queue'],
            },
            {
              id: 'ccde4168-3029-40fe-a77e-04feca16d21f',
              isFolder: false,
              name: 'Fibo.java',
              code: 'public class Fibo {\n    public static long fibo(int n, long[] temp) {\n        if (n <= 1) return n;\n        if (temp[n] != 0) return temp[n];\n        temp[n] = fibo(n-1, temp) + fibo(n-2, temp);\n        return temp[n];\n    }\n    // Optimised\n    public static long getFibo2(int n) {\n        long[] arr = new long[n + 1];\n        arr[1] = 1;\n        return fibo(n, arr);\n    }\n\n    // slow\n    public static long getFibo(int n) {\n        if (n <= 1) return n;\n        return getFibo(n-1) + getFibo(n-2);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'b1cd4f06-07e0-4bfa-befb-b8368cce695e',
              isFolder: false,
              name: 'LetterCombinationsOfPhoneNumber.java',
              code: 'import java.util.*;\npublic class LetterCombinationsOfPhoneNumber {\n    public List<String> letterCombinations(String digs) {\n        List<String> ans = new ArrayList<>();\n        if (digs.length() == 0) return ans;\n        StringBuilder sb = new StringBuilder();\n        String[] mappings = {"", "", "abc", "def", "ghi", "jkl","mno","pqrs","tuv","wxyz"};\n        solve(mappings, digs, ans, sb, 0);\n        return ans;\n    }\n    public static void solve(String[] mappings, String digs, List<String> ans, StringBuilder sb, int idx) {\n        // Base case\n        if (idx >= digs.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        // Get index\n        int index = digs.charAt(idx) - \'0\';\n        String val = mappings[index];\n        // Get all letters from mapping[index]\n        for (int i = 0; i < val.length(); i++) {\n            sb.append(val.charAt(i));\n            solve(mappings, digs, ans, sb, idx + 1);\n            sb.replace(sb.length() - 1, sb.length(), "");\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '59046f1e-7297-4b9c-9808-c2ed7d2136d2',
              isFolder: false,
              name: 'MatrixFindPaths.java',
              code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MatrixFindPaths {\n    //    Given a n x m matrix, you are only allowed to move right and down direction\n//    find the of paths to reach the corner right of the matrix\n    public static void findPaths(int m, int n, int i, int j, List<String> paths, String path) {\n        if (i >= m || j >= n) return;\n        if (i == m - 1 && j == n - 1) {\n            paths.add(path);\n            return;\n        }\n        findPaths(m, n, i, j+1, paths, path+"R");\n        findPaths(m, n, i+1, j, paths, path + "D");\n    }\n\n    public static void main(String[] args) {\n        List<String> ans = new ArrayList<>();\n        findPaths(3, 2, 0, 0, ans, "");\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'd5a70bdc-359f-4677-ac74-21843c080f0e',
              isFolder: false,
              name: 'NKnightsProblem.java',
              code: "import java.util.Arrays;\n\npublic class NKnightsProblem {\n    static boolean isPossible(char[][] board, int row, int col) {\n//        Coordinates\n        int[][] coordinates = {\n                {col - 2, row - 1},\n                {col - 1, row - 2},\n                {col + 1, row - 2},\n                {col + 2, row - 1},\n                {col + 2, row + 1},\n                {col + 1, row + 2},\n                {col - 1, row + 2},\n                {col - 2, row + 1},\n        };\n        for (int[] coordinate : coordinates) {\n            int r = coordinate[1], c = coordinate[0];\n            if (r >= 0 && c >= 0 && r < board.length && c < board.length)\n                if (board[r][c] == 'K') return false;\n        }\n        return true;\n    }\n\n    static void solve(char[][] board, int col) {\n        if (col == board.length) {\n            for (char[] chars : board)\n                System.out.println(Arrays.toString(chars));\n            System.out.println();\n            return;\n        }\n        for (int row = 0; row < board.length; row++) {\n            if (isPossible(board, row, col)) {\n                board[row][col] = 'K';\n                solve(board, col + 1);\n                board[row][col] = '0';\n            }\n        }\n\n    }\n\n    public static void nKnights(int n, char[][] board) {\n        solve(board, 0);\n    }\n\n    public static void main(String[] args) {\n        int n = 1;\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], '0');\n        }\n        nKnights(n, board);\n    }\n}",
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '119e56b2-26f8-4f5b-9806-ca9ebe117ffd',
              isFolder: false,
              name: 'Permutations.java',
              code: 'import java.util.*;\npublic class Permutations {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int idx) {\n        // Base case\n        if (idx >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n\n        for (int i = idx; i < nums.length; i++) {\n            op.add(nums[i]);\n            swap(nums, idx, i);\n            solve(nums, ans, op, idx + 1);\n            swap(nums, idx, i);\n            op.remove(op.size() - 1);\n        }\n    }\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}',
              link: 'https://leetcode.com/problems/permutations/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'e7fda4e6-c013-492d-abb3-105ee288fe5d',
              isFolder: false,
              name: 'PermutationsOfString.java',
              code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsOfString {\n    public static void swap(StringBuilder s, int i, int j) {\n        char temp = s.charAt(i);\n        s.setCharAt(i, s.charAt(j));\n        s.setCharAt(j, temp);\n    }\n    public static void getPermutations(StringBuilder s, List<String> ans, int idx) {\n        if (idx == s.length()) {\n            ans.add(s.toString());\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            swap(s, idx, i);\n            getPermutations(s, ans, idx + 1);\n            swap(s, idx, i);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<String> ans = new ArrayList<>();\n        StringBuilder s = new StringBuilder("ABC");\n        getPermutations(s, ans, 0);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '63abec68-9b69-42a4-afb4-746bf9a3c9f7',
              isFolder: false,
              name: 'RopeCuttingProblem.java',
              code: 'public class RopeCuttingProblem {\n    public static int maxCuts(int n, int a, int b, int c, int count) {\n//        Base case\n        if (n == 0) return count;\n        if (n < 0) return -1;\n        int aCut = maxCuts(n - a, a, b, c, count + 1);\n        int bCut = maxCuts(n - b, a, b, c, count + 1);\n        int cCut = maxCuts(n - c, a, b, c, count + 1);\n        return Math.max(aCut, Math.max(bCut, cCut));\n    }\n\n    public static void main(String[] args) {\n        int ans = maxCuts(9,2,2,2, 0);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '6a20ce64-410e-4fae-95ee-f1a1a015734d',
              isFolder: false,
              name: 'SubsequencesOfString.java',
              code: 'import java.util.*;\n// This is the same question as power set but the solution is using recursion\npublic class SubsequencesOfString {\n    public static void getSubsequences(String str, ArrayList<String> ans, StringBuilder sb, int index) {\n        if (index >= str.length()) {\n            if (sb.length() != 0) {\n                ans.add(sb.toString());\n            }\n            return;\n        }\n//        Exclude\n        getSubsequences(str, ans, sb, index+1);\n//        Include\n        sb.append(str.charAt(index));\n        getSubsequences(str, ans, sb, index+1);\n        sb.replace(sb.length() - 1, sb.length(),"");\n    }\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getSubsequences(str, ans, sb, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences("abc");\n        System.out.println(ans);\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/subsequences-of-string_985087',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'b7dbca7f-b707-44bb-afa0-82011d85cf1a',
              isFolder: false,
              name: 'SubsetDuplicate.java',
              code: 'import java.util.*;\n\npublic class SubsetDuplicate {\n\n    public static void solve(int[] arr, List<List<Integer>> ans) {\n        ans.add(new ArrayList<>());\n        for (int i = 0; i < arr.length; i++) {\n            int n = ans.size();\n            int start = 0;\n            if (i > 0 && arr[i] == arr[i-1]) {\n                start = n/2;\n            }\n            for (int j = start; j < n; j++) {\n                List<Integer> list = new ArrayList<>(ans.get(j));\n                list.add(arr[i]);\n                ans.add(list);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2};\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, ans);\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '32c9c479-b093-453a-b7d4-335acb43ae33',
              isFolder: false,
              name: 'Subsets.java',
              code: 'import java.util.*;\n\npublic class Subsets {\n    public static void solve(int[] nums, List<List<Integer>> ans, List<Integer> op, int index) {\n        if (index >= nums.length) {\n            ans.add(new ArrayList<>(op));\n            return;\n        }\n//        Exclude\n        solve(nums, ans, op, index+1);\n//        Include\n        op.add(nums[index]);\n        solve(nums, ans, op, index+1);\n        op.remove(op.size() - 1);\n    }\n    public static List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        List<Integer> op = new ArrayList<>();\n        solve(nums, ans, op, 0);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1,2,3};\n        List<List<Integer>> ans =  subsets(nums);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: 'cda9acae-0d7e-46a2-bf5c-037274b6676e',
              isFolder: false,
              name: 'TowerOfHanoi.java',
              code: 'import java.util.*;\n\npublic class TowerOfHanoi {\n    public static void towerOfHanoi(int n, String src, String helper, String dest) {\n        if (n == 1) {\n            System.out.println("Transferring " + n + " from: " + src + " to: " + dest);\n            return;\n        }\n        towerOfHanoi(n-1, src,  dest, helper);\n        System.out.println("Transferring " + n + " from: " + src + " to: " + dest);\n        towerOfHanoi(n-1, helper, src, dest);\n    }\n\n    public static void solve(int n, int src, int helper, int dest, ArrayList<ArrayList<Integer>> ans) {\n        if (n == 1) {\n            ans.add(new ArrayList<>(Arrays.asList(src, dest)));\n            return;\n        }\n        solve(n - 1, src, helper, dest, ans);\n        ans.add(new ArrayList<>(Arrays.asList(src, dest)));\n        solve(n - 1, helper, src, dest, ans);\n    }\n    public static void main(String[] args) {\n        towerOfHanoi(3, "S", "h", "D");\n    }\n}',
              link: null,
              notes: '',
              tags: ['Recursion'],
            },
            {
              id: '706aa3be-3ba6-495c-8f50-f12ccce66aaa',
              isFolder: false,
              name: 'CountOccuranceOfAnagrams.java',
              code: 'import java.util.HashMap;\n\npublic class CountOccuranceOfAnagrams {\n    public static int search(String pat, String txt) {\n        // code here\n        HashMap<Character, Integer> map = new HashMap<>();\n        int count = 0;\n        for (int i = 0; i < txt.length(); i++) {\n            char ch = txt.charAt(i);\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n        }\n        int uniqueCount = map.size();\n        int i = 0, j = 0, k = txt.length();\n        while (j < pat.length()) {\n            char ch = pat.charAt(j);\n            if (map.containsKey(ch)) {\n                int c = map.get(ch);\n                map.put(ch, c - 1);\n                if (c == 1) uniqueCount--;\n            }\n            if (j - i + 1 < k) j++;\n            else if (j - i + 1 == k) {\n                if (uniqueCount == 0) count++;\n                char ch2 = pat.charAt(i);\n                if (map.containsKey(ch2)) {\n                    int c2 = map.get(ch2);\n                    map.put(ch2, c2 + 1);\n                    if (c2 == 0) uniqueCount++;\n                }\n                i++;\n                j++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String pat = "aabaabaa";\n        String txt = "aaba";\n        System.out.println(search(pat, txt));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Sliding Window'],
            },
            {
              id: '6d263edf-a01b-4c90-bc87-9499c55ddce9',
              isFolder: false,
              name: 'AssignCookies.java',
              code: 'import java.util.Arrays;\n\npublic class AssignCookies {\n    public static int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int gLast = g.length - 1;\n        int sLast = s.length - 1;\n        int count = 0;\n        while (gLast >= 0 && sLast >= 0) {\n            if (g[gLast] <= s[sLast]) {\n                gLast--;\n                sLast--;\n                count++;\n            } else {\n                gLast--;\n            }\n        }\n        return count;\n    }\n}',
              link: 'https://leetcode.com/problems/assign-cookies/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'f1a4e208-a0fc-401f-b027-21176f8ac89c',
              isFolder: false,
              name: 'CanMakeAPFromSequence.java',
              code: 'public class CanMakeAPFromSequence {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    public static boolean canMakeArithmeticProgression(int[] arr) {\n//        Brute force\n//         Arrays.sort(arr);\n//         int diff = arr[1] - arr[0];\n//         for (int i = 1; i < arr.length; i++) {\n//             if (arr[i] - arr[i-1] != diff) return false;\n//         }\n//         return true;\n\n//        Optimal solution\n        int min = Integer.MAX_VALUE, max =Integer.MIN_VALUE;\n        for (int num: arr){\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        int n = arr.length;\n//        If difference is not perfectly divisible then return false\n        if ((max - min) % (n - 1) != 0) return false;\n//        To get the difference between any 2 element in a AP\n        int diff = (max - min) / (n - 1);\n        int i = 0;\n        while (i < n) {\n            if (arr[i] == min + i*diff) i++;\n            else if ((arr[i] - min)%diff != 0) return false;\n            else {\n                int j = (arr[i] - min)/diff;\n                if (arr[i] == arr[j]) return false;\n                swap(arr, i, j);\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13, 12, -12, 9, 9, 16, 7, -10, -20, 0, 18, -1, -20, -10, -8, 15, 15, 16, 2, 15};\n        System.out.println(canMakeArithmeticProgression(arr));\n    }\n}',
              link: 'https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'd4e96dce-36ed-49e6-96d3-b3e9bc26e2b7',
              isFolder: false,
              name: 'InsertionSortList.java',
              code: 'public class InsertionSortList {\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) {\n            this.val = val;\n        }\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n    public static ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null)  return head;\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = head;\n        ListNode curr = head.next;\n        while (curr != null) {\n            if (curr.val >= prev.val) {\n                prev = curr;\n                curr = curr.next;\n                continue;\n            }\n            ListNode temp = dummy;\n            while (curr.val > temp.next.val) {\n                temp = temp.next;\n            }\n            prev.next = curr.next;\n            curr.next = temp.next;\n            temp.next = curr;\n            curr = prev.next;\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = insertionSortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + " => ");\n            temp = temp.next;\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/insertion-sort-list',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '6787ee10-308d-48b2-bd8a-830dd91e5746',
              isFolder: false,
              name: 'LargestNumber.java',
              code: 'import java.util.*;\npublic class LargestNumber {\n    public String largestNumber(int[] nums) {\n        Comparator<String> comp = (i, j) -> (j+i).compareTo(i+j);\n        List<String> list = new ArrayList<>();\n        for (int num : nums) {\n            list.add(String.valueOf(num));\n        }\n        list.sort(comp);\n        StringBuilder sb = new StringBuilder();\n        for (String l : list) {\n            sb.append(l);\n        }\n        return String.valueOf(Integer.parseInt(String.valueOf(sb)));\n    }\n\n}',
              link: 'https://leetcode.com/problems/largest-number/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'b67b3580-27e1-4054-aa85-0f826041153d',
              isFolder: false,
              name: 'MaxProductOfTwoElementsInAnArray.java',
              code: 'public class MaxProductOfTwoElementsInAnArray {\n    public int maxProduct(int[] nums) {\n        int f = 0, s = 0;\n        for (int num : nums) {\n            if (num > f) {\n                s = f;\n                f = num;\n            } else if (num > s) {\n                s = num;\n            }\n        }\n        return (f-1)*(s-1);\n    }\n}',
              link: 'https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'e3ebe23b-2bd0-437a-af2a-a2199fbe3ec7',
              isFolder: false,
              name: 'RankTransformOfAnArray.java',
              code: 'import java.util.*;\n\npublic class RankTransformOfAnArray {\n    public int[] arrayRankTransform(int[] arr) {\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n        int[] h = arr.clone();\n        Arrays.sort(h);\n        int rank = 1;\n        for (int i = 0; i < h.length; i++) {\n            if (!hm.containsKey(h[i])) {\n                hm.put(h[i], rank++);\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            h[i] = hm.get(arr[i]);\n        }\n        return h;\n    }\n}',
              link: 'https://leetcode.com/problems/rank-transform-of-an-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'bcb32783-90e3-4618-a273-7ac42d6e2aa9',
              isFolder: false,
              name: 'RelativeSortArray.java',
              code: 'import java.util.Arrays;\n\npublic class RelativeSortArray {\n    public static int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] count = new int[1001];\n        int totalCount = arr1.length;\n        for (int i : arr1) {\n            count[i]++;\n        }\n        int j = 0;\n        for (int k : arr2) {\n            while (count[k] != 0) {\n                arr1[j++] = k;\n                count[k]--;\n                totalCount--;\n            }\n        }\n        if (totalCount != 0) {\n            for (int i = 0; i < 1001; i++) {\n                while (count[i] != 0) {\n                    arr1[j++] = i;\n                    count[i]--;\n                }\n            }\n        }\n        return arr1;\n    }\n    public static void main(String[] args) {\n//        Input:\n        int[] arr1 = {2,3,1,3,2,4,6,7,9,2,19};\n        int[] arr2 = {2,1,4,3,9,6};\n        int[] ans = relativeSortArray(arr1, arr2);\n        System.out.println(Arrays.toString(ans));\n//        Output: [2,2,2,1,4,3,3,9,6,7,19]\n    }\n}',
              link: 'https://leetcode.com/problems/relative-sort-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '5fadd31c-b01f-4f79-b3c5-5cdf074032df',
              isFolder: false,
              name: 'SortArrayByIncreasingFrequency.java',
              code: 'import java.util.*;\npublic class SortArrayByIncreasingFrequency {\n    public static int[] frequencySort(int[] nums) {\n        // Count the frequency of each number\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        // Sort the unique numbers by frequency and then by value\n        List<Integer> numList = new ArrayList<>(hm.keySet());\n        numList.sort((a, b) -> {\n            int freqCompare = Integer.compare(hm.get(a), hm.get(b));\n            return (freqCompare != 0) ? freqCompare : Integer.compare(b, a);\n        });\n        // Populate the sorted result array -> O(n) operation\n        int index = 0;\n        for (int num : numList) {\n            int freq = hm.get(num);\n            for (int i = 0; i < freq; i++) {\n                nums[index++] = num;\n            }\n        }\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-1,1,-6,4,5,-6,1,4,1};\n        int[] ans = frequencySort(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/sort-array-by-increasing-frequency/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'b7daa485-e2f1-4c66-90d0-7c3722d162a9',
              isFolder: false,
              name: 'SortIntegersByNumberOf1Bits.java',
              code: 'import java.util.*;\n\npublic class SortIntegersByNumberOf1Bits {\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int compare(int a, int b) {\n        int aBits = Integer.bitCount(a);\n        int bBits = Integer.bitCount(b);\n        if (aBits != bBits) return aBits - bBits;\n        return a - b;\n    }\n\n    public static void mergeSort(int[] arr, int low, int high) {\n        if (low == high) return;\n        int mid = low + (high - low)/2;\n        mergeSort(arr, low, mid);\n        mergeSort(arr, mid+1, high);\n        merge(arr, low, mid, high);\n    }\n\n    public static void merge(int[] arr, int low, int mid, int high) {\n        int[] temp = new int[high - low + 1];\n        int i = 0, left = low, right = mid+1;\n        while (left <= mid && right <= high) {\n            if (compare(arr[left], arr[right]) > 0)\n                temp[i++] = arr[right++];\n            else\n                temp[i++] = arr[left++];\n        }\n        while (left <= mid) temp[i++] = arr[left++];\n        while (right <= high) temp[i++] = arr[right++];\n\n        for (int j = 0; j < temp.length; j++)\n            arr[j+low] = temp[j];\n    }\n\n    public static int[] sortByBits(int[] arr) {\n//        Brute force solution\n//        int n = arr.length - 1;\n//        for (int i = 0; i < n; i++) {\n//            boolean swapped = false;\n//            for (int j = 0; j < n - i; j++) {\n//                if (compare(arr[j], arr[j + 1]) > 0) {\n//                    swap(arr, j, j + 1);\n//                    swapped = true;\n//                }\n//            }\n//            if (!swapped) break;\n//        }\n//        return arr;\n\n//        Better solution\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] += Integer.bitCount(arr[i]) * 10001;\n//        }\n//        Arrays.sort(arr);\n//        for (int i = 0; i < arr.length; i++) {\n//            arr[i] = arr[i] % 10001;\n//        }\n//        return arr;\n\n//        Optimised solution\n        mergeSort(arr, 0, arr.length - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n//        int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n//        int[] arr = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\n        int[] arr = {2, 3, 5, 7, 11, 13, 17, 19};\n        int[] ans = sortByBits(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '665320f3-66cb-4e7a-9451-b88b1a8f6f2f',
              isFolder: false,
              name: 'SortList.java',
              code: 'class SortList {\n    static class ListNode {\n            int val;\n            ListNode next;\n            ListNode() {}\n            ListNode(int val) {\n                this.val = val;\n            }\n            ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode list2Head = slow.next;\n        slow.next = null;\n        head = mergeSort(head);\n        list2Head = mergeSort(list2Head);\n        return merge(head, list2Head);\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode();\n        ListNode head = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        }\n        if (right != null) {\n            temp.next = right;\n        }\n        return head.next;\n    }\n    public static ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {1,5,-3,4,1};\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        for (int j : arr) {\n            temp.next = new ListNode(j);\n            temp = temp.next;\n        }\n        head = head.next;\n        head = sortList(head);\n        temp = head;\n        while (temp != null) {\n            if (temp.next == null) {\n                System.out.print(temp.val);\n                break;\n            }\n            System.out.print(temp.val + " => ");\n            temp = temp.next;\n        }\n    }\n}',
              link: 'https://leetcode.com/problems/sort-list/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '2b6fe43b-671d-4e31-8bc7-80767421eea3',
              isFolder: false,
              name: 'SplArrayWithXElementsGTEToX.java',
              code: 'public class SplArrayWithXElementsGTEToX {\n    public int specialArray(int[] nums) {\n        int start = 1, end = nums.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i: nums) {\n                if (i >= mid) count++;\n            }\n            if (count == mid) return mid;\n            if (count > mid)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '0df0efc1-f57b-4278-9e9f-567215797fc4',
              isFolder: false,
              name: 'SquaresOfASortedArray.java',
              code: 'public class SquaresOfASortedArray {\n    public int[] sortedSquares(int[] nums) {\n//        Brute force\n//        int[] ans = new int[nums.length];\n//        for (int i=0; i < nums.length; i++) {\n//            ans[i] = nums[i]*nums[i];\n//        }\n//        Arrays.sort(ans);\n//        return ans;\n//        Best solution\n        int n = nums.length - 1;\n        int[] ans = new int[n+1];\n        int start = 0, end = n;\n        while(start <= end) {\n            if (Math.abs(nums[start]) >= Math.abs(nums[end])) {\n                ans[n--] = nums[start]*nums[start];\n                start++;\n            } else {\n                ans[n--] = nums[end]*nums[end];\n                end--;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n\n    }\n}',
              link: 'https://leetcode.com/problems/squares-of-a-sorted-array/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: '4195c634-d325-4476-8c9e-96d8c616a284',
              isFolder: false,
              name: 'ThirdMaximumNumber.java',
              code: "// Approach: Ranking technique with conditions to handle the same values as first and second;\n// Use Long instead of int as min and max value is Integer's min and max value\n\npublic class ThirdMaximumNumber {\n    public static int getThirdMaxNumber(int[] arr) {\n        long f = Long.MIN_VALUE;\n        long s = Long.MIN_VALUE;\n        long t = Long.MIN_VALUE;\n        for (int num : arr) {\n            if (num > f) {\n                t = s;\n                s = f;\n                f = num;\n            } else if (num > s && num != f) {\n                t = s;\n                s = num;\n            } else if (num > t && num != s && num != f) {\n                t = num;\n            }\n        }\n        if (t == Long.MIN_VALUE) {\n            return (int)f;\n        }\n        return (int)t;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1,2,2,5,3,5};\n        int ans = getThirdMaxNumber(arr);\n        System.out.println(ans);\n    }\n}",
              link: 'https://leetcode.com/problems/third-maximum-number/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'cee1d26c-8681-4adf-9972-e6ee7b8c94e9',
              isFolder: false,
              name: 'ThreeSumClosest.java',
              code: 'import java.util.*;\npublic class ThreeSumClosest {\n    public static int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int n = nums.length;\n\n        int first3Sum = nums[0]+nums[1]+nums[2];\n        int last3Sum = nums[n-1]+nums[n-2]+nums[n-3];\n        if (first3Sum >= target) return first3Sum;\n        if (last3Sum <= target) return last3Sum;\n\n        int diff = Integer.MAX_VALUE;\n        int closest = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            int j = i+1;\n            int k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) return sum;\n\n                int abs = Math.abs(target - sum);\n                if (diff > abs) {\n                    closest = sum;\n                    diff = abs;\n                }\n                if (sum > target) k--;\n                else j++;\n            }\n        }\n        return closest;\n    }\n}',
              link: 'https://leetcode.com/problems/3sum-closest/',
              notes: '',
              tags: ['Sorting'],
            },
            {
              id: 'b2eda809-e602-42c1-ab45-707f93779ece',
              isFolder: false,
              name: 'MaximumOccuringCharacter.java',
              code: "public class MaximumOccuringCharacter {\n//    Use a hashmap or counts array to store the count of all the elements\n//    ans iterate over it to get the max count;\n    public static char getMaxOccuringChar(String line)\n    {\n        // Your code here\n        int[] count = new int[26];\n        for (int i = 0; i < line.length(); i++) {\n            count[(int) line.charAt(i) - 'a']++;\n        }\n        int max = count[0];\n        int idx = 0;\n        for (int j = 0; j < count.length; j++) {\n            if (count[j] > max) {\n                idx = j;\n                max = count[j];\n            }\n        }\n        return (char) (idx + 'a');\n    }\n\n    public static void main(String[] args) {\n        String s = \"testsample\";\n        char ans = getMaxOccuringChar(s);\n        System.out.println(ans);\n    }\n}",
              link: 'https://practice.geeksforgeeks.org/problems/maximum-occuring-character-1587115620/1',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'ba50210b-ae58-47dc-8e4a-30db9156def7',
              isFolder: false,
              name: 'PermutationInString.java',
              code: 'public class PermutationInString {\n    public static boolean checkCount(int[] arr1, int[] arr2) {\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] != arr2[i]) return false;\n        }\n        return true;\n    }\n\n    public static boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n        int[] count1 = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count1[s1.charAt(i) - 97]++;\n        }\n        int[] count2 = new int[26];\n        int windowSize = s1.length();\n        int i = 0;\n        while (i < windowSize) {\n            count2[s2.charAt(i) - 97]++;\n            i++;\n        }\n        if (checkCount(count1, count2)) return true;\n        while (i < s2.length()) {\n            // Add\n            count2[s2.charAt(i) -97]++;\n            // Minus\n            count2[s2.charAt(i-windowSize) -97]--;\n\n            i++;\n            if (checkCount(count1, count2)) return true;\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        String s1 = "ab";\n        String s2 = "eidboaoo";\n        boolean ans = checkInclusion(s1, s2);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/permutation-in-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'cb0314c1-52fc-4b4a-bd77-ad5e7e4baccf',
              isFolder: false,
              name: 'PowerSet.java',
              code: 'import java.util.*;\npublic class PowerSet {\n    public List<List<Integer>> powerSet(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < Math.pow(2, nums.length); i++) {\n            List<Integer> list = new ArrayList<>();\n            int idx = 0;\n            while(idx < nums.length) {\n                if (((i >> idx)&1) == 1) {\n                    list.add(nums[idx]);\n                }\n                idx++;\n            }\n            ans.add(list);\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/subsets/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '932b22b2-5287-4af2-80aa-dcf7598efe22',
              isFolder: false,
              name: 'RemoveAllAdjacentDuplicates.java',
              code: 'public class RemoveAllAdjacentDuplicates {\n    public static String removeDuplicates(String s) {\n//        Brute force solution\n//        Stack<Character> stack = new Stack<>();\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (!stack.isEmpty() && stack.peek() == ch)\n//                stack.pop();\n//            else\n//                stack.push(ch);\n//        }\n//        while (!stack.isEmpty()) sb.append(stack.pop());\n//        return sb.reverse().toString();\n\n//        Better solution using stack\n        char[] stack = new char[s.length()];\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            char ch = s.charAt(j);\n            if (i > 0 && stack[i-1] == ch)\n                i = Math.max(0, i - 1);\n            else\n                stack[i++] = ch;\n        }\n        return new String(stack, 0, i);\n    }\n    public static void main(String[] args) {\n        String s = "abbaca";\n        String ans = removeDuplicates(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '12b23d1f-a55a-418c-aa33-54a054fea313',
              isFolder: false,
              name: 'RemoveAllOccurrencesOfSubstring.java',
              code: 'public class RemoveAllOccurrencesOfSubstring {\n    public static String removeOccurrences(String s, String part) {\n        StringBuilder sb = new StringBuilder(s);\n        while (sb.length()!=0 && sb.indexOf(part)>=0) {\n            int idx = sb.indexOf(part);\n            sb.delete(idx, idx+part.length());\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n        String s = "daabcbaabcbc";\n        String part = "abc";\n        String ans = removeOccurrences(s, part);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/remove-all-occurrences-of-a-substring/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '7a293f71-2bd8-4735-b201-903e22cd75dc',
              isFolder: false,
              name: 'ReplaceSpaces.java',
              code: 'public class ReplaceSpaces {\n    public static StringBuilder replaceSpaces(StringBuilder str) {\n        // Write your code here.\n        // return new StringBuilder(str.toString().replace(" ", "@40"));\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == \' \')\n                sb.append("@40");\n            else\n                sb.append(str.charAt(i));\n        }\n        return sb;\n    }\n\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder("Coding Ninjas Is A Coding Platform");\n        StringBuilder ans = replaceSpaces(str);\n        System.out.println(ans);\n    }\n}',
              link: 'https://www.codingninjas.com/studio/problems/replace-spaces_1172172',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '7540dda2-80d8-416b-9cc4-8ae412b78324',
              isFolder: false,
              name: 'ReverseWords1.java',
              code: 'public class ReverseWords1 {\n    public static String reverseWords(String s) {\n//        Brute force solution\n//        String[] sArr = s.split(" ");\n//        StringBuilder sb = new StringBuilder();\n//        for (int i = sArr.length - 1; i >= 0; i--) {\n//            if (sArr[i].trim().length() != 0) {\n//                sb.append(sArr[i]).append(" ");\n//            }\n//        }\n//        return sb.toString().trim();\n\n//        Best: 2 pointer approach\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == \' \') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != \' \') i--;\n            if (i == -1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(\' \');\n        }\n        return sb.toString().trim();\n    }\n    public static void main(String[] args) {\n        String s = "a good   example";\n//        The string can have more than 1 space anywhere in the array\n        String ans = reverseWords(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '1506d0bd-36dc-489a-af02-2f996c48d8a4',
              isFolder: false,
              name: 'ReverseWordsInAString2.java',
              code: "import java.util.Arrays;\n\npublic class ReverseWordsInAString2 {\n//    Input: s = \"the sky is blue\"\n//    Output: \"blue is sky the\"\n    public static void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n\n    public static char[] reverseWords(char[] arr) {\n//        int start = 0;\n//        int end = arr.length;\n//        reverse(arr, start, end - 1);\n//        for (int i = 0; i < end; i++) {\n//            if (arr[i] == ' ') {\n//                reverse(arr, start, i-1);\n//                start = i+1;\n//            } else if (i == end - 1) {\n//                reverse(arr, start, i);\n//            }\n//        }\n//        return arr;\n        int start = 0;\n        int end = arr.length - 1;\n        reverse(arr, start, end);\n        for (int i = 0; i <= end; i++) {\n            if (arr[i] == ' ') {\n                reverse(arr, start, i - 1);\n                start = i + 1;\n            }\n        }\n        reverse(arr, start, end);\n        return arr;\n    }\n    public static void main(String[] args) {\n        char[] arr = {'t', 'h', 'e', ' ', 's', 'k', 'y', ' ', 'i', 's', ' ', 'b', 'l', 'u', 'e'};\n        char[] ans = reverseWords(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}",
              link: 'https://www.lintcode.com/problem/927/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: 'bd0a7a5b-df9d-40e0-8680-d6eb766379c0',
              isFolder: false,
              name: 'StringCompression.java',
              code: "public class StringCompression {\n    public static int compress(char[] chars) {\n        // Best solution O(n)\n        int n = chars.length;\n        if (n == 1)\n            return 1;\n        int i = 0, j = 0, slow = 0;\n        while (j < n) {\n            while (j < n && chars[i] == chars[j])\n                j++;\n            chars[slow++] = chars[i];\n            if (j - i > 1) {\n                String diff = j - i + \"\";\n                for (int k = 0; k < diff.length(); k++) {\n                    chars[slow++] = diff.charAt(k);\n                }\n            }\n            i = j;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        char[] chars = { 'a', 'a', 'b', 'b', 'c', 'c', 'c' };\n        int ans = compress(chars);\n        System.out.println(ans);\n    }\n}",
              link: 'https://leetcode.com/problems/string-compression/',
              notes: '',
              tags: ['Strings'],
            },
            {
              id: '56b57f22-3b93-4af0-80bc-4b246baf5ab6',
              isFolder: false,
              name: 'ValidPalindrome.java',
              code: '//    The given string is polluted with characters other than numbers and alphabets.\n//    Also ignore the case while solving for the answer\n\npublic class ValidPalindrome {\n    public static boolean isPalindrome(String s) {\n//        Brute force: Remove every character that is not valid using replaceAll method\n//        This will take O(n) time to replace and O(n) time to make it lowercase and then\n//        another O(n) to iterate the array\n//        Total TC = O(3n)\n//        s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Best approach: Two pointer approach\n//        Total TC = O(2n) => (lowercase and iterating)\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n\n    }\n    public static void main(String[] args) {\n        String s = "A man, a plan, a canal: Panama";\n        boolean ans = isPalindrome(s);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/valid-palindrome/',
              notes: '',
              tags: ['Strings'],
            },
          ],
        },
        {
          id: 'bda52064-8b13-480e-8544-dce804a32d16',
          isFolder: true,
          name: 'Neetcode 150',
          content: [
            {
              id: 'd2ca0a68-1f8d-479f-860d-54258c5f92df',
              isFolder: false,
              name: 'ContainsDuplicate.java',
              code: 'import java.util.*;\n\nclass ContainsDuplicate {\n    public boolean containsDuplicate(int[] nums) {\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : nums) {\n            if (hs.contains(i)) return true;\n            hs.add(i);\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/contains-duplicate/',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '7ec32c4d-5c40-4833-9c24-8b00ae29960c',
              isFolder: false,
              name: 'GroupAnagrams.java',
              code: 'import java.util.*;\n/*\n* Sorting and storing in hashmap and value list\n* if a duplicate string is found store it in value list.\n* If it does not exist create a new key value pair in hashmap\n*/\n\npublic class GroupAnagrams {\n    public static List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<String, List<String>> hm = new HashMap<>();\n        for (String str : strs) {\n            char[] ch = str.toCharArray();\n            Arrays.sort(ch);\n            String s = new String(ch);\n            if (!hm.containsKey(s)) {\n                hm.put(s, new ArrayList<>());\n            }\n            hm.get(s).add(str);\n        }\n        System.out.println(hm);\n        return new ArrayList<>(hm.values());\n    }\n\n    public static void main(String[] args) {\n//        String[] arr = {"eat","tea","tan","ate","nat","bat"};\n        String[] arr = {""};\n        List<List<String>> ans = groupAnagrams(arr);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/group-anagrams',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '45ef07f2-140b-4efe-acdc-12ba267bce75',
              isFolder: false,
              name: 'LongestConsecutiveSequence.java',
              code: 'import java.util.*;\n\npublic class LongestConsecutiveSequence {\n    public static int longestConsecutive(int[] N) {\n//        Brute force solution\n//        if (N.length == 0) return 0;\n//        Arrays.sort(N);\n//        int maxLen = 0, len = 1, last = Integer.MIN_VALUE;\n//        for (int k : N) {\n//            if (k - 1 == last) len++;\n//            else if (k != last)len = 1;\n//            last = k;\n//            maxLen = Math.max(maxLen, len);\n//        }\n//        return maxLen;\n\n//        Best solution\n        HashSet<Integer> hs = new HashSet<>();\n        int maxCount = 0;\n        for (int num: N) hs.add(num);\n        for (int j : N) {\n            if (!hs.contains(j - 1)) {\n                int x = j;\n                int count = 1;\n                while (hs.contains(x+1)) {\n                    count++;\n                    x++;\n                }\n                maxCount = Math.max(maxCount, count);\n            }\n        }\n        return maxCount;\n    }\n    public static void main(String[] args) {\n\n    }\n}',
              link: 'https://leetcode.com/problems/longest-consecutive-sequence',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '9550c224-6e88-49f4-93bf-e0bfe90a5d17',
              isFolder: false,
              name: 'ProductArrayExceptSelf.java',
              code: 'public class ProductArrayExceptSelf {\n    public int[] productExceptSelf(int[] nums) {\n        int zeroCount = 0;\n        int zeroIdx = -1;\n        int[] ans = new int[nums.length];\n        int product = 1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                zeroCount++;\n                if (zeroCount > 1) return ans;\n                zeroIdx = i;\n                continue;\n            }\n            product *= nums[i];\n        }\n        if (zeroCount == 1) {\n            ans[zeroIdx] = product;\n            return ans;\n        }\n        for (int j = 0; j < nums.length; j++) {\n            ans[j] = product / nums[j];\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/product-of-array-except-self/',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '9bf9ee62-1b81-47ba-959c-f9c87eefcf0d',
              isFolder: false,
              name: 'TopKFrequentElements.java',
              code: 'import java.util.*;\n\npublic class TopKFrequentElements {\n    public static int[] topKFrequent(int[] nums, int k) {\n        // This is the O(klogN) solution\n        // int[] kArr = new int[k];\n        // HashMap<Integer, Integer> hm = new HashMap<>();\n        // for (int num : nums) {\n        //     hm.put(num, hm.getOrDefault(num, 0) + 1);\n        // }\n        // PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue());\n        // for (Map.Entry<Integer, Integer> it : hm.entrySet()) {\n        //     pq.add(it);\n        //     if (pq.size() > k) pq.poll();\n        // }\n        // while (!pq.isEmpty()) {\n        //     kArr[--k] = pq.poll().getKey();\n        // }\n        // return kArr;\n\n        // Most efficient solution: O(n)\n        Map<Integer, Integer> hm = new HashMap<>();\n        for (int num : nums) {\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\n        }\n        List<List<Integer>> countList = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            countList.add(new ArrayList<>());\n        }\n        for(Map.Entry<Integer, Integer> val : hm.entrySet()) {\n            countList.get(val.getValue()-1).add(val.getKey());\n        }\n        int[] ans = new int[k];\n        int ptr = 0;\n        for (int i = countList.size() - 1; i >= 0; i--) {\n            if (countList.get(i).size() != 0) {\n                for (int j: countList.get(i)) {\n                    if (ptr == k) break;\n                    ans[ptr++] = j;\n                }\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 1, 1, 2, 2, 3};\n        int k = 2;\n        int[] ans = topKFrequent(nums, k);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: 'https://leetcode.com/problems/top-k-frequent-elements',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'bffda2e9-c785-4ce7-8c47-30b18a56859a',
              isFolder: false,
              name: 'TwoSum.java',
              code: 'import java.util.HashMap;\n\npublic class TwoSum {\n  public int[] twoSum(int[] nums, int target) {\n    HashMap<Integer, Integer> hm = new HashMap<>();\n    for (int j = 0; j < nums.length; j++) {\n      if (hm.containsKey(target - nums[j]))\n        return new int[] { j, hm.get(target - nums[j]) };\n      hm.put(nums[j], j);\n    }\n    return new int[] { -1, -1 };\n  }\n}',
              link: 'https://leetcode.com/problems/two-sum',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: '3919f9b6-ba01-4b28-b5ac-99925455e8bc',
              isFolder: false,
              name: 'ValidAnagram.java',
              code: "public class ValidAnagram {\n  public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length())\n      return false;\n    int[] count = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n      count[s.charAt(i) - 'a']++;\n      count[t.charAt(i) - 'a']--;\n    }\n    for (int i = 0; i < 26; i++) {\n      if (count[i] != 0)\n        return false;\n    }\n    return true;\n  }\n}",
              link: 'https://leetcode.com/problems/valid-anagram',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'a0c9cd39-9fd7-4729-b714-fb994af0cf6d',
              isFolder: false,
              name: 'ValidSudoku.java',
              code: "import java.util.HashSet;\n\npublic class ValidSudoku {\n    public static boolean checkBlock(int iIdx, int jIdx, char[][] board) {\n        HashSet<Character> hs = new HashSet<>();\n        int rows = iIdx + 3;\n        int cols = jIdx + 3;\n        for (int i = iIdx; i < rows; i++) {\n            for (int j = jIdx; j < cols; j++) {\n                char curr = board[i][j];\n                if (curr != '.') {\n                    if (hs.contains(curr)) return false;\n                    hs.add(curr);\n                }\n            }\n        }\n        return true;\n    }\n    public static boolean isValidSudoku(char[][] board) {\n//        Row column check\n        for (int i = 0; i < board.length; i++) {\n            HashSet<Character> row = new HashSet<>();\n            HashSet<Character> col = new HashSet<>();\n            for (int j = 0; j < board.length; j++) {\n                char r = board[i][j], c = board[j][i];\n                if (r != '.' && row.contains(r)) return false;\n                else row.add(r);\n                if (c != '.' && col.contains(c)) return false;\n                else col.add(c);\n            }\n        }\n//        3x3 box check\n        for (int i = 0; i < 9; i += 3)\n            for (int j = 0; j < 9; j += 3)\n                if (!checkBlock(i, j, board)) return false;\n\n        return true;\n    }\n}",
              link: 'https://leetcode.com/problems/valid-sudoku',
              notes: '',
              tags: ['Arrays & Hashing'],
            },
            {
              id: 'd1a87628-729a-452d-9e2b-26230a2767e2',
              isFolder: false,
              name: 'FindMinInSortedRotatedArray.java',
              code: 'public class FindMinInSortedRotatedArray {\n    public int findMin(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] > arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '0fa1448c-72fe-4dda-9b12-0ae8f4c46f79',
              isFolder: false,
              name: 'kokoEatingBananas.java',
              code: 'public class kokoEatingBananas {\n    public long totalTimeToEat(int mid, int[] piles) {\n        long hours = 0;\n        for (int i : piles) {\n            hours += (i + mid - 1) / mid;\n        }\n        return hours;\n    }\n\n    public int minEatingSpeed(int[] piles, int h) {\n        int start = 1;\n        int end = 0;\n        for(int i: piles) {\n            end = Math.max(end, i);\n        }\n        int ans = 0;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (totalTimeToEat(mid, piles) <= h) {\n                ans = mid;\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/koko-eating-bananas',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'bed6af35-bf6c-4f79-9964-b908d74bfe1b',
              isFolder: false,
              name: 'MedianOfTwoSortedArrays.java',
              code: 'public class MedianOfTwoSortedArrays {\n    public double findMedianSortedArrays(int[] M, int[] N) {\n       int m = M.length, n = N.length;\n       if (m > n) return findMedianSortedArrays(N, M);\n       int k = (m + n + 1)/2;\n       int start = 0, end = m;\n       while (start <= end) {\n           int mid1 = start + (end - start)/2;\n           int mid2 = k - mid1;\n           int l1 = mid1 > 0 ? M[mid1 - 1] : Integer.MIN_VALUE;\n           int l2 = mid2 > 0 ? N[mid2 - 1] : Integer.MIN_VALUE;\n           int r1 = mid1 < m ? M[mid1] : Integer.MIN_VALUE;\n           int r2 = mid2 < n ? N[mid2] : Integer.MIN_VALUE;\n           if (l1 <= r2 && l2 <= r1) {\n               double median = Math.max(l1, l2);\n               if ((m+n) %2 == 0) {\n                   median += Math.min(r1, r2);\n                   return median / 2;\n               }\n               return median;\n           }\n           if (l1 > r2) {\n               end = mid1 - 1;\n           } else {\n               start = mid1 + 1;\n           }\n       }\n       return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/median-of-two-sorted-arrays',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '9f4e53b4-42ed-442a-9acf-c5968083503b',
              isFolder: false,
              name: 'Search2DMatrix.java',
              code: 'public class Search2DMatrix {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int n = matrix.length;\n        int m = matrix[0].length;\n        int start = 0;\n        int end = n*m -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (matrix[mid/m][mid%m] == target)\n                return true;\n            if (matrix[mid/m][mid%m] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/search-a-2d-matrix',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '365e69dd-b0e3-4a4c-962d-821bac14ee80',
              isFolder: false,
              name: 'SearchInRotatedSortedArray.java',
              code: 'public class SearchInRotatedSortedArray {\n    public int search(int[] arr, int target) {\n        int start = 0; int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (target == arr[mid]) return mid;\n            if (arr[mid] >= arr[start]) {\n                if (target >= arr[start] && target < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else {\n                if (target <= arr[end] && target > arr[mid])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            }\n        }\n        return -1;\n    }\n}',
              link: 'https://leetcode.com/problems/search-in-rotated-sorted-array',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: '7eb7f61d-6679-419c-b00d-4e71413f7256',
              isFolder: false,
              name: 'TimeMap.java',
              code: 'import java.util.*;\n\nclass TimeMap {\n    HashMap<String, List<String[]>> hm;\n    public TimeMap() {\n        hm = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        if (!hm.containsKey(key))\n            hm.put(key, new ArrayList<>());\n        hm.get(key).add(new String[]{ value, String.valueOf(timestamp) });\n    }\n\n    public String get(String key, int timestamp) {\n        if (!hm.containsKey(key)) return "";\n        List<String[]> list = hm.get(key);\n        int pos = findPos(list, timestamp);\n        if (pos == -1) return "";\n        return list.get(pos)[0];\n    }\n\n    public static int findPos(List<String[]> list, int target) {\n        int start = 0, end = list.size() - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int val = Integer.parseInt(list.get(mid)[1]);\n            if (val == target) return mid;\n            if (val > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static void main(String[] args) {\n        String[] operations = {"TimeMap", "set", "set", "get", "get", "get", "get", "get"};\n        String[][] values = {{}, {"love", "high", "10"}, {"love", "low", "20"}, {"love", "5"}, {"love", "10"}, {"love", "15"}, {"love", "20"}, {"love", "25"}};\n        TimeMap timeMap = null;\n        List<String> output = new ArrayList<>();\n        for (int i = 0; i < operations.length; i++) {\n            String[] val = values[i];\n            switch (operations[i]) {\n                case "TimeMap" -> {\n                    timeMap = new TimeMap();\n                    output.add(null);\n                }\n                case "set" -> {\n                    timeMap.set(val[0], val[1], Integer.parseInt(val[2]));\n                    output.add(null);\n                }\n                case "get" -> {\n                    output.add(timeMap.get(val[0], Integer.parseInt(val[1])));\n                }\n            }\n        }\n        System.out.println(output);\n    }\n}\n\n/**\n * Your TimeMap object will be instantiated and called as such:\n * TimeMap obj = new TimeMap();\n * obj.set(key,value,timestamp);\n * String param_2 = obj.get(key,timestamp);\n */',
              link: 'https://leetcode.com/problems/time-based-key-value-store',
              notes: '',
              tags: ['Binary Search'],
            },
            {
              id: 'aaa3a4bf-e87f-4183-a9f9-ad77a35b3848',
              isFolder: false,
              name: 'ReverseBits.java',
              code: 'public class ReverseBits {\n    // you need treat n as an unsigned value\n    public static int setBit (int n, int mask) {\n        return n | mask;\n    }\n    public static int clearBit (int n, int mask) {\n        return n & ~mask;\n    }\n    public int reverseBits(int n) {\n//        int start = 31;\n//        int end = 0;\n//        while (start > end) {\n//            int startMask = 1<<start;\n//            int endMask = 1<<end;\n//            int a = (n&startMask) != 0 ? 1 : 0;\n//            int b = (n&endMask) != 0 ? 1 : 0;\n//            if (a != b) {\n//                if (a == 1) {\n//                    n = clearBit(n, startMask);\n//                    n = setBit(n, endMask);\n//                } else {\n//                    n = clearBit(n, endMask);\n//                    n = setBit(n, startMask);\n//                }\n//            }\n//            start--;\n//            end++;\n//        }\n//        return n;\n\n        int ans = 0;\n        for (int i = 0; i < 32; i++) {\n            ans <<= 1;\n            ans |= (n&1);\n            n >>= 1;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-bits/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '144a3f1d-283c-476a-ab3d-cd8ee941cef0',
              isFolder: false,
              name: 'ReverseInteger.java',
              code: 'public class ReverseInteger {\n    public int reverse(int n) {\n        boolean isNegative = n < 0;\n        int num = 0;\n        n = Math.abs(n);\n        while (n > 0) {\n            if (Integer.MAX_VALUE / 10 < num) return 0;\n            num = num * 10 + n % 10;\n            n = n / 10;\n        }\n        return isNegative ? -num : num;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-integer/',
              notes: '',
              tags: ['Bit Manipulation'],
            },
            {
              id: '9c31eb6c-ab69-4357-b2d1-4a7ca49d5283',
              isFolder: false,
              name: 'AddTwoNumbers.java',
              code: 'public class AddTwoNumbers {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode sum = new ListNode(0);\n        ListNode sumHead = sum;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int d1 = l1 != null ? l1.val : 0;\n            int d2 = l2 != null ? l2.val : 0;\n            carry += d1 + d2;\n            sum.next = new ListNode(carry%10);\n            sum = sum.next;\n            carry /= 10;\n            l1 = l1 != null ? l1.next : null;\n            l2 = l2 != null ? l2.next : null;\n        }\n        return sumHead.next;\n    }\n}',
              link: 'https://leetcode.com/problems/add-two-numbers/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'c32a7b6c-39dc-4d9b-ba03-a5df8a093eb8',
              isFolder: false,
              name: 'CopyListWithRandomPointer.java',
              code: 'public class CopyListWithRandomPointer {\n    public Node copyRandomList(Node head) {\n        // Optimised solution\n        if (head == null) return null;\n        // Step 1: Create a new linked list in between the nodes of current LL\n        Node curr = head;\n        while (curr != null) {\n            Node newNode = new Node(curr.val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            curr = newNode.next;\n        }\n        // Step 2: Assign random pointers to the deep copy\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n        // Step 3: Separate both the linked list and return Head\n        Node copy = head.next;\n        Node temp = copy;\n        curr = head;\n        while (temp != null) {\n            curr.next = temp.next;\n            curr = curr.next;\n            if (curr == null) break;\n            temp.next = curr.next;\n            temp = temp.next;\n        }\n        return copy;\n    }\n}',
              link: 'https://leetcode.com/problems/copy-list-with-random-pointer/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'f4fe64df-d892-48b9-8d08-157b1bd4d8d4',
              isFolder: false,
              name: 'FindTheDuplicateNumber.java',
              code: "public class FindTheDuplicateNumber {\n    public int findDuplicate(int[] nums) {\n        // To solve this in linear time and constant space we use FLOYD'S Algorithm\n        int slow = 0;\n        int fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        int slow2 = 0;\n        while (slow != slow2) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n        }\n        return slow;\n    }\n}",
              link: 'https://leetcode.com/problems/find-the-duplicate-number/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '00b6a29f-7804-44fe-94ec-999246195e32',
              isFolder: false,
              name: 'LinkedListCycle.java',
              code: 'public class LinkedListCycle {\n    public boolean hasCycle(ListNode head) {\n        // Brute force\n        // HashSet<ListNode> hs = new HashSet<>();\n        // ListNode curr = head;\n        // while (curr != null) {\n        //     if (hs.contains(curr)) return true;\n        //     hs.add(curr);\n        //     curr = curr.next;\n        // }\n        // return false;\n\n        // Optimised\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}',
              link: 'https://leetcode.com/problems/linked-list-cycle/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '8bcc8b7b-2842-4db6-87f6-1a050f0beb2a',
              isFolder: false,
              name: 'ListNode.java',
              code: '// !ignore\npublic class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '9c384f93-5bfc-42e2-981d-1b4fae862fdd',
              isFolder: false,
              name: 'MergeKSortedLists.java',
              code: 'public class MergeKSortedLists {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        temp.next = left != null ? left : right;\n        return tHead.next;\n    }\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += interval*2) {\n                lists[i] = merge(lists[i], lists[i+interval]);\n            }\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
              link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'f1150789-6131-44f6-8d79-96c79db3d04b',
              isFolder: false,
              name: 'MergeTwoSortedLists.java',
              code: 'public class MergeTwoSortedLists {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null) {\n            temp.next = left;\n        } else {\n            temp.next = right;\n        }\n        return tHead.next;\n    }\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        return merge(list1, list2);\n    }\n}',
              link: 'https://leetcode.com/problems/merge-two-sorted-lists/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '37e066bf-39ab-482f-8c40-4008699c95a1',
              isFolder: false,
              name: 'Node.java',
              code: '// !ignore\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}',
              link: null,
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '52ca1d8f-b1f6-4533-bc6f-785ea580b1ef',
              isFolder: false,
              name: 'RemoveNthNodeFromEndOfList.java',
              code: 'public class RemoveNthNodeFromEndOfList {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Optimised approach\n        ListNode start = new ListNode(0, head);\n        ListNode slow = start;\n        ListNode fast = start;\n        for (int i = 0; i < n; i++) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return start.next;\n    }\n}',
              link: 'https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '9af1957e-9bda-4bc8-8839-7c2469cf3e49',
              isFolder: false,
              name: 'ReorderList.java',
              code: 'public class ReorderList {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode tHead = new ListNode(0);\n        ListNode temp = tHead;\n        while (left != null && right != null) {\n            temp.next = left;\n            left = left.next;\n            temp = temp.next;\n            temp.next = right;\n            right = right.next;\n            temp = temp.next;\n        }\n        temp.next = left != null ? left : right;\n        return tHead.next;\n    }\n\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n        slow = revLL(slow);\n        head = merge(head, slow);\n    }\n}',
              link: 'https://leetcode.com/problems/reorder-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: 'c6c437e5-b6d0-4370-87d7-e5ca2c8affd5',
              isFolder: false,
              name: 'ReverseLinkedList.java',
              code: 'public class ReverseLinkedList {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-linked-list/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '143b5e80-6c68-4e96-8fcf-12d0dea7e58f',
              isFolder: false,
              name: 'ReverseNodesInKGroups.java',
              code: 'public class ReverseNodesInKGroups {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = head;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head, start = head, prev = head;\n        ListNode newHead = new ListNode(0, head);\n        ListNode temp = newHead;\n\n        while (curr != null) {\n            for (int i = 1; i <= k; i++) {\n                if (curr.next == null && i < k) return newHead.next;\n                prev = curr;\n                curr = curr.next;\n            }\n            prev.next = null;\n            temp.next = revLL(start);\n            start.next = curr;\n            temp = start;\n            start = curr;\n        }\n        return newHead.next;\n    }\n}',
              link: 'https://leetcode.com/problems/reverse-nodes-in-k-group/',
              notes: '',
              tags: ['Linked List'],
            },
            {
              id: '47d6feae-ab78-435a-9ff4-1eede127f838',
              isFolder: false,
              name: 'CarFleet.java',
              code: 'import java.util.Arrays;\nimport java.util.Stack;\n\npublic class CarFleet {\n    static class Pair {\n        int position;\n        int speed;\n\n        Pair(int p, int s) {\n            this.position = p;\n            this.speed = s;\n        }\n\n        @Override\n        public String toString() {\n            return "Pair{" + "P=" + position + ", S=" + speed + \'}\';\n        }\n    }\n\n    public static int carFleet(int target, int[] position, int[] speed) {\n        Pair[] arr = new Pair[speed.length];\n        for (int i = 0; i < speed.length; i++) {\n            arr[i] = new Pair(position[i], speed[i]);\n        }\n        Arrays.sort(arr, (a, b) -> b.position - a.position);\n        Stack<Double> st = new Stack<>();\n        for (Pair pair : arr) {\n            double curr = (double) (target - pair.position) / pair.speed;\n            if (st.isEmpty() || curr > st.peek()) {\n                st.push(curr);\n            }\n        }\n        return st.size();\n    }\n\n    public static void main(String[] args) {\n        int[] position = {10, 8, 0, 5, 3};\n        int[] speed = {2, 4, 1, 1, 3};\n        System.out.println(carFleet(12, position, speed));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '6d945000-845a-4b21-a8f3-250aefcc7e7a',
              isFolder: false,
              name: 'MinStack.java',
              code: 'import java.util.*;\n\nclass MinStack {\n    Stack<Integer> stack;\n    Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        int minValue = minStack.empty() ? val : Math.min(minStack.peek(), val);\n        minStack.push(minValue);\n    }\n\n    public void pop() {\n        minStack.pop();\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n\n    public static void main(String[] args) {\n//        ["MinStack","push","push","push","top","pop","getMin","pop","getMin","pop","push","top","getMin","push","top","getMin","pop","getMin"]\n//        [[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\n        MinStack st = new MinStack();\n        st.push(2147483646);\n        st.push(2147483646);\n        st.push(2147483647);\n        System.out.println(st.top());\n        st.pop();\n        System.out.println(st.getMin());\n        st.pop();\n        System.out.println(st.getMin());\n        st.pop();\n//        System.out.println(st.top());\n\n    }\n}\n\n/*\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */',
              link: 'https://leetcode.com/problems/min-stack/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: 'f971d50f-aa6e-44c7-8cab-233a70f32084',
              isFolder: false,
              name: 'ReversePolishNotation.java',
              code: 'import java.util.*;\n\nclass ReversePolishNotation {\n    public static int operate(String op, int first, int second) {\n        if (op.equals("-")) return second - first;\n        if (op.equals("*")) return second * first;\n        if (op.equals("/")) return second / first;\n        return second + first; // op = +\n    }\n\n    public int evalRPN(String[] tokens) {\n        // Basically secondPop operation firstPop\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/"))\n                stack.push(operate(token, stack.pop(), stack.pop()));\n            else\n                stack.add(Integer.parseInt(token));\n        }\n        return stack.pop();\n    }\n}',
              link: 'https://leetcode.com/problems/evaluate-reverse-polish-notation/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '43294f01-1204-44e8-8345-22810c86e97f',
              isFolder: false,
              name: 'ValidParentheses.java',
              code: "import java.util.*;\npublic class ValidParentheses {\n    public static boolean isValid(String s) {\n//        Best w Stack\n//        int len = s.length();\n//        if ((len&1) == 1) return false;\n//        HashMap<Character, Character> hm = new HashMap<>();\n//        hm.put('(', ')');\n//        hm.put('[', ']');\n//        hm.put('{', '}');\n//        char[] charArr = s.toCharArray();\n//        Stack<Character> stack = new Stack<>();\n//        for (int i = 0; i < len; i++) {\n//            char ch = charArr[i];\n//            if (hm.containsKey(ch)) stack.push(ch);\n//            else {\n//                if(stack.empty()) return false;\n//                char top = stack.pop();\n//                if (hm.get(top) != ch) return false;\n//            }\n//        }\n//        return stack.empty();\n\n//     Best w/o stack\n        int len = s.length();\n        if ((len&1) == 1) return false;\n        char[] stack = new char[len];\n        char[] charArr = s.toCharArray();\n        HashMap<Character, Character> hm = new HashMap<>();\n        hm.put('(', ')');\n        hm.put('[', ']');\n        hm.put('{', '}');\n        int ptr = -1;\n        for (int i = 0; i < len; i++) {\n            char ch = charArr[i];\n            if (hm.containsKey(ch)) {\n                stack[++ptr] = ch;\n            } else {\n                if(ptr == -1) return false;\n                char top = stack[ptr--];\n                if (hm.get(top) != ch) return false;\n            }\n        }\n        return ptr == -1;\n    }\n\n    public static void main(String[] args) {\n        String s = \"()\";\n        System.out.println(isValid(s));\n    }\n}",
              link: 'https://leetcode.com/problems/valid-parentheses/',
              notes: '',
              tags: ['Stack'],
            },
            {
              id: '102da00e-8d4a-4b6e-a225-9c4fde0b0d91',
              isFolder: false,
              name: 'ContainerWithMostWater.java',
              code: 'public class ContainerWithMostWater {\n    public static int maxArea(int[] heights) {\n        int i = 0;\n        int j = heights.length - 1;\n        int area = 0;\n        int max = 0;\n        while (i < j) {\n            if (heights[i] <= heights[j]) i++;\n            else if (heights[i] > heights[j]) j--;\n\n            area = (j - i) * Math.min(heights[i], heights[j]);\n            max = Math.max(max, area);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n        int ans = maxArea(heights);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/container-with-most-water/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '23f3b64c-8195-4275-9af6-48088bc22412',
              isFolder: false,
              name: 'ThreeSum.java',
              code: 'import java.util.*;\npublic class ThreeSum {\n    public List<List<Integer>> threeSum(int[] N) {\n        Arrays.sort(N);\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = N.length;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && N[i] == N[i-1]) continue;\n            int j = i+1;\n            int k = n-1;\n            while (j < k) {\n                int sum = N[i] + N[j] + N[k];\n                if (sum > 0) k--;\n                else if (sum < 0) j++;\n                else {\n                    ans.add(Arrays.asList(N[i], N[j], N[k]));\n                    j++;\n                    k--;\n                    while (j < k && N[j] == N[j-1]) j++;\n                    while (j < k && N[k] == N[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/3sum',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '046c8b90-04f3-4c27-8ad5-84e4cc7d6832',
              isFolder: false,
              name: 'TrappingRainWater.java',
              code: '// import java.util.Arrays;\npublic class TrappingRainWater {\n    public static int trap(int[] height) {\n        int n = height.length;\n//        int[] maxLeft = new int[n];\n//        int[] maxRight = new int[n];\n//        int leftMax = 0, rightMax = 0;\n//        for (int i = 0; i < n; i++) {\n//            maxLeft[i] = leftMax;\n//            leftMax = Math.max(leftMax, height[i]);\n//            maxRight[n - i - 1] = rightMax;\n//            rightMax = Math.max(rightMax, height[n - i - 1]);\n//        }\n//        int count = 0;\n//        for (int j = 0; j < n; j++) {\n//            count += Math.max(Math.min(maxLeft[j], maxRight[j]) - height[j], 0);\n//        }\n//        return count;\n        int start = 0, end = n - 1;\n        int maxL = height[start], maxR = height[end];\n        int c = 0;\n        while (start < end) {\n            if (height[start] <= height[end]) {\n                start++;\n                maxL = Math.max(maxL, height[start]);\n                c += Math.max(maxL - height[start], 0);\n\n            } else {\n                end--;\n                maxR = Math.max(maxR, height[end]);\n                c += Math.max(maxR - height[end], 0);\n            }\n        }\n        return c;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n        int ans = trap(arr);\n        System.out.println(ans);\n    }\n}',
              link: 'https://leetcode.com/problems/trapping-rain-water/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: 'a7f39663-ee19-4d59-8ed5-10812e1bc197',
              isFolder: false,
              name: 'TwoSumSortedArray.java',
              code: 'public class TwoSumSortedArray {\n    public static int[] twoSum(int[] N, int target) {\n//        Brute force: Linear search the pair using 2 for loops (nested) O(N^2)\n\n//        Better solution: Use 2 pointer from left and right to get sum\n\n//        Optimised solution: Binary search\n        int start = 0;\n        int end = N.length - 1;\n        int[] ans = {-1, -1};\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int sum = N[start] + N[end];\n            if (sum == target){\n                ans[0] = start + 1;\n                ans[1] = end + 1;\n                return ans;\n            }\n            if (sum > target)\n                end = N[start] + N[mid] > target ? mid - 1 : end - 1;\n            else\n                start = N[end] + N[mid] < target ? mid + 1 : start + 1;\n        }\n        return ans;\n    }\n}',
              link: 'https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/',
              notes: '',
              tags: ['Two Pointers'],
            },
            {
              id: '1311b289-4113-4728-b53c-72ab0e93a2c6',
              isFolder: false,
              name: 'ValidPalindrome.java',
              code: 'public class ValidPalindrome {\n    public boolean isPalindrome(String s) {\n//        Brute force solution\n//        s = s.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();\n//        int start = 0;\n//        int end = s.length() - 1;\n//        while (start < end) {\n//            if (s.charAt(start) != s.charAt(end)) return false;\n//            start++;\n//            end--;\n//        }\n//        return true;\n\n//        Optimised solution\n         int n = s.length();\n         int start = 0;\n         int end = n-1;\n         s = s.toLowerCase();\n         while (start < end) {\n             if (!Character.isLetterOrDigit(s.charAt(start))) start++;\n             else if (!Character.isLetterOrDigit(s.charAt(end))) end--;\n             else {\n                 if (s.charAt(start) != s.charAt(end)) return false;\n                 start++;\n                 end--;\n             }\n         }\n         return true;\n    }\n}',
              link: 'https://leetcode.com/problems/valid-palindrome/',
              notes: '',
              tags: ['Two Pointers'],
            },
          ],
        },
        {
          id: 'ccacefe1-cdbe-4875-93e6-0d9ec3abc020',
          isFolder: true,
          name: 'stiver_dsa_sheet',
          content: [
            {
              id: '8541381b-01ee-4472-95cd-fd803cabc6fb',
              isFolder: true,
              name: 'Arrays',
              content: [
                {
                  id: 'a4826036-6625-4671-8a0c-321f48f75db3',
                  isFolder: false,
                  name: 'MajorityFrequency.java',
                  code: 'import java.util.*;\n\npublic class MajorityFrequency {\n    public static int majorityElement(int[] v) {\n        // Write your code here\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int maxFrequency = v.length / 2;\n        for (int i = 0 ; i <  v.length; i++) {\n            if (hm.containsKey(v[i])) {\n                hm.put(v[i], hm.get(v[i]) + 1);\n                if (hm.get(v[i]) > maxFrequency) {\n                    return v[i];\n                }\n            } else {\n                hm.put(v[i], 1);\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 2, 1, 3, 1, 1, 3, 1, 1};\n        int ans = majorityElement(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '44729e8b-63f4-4286-9f89-aae2c772c1d3',
                  isFolder: false,
                  name: 'MaximumConsecutiveOnes.java',
                  code: 'public class MaximumConsecutiveOnes {\n    public static int findMaxConsecutiveOnes(int[] N) {\n        int count = 0;\n        int maxCount = 0;\n        for (int i = 0; i < N.length; i++) {\n            if (N[i] == 0) {\n                count = 0;\n            } else {\n                count++;\n            }\n            maxCount = Math.max(count, maxCount);\n        }\n        return maxCount;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 0, 1, 1, 0, 1};\n        int ans = findMaxConsecutiveOnes(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: '2bc0f3de-f840-4776-9bcc-8e12d388e15e',
                  isFolder: false,
                  name: 'MergeSortedArraysDuplicates.java',
                  code: 'import java.util.*;\n\npublic class MergeSortedArraysDuplicates {\n    public static List< Integer > sortedArray(int []a, int []b) {\n        // Write your code here\n        List<Integer> ans = new ArrayList<>();\n        int i = 0, j = 0;\n        while (i < a.length && j < b.length) {\n            if (a[i] <= b[j]) {\n                if (ans.size() == 0 || ans.get(ans.size() - 1) != a[i])\n                    ans.add(a[i]);\n                i++;\n            } else {\n                if (ans.size() == 0 || ans.get(ans.size() - 1) != b[j])\n                    ans.add(b[j]);\n                j++;\n            }\n        }\n        while (i < a.length) {\n            if (ans.get(ans.size() - 1) != a[i])\n                ans.add(a[i]);\n            i++;\n        }\n        while (j < b.length) {\n            if (ans.get(ans.size() - 1) != b[j])\n                ans.add(b[j]);\n            j++;\n        }\n        return ans;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: 'affe8a39-7232-4c02-9ec1-dedfc1ecd2f2',
                  isFolder: false,
                  name: 'ZeroOneTwo.java',
                  code: 'import java.util.*;\n\npublic class ZeroOneTwo {\n    public static void sortArray(ArrayList<Integer> arr, int n) {\n        // Write your code here.\n        int start = 0, end = n-1, element = 0;\n        while (element < 2) {\n            if (start >= end) {\n                element++;\n                end = n-1;\n            }\n            if (arr.get(start) == element) start++;\n            else if (arr.get(end) != element) end--;\n            else {\n                arr.set(end, arr.get(start));\n                arr.set(start, element);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        arr.add(2);\n        arr.add(2);\n        arr.add(2);\n        arr.add(2);\n        arr.add(0);\n        arr.add(0);\n        arr.add(1);\n        arr.add(0);\n        sortArray(arr, arr.size());\n        System.out.println(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['EASY'],
                },
                {
                  id: 'cbfaf842-50b2-46bf-ab4f-4d5491f3f9ee',
                  isFolder: false,
                  name: 'CountInversions.java',
                  code: 'public class CountInversions {\n    public static int merge(int[] A, int low, int mid, int high) {\n        int left = low, right = mid + 1, i = 0;\n        int count = 0;\n        int[] temp = new int[high - low + 1];\n        while (left <= mid && right <= high) {\n            if (A[left] <= A[right]) {\n                temp[i++] = A[left++];\n            } else {\n                count += mid - left + 1;\n                temp[i++] = A[right++];\n            }\n        }\n        while (left <= mid)\n            temp[i++] = A[left++];\n        while (right <= high)\n            temp[i++] = A[right++];\n        for (int j = 0; j < temp.length; j++)\n            A[j + low] = temp[j];\n        return count;\n    }\n\n    public static int mergeSort(int[] A, int low, int high) {\n        if (low == high) return 0;\n        int mid = (low + high) / 2;\n        int count = 0;\n        count += mergeSort(A, low, mid);\n        count += mergeSort(A, mid + 1, high);\n        count += merge(A, low, mid, high);\n        return count;\n    }\n\n    public static int numberOfInversions(int[] A, int n) {\n        // Write your code here.\n        return mergeSort(A, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {5, 4, 3, 2, 1};\n//        int[] arr = {1, 2, 3, 4, 5};\n        int inversions = numberOfInversions(arr, arr.length);\n        System.out.println(inversions);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'e4424197-c3ac-44d6-a522-6f19f180616b',
                  isFolder: false,
                  name: 'FourSum.java',
                  code: 'import java.util.*;\n\npublic class FourSum {\n    public static void fourSum(int[] A, int target) {\n        int n = A.length;\n//        BETTER APPROACH\n//         HashSet<List<Integer>> unique = new HashSet<>();\n//         for (int i = 0; i < n; i++) {\n//             for (int j = i + 1; j < n; j++) {\n//                 HashSet<Integer> hs = new HashSet<>();\n//                 for (int k = j + 1; k < n; k++) {\n//                     int fourth = target - (A[i] + A[j] + A[k]);\n//                     if (hs.contains(fourth)) {\n//                         List<Integer> temp = Arrays.asList(A[i], A[j], A[k], fourth);\n//                         temp.sort(null);\n//                         unique.add(temp);\n//                     }\n//                     hs.add(A[k]);\n//                 }\n//             }\n//         }\n//         List<List<Integer>> X = new ArrayList<>(unique);\n\n//        BEST APPROACH\n       Arrays.sort(A);\n       List<List<Integer>> ans = new ArrayList<>();\n       for (int i = 0; i < n; i++) {\n           if (i > 0 && A[i] == A[i - 1]) continue;\n           for (int j = i + 1; j < n - 1; j++) {\n               if (j > i+1 && A[j] == A[j - 1]) continue;\n               int k = j + 1;\n               int l = n - 1;\n               while (k < l) {\n                   int sum = A[i];\n                   sum += A[j];\n                   sum += A[k];\n                   sum += A[l];\n                   if (sum > target) l--;\n                   else if (sum < target) k++;\n                   else {\n                       ans.add(Arrays.asList(A[i], A[j], A[k], A[l]));\n                       k++;\n                       l--;\n                       while (k < l && A[k] == A[k - 1]) k++;\n                       while (k < l && A[l] == A[l + 1]) l--;\n                   }\n               }\n           }\n       }\n       System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 0, -1, 0, -2, 2};\n        fourSum(arr, 0);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'da037614-f410-4660-9c2a-a69f838fc69a',
                  isFolder: false,
                  name: 'LargestSubArray0Sum.java',
                  code: 'import java.util.HashMap;\n\npublic class LargestSubArray0Sum {\n    public static int longestSubArrayWith0Sum(int[] arr) {\n        int longest = 0;\n//        Better solution O(N^2)\n//        for (int i = 0; i < arr.length; i++) {\n//            int sum = 0;\n//            for (int j = i; j < arr.length; j++) {\n//                sum += arr[j];\n//                if (sum == 0)\n//                    longest = Math.max(longest, j - i + 1);\n//            }\n//        }\n\n//        Best solution\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n            if (sum == 0)\n                longest = Math.max(longest, i + 1);\n            else if (hm.containsKey(sum))\n                longest = Math.max(longest, i - hm.get(sum));\n            if (!hm.containsKey(sum)) hm.put(sum, i);\n        }\n        return  longest;\n    }\n    public static void main(String[] args) {\n        int[] arr = {9, -3, 3, -1, 6, -5};\n        int ans = longestSubArrayWith0Sum(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'f5af337d-ea61-41f5-aaad-eddf2790856d',
                  isFolder: false,
                  name: 'MajorityElementNBy3.java',
                  code: 'import java.util.*;\n\npublic class MajorityElementNBy3 {\n    public static void printMajorityElements(int[] arr) {\n        List<Integer> ans = new ArrayList<>();\n        int majority = (arr.length / 3) + 1;\n//        Better approach\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        for (int j : arr) {\n//            hm.put(j, hm.getOrDefault(j, 0) + 1);\n//        }\n//        for (Map.Entry<Integer, Integer> x: hm.entrySet()) {\n//            if (x.getValue() > majority) ans.add(x.getKey());\n//            if (ans.size() == 2) break;\n//        }\n\n//        Best approach\n        int c1 = 0, c2 = 0, e1 = -1, e2 = -1;\n        for (int j : arr) {\n            if (c1 == 0 && e2 != j) {\n                c1 = 1;\n                e1 = j;\n            } else if (c2 == 0 && e1 != j) {\n                c2 = 1;\n                e2 = j;\n            } else if (j == e1) c1++;\n            else if (j == e2) c2++;\n            else {\n                c1--;\n                c2--;\n            }\n        }\n//        We got elements\n        c1 = 0;\n        c2 = 0;\n        for (int i: arr) {\n            if (i == e1) c1++;\n            else if (i == e2) c2++;\n        }\n        if (c1 >= majority) ans.add(e1);\n        if (c2 >= majority) ans.add(e2);\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 1, 1, 3, 1, 4, 5, 6};\n        printMajorityElements(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '4ed49bac-7a42-43d5-b126-fef61920a152',
                  isFolder: false,
                  name: 'MaximumProductSubArray.java',
                  code: 'public class MaximumProductSubArray {\n    public static int subarrayWithMaxProduct(int []arr){\n        // Brute force\n//        int maxProd = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int prod = arr[i];\n//            for (int j = i+1; j < arr.length; j++) {\n//                prod *= arr[j];\n//                maxProd = Math.max(maxProd, prod);\n//            }\n//        }\n//        return maxProd;\n        // Best approach\n        int maxProd = arr[0];\n        int prodLeft = 1;\n        int prodRight = 1;\n        for (int i = 0; i < arr.length; i++) {\n            prodLeft *= arr[i];\n            prodRight *= arr[arr.length - i - 1];\n            maxProd = Math.max(maxProd, Math.max(prodLeft, prodRight));\n            if (prodLeft == 0) prodLeft++;\n            if (prodRight == 0) prodRight++;\n        }\n        return maxProd;\n    }\n    public static void main(String[] args) {\n        int[] arr = {-2, 3, -4, 0};\n        int ans = subarrayWithMaxProduct(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'adc3e992-3138-44a2-8bbd-4f11baf422aa',
                  isFolder: false,
                  name: 'MergeOverlappingSubIntervals.java',
                  code: 'import java.util.*;\n\npublic class MergeOverlappingSubIntervals {\n    public static void mergeIntervals(int[][] arr) {\n        Arrays.sort(arr, Comparator.comparingInt(a -> a[0]));\n        int start = arr[0][0], end = arr[0][1];\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 1; i < arr.length; i++) {\n            if (end >= arr[i][0])\n                end = Math.max(end, arr[i][1]);\n            else {\n                ans.add(Arrays.asList(start, end));\n                start = arr[i][0];\n                end = arr[i][1];\n            }\n        }\n        ans.add(Arrays.asList(start, end));\n        System.out.println(ans);\n    }\n    public static void main(String[] args) {\n//        int[][] arr = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n        int[][] arr = {{1, 4}, {4, 5}};\n        mergeIntervals(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'ae536814-504a-43d9-9f87-51066516200d',
                  isFolder: false,
                  name: 'MergeTwoSortedArrays.java',
                  code: 'import java.util.Arrays;\n\npublic class MergeTwoSortedArrays {\n//    Variation 1\n    public static void mergeSortedArrays(int[] a, int[] b, int m, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        while (j >= 0) {\n            if (a[i] >= b[j])\n                a[k--] = a[i--];\n            else\n                a[k--] = b[j--];\n        }\n        System.out.println(Arrays.toString(a));\n    }\n    public static void mergeSortedArrays2(int[] a, int[] b) {\n        int m = a.length, n = b.length;\n//        int[] temp = new int[m+n];\n//        int left = 0, right = 0, index = 0;\n//        while (left < m && right < n) {\n//            if (a[left] <= b[right]) {\n//                temp[index++] = a[left++];\n//            } else {\n//                temp[index++] = b[right++];\n//            }\n//        }\n//        while (left < m) temp[index++] = a[left++];\n//        while (right < n) temp[index++] = b[right++];\n//        for (int i = 0; i < temp.length; i++) {\n//            if (i < m)\n//                a[i] = temp[i];\n//            else\n//                b[i-m] = temp[i];\n//        }\n        int l = m - 1;\n        int r = 0;\n        while (l >=0 && r < n) {\n            if (a[l] <= b[r]) break;\n            int temp = a[l];\n            a[l--] = b[r];\n            b[r++] = temp;\n        }\n        Arrays.sort(a);\n        Arrays.sort(b);\n        System.out.println(Arrays.toString(a));\n        System.out.println(Arrays.toString(b));\n    }\n\n    public static void main(String[] args) {\n//        Type 1:\n//        int[] a = {1, 4, 8, 10, 0, 0, 0};\n//        int[] b = {2, 3, 9};\n//        mergeSortedArrays(a, b, 4,3);\n        int[] a = {1, 4, 8, 10};\n        int[] b = {2, 3, 9};\n        mergeSortedArrays2(a, b);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'ccf7d3dc-23df-40fa-a768-e075e3ad4667',
                  isFolder: false,
                  name: 'MissingAndDuplicateNumber.java',
                  code: 'public class MissingAndDuplicateNumber {\n    //    Without changing the input array\n    public static void findMissingRepeatingNumbers(int[] arr) {\n//        Mathematical equation technique\n        int n = arr.length;\n        long S = 0;\n        long S2 = 0;\n        long SN = (long) n * (n + 1) /2;\n        long S2N = n * (n + 1) * (2L * n + 1) /6;\n        for (int i : arr) {\n            S += i;\n            S2 += (long) i *i;\n        }\n        long val1 = S - SN; // (X - Y)\n        long val2 = S2 - S2N; // (X - Y) (X + Y)\n        long x = (val2/val1 + val1)/2;\n        long y = x - val1;\n        System.out.println("x: " + x + " y: " + y);\n\n//        int[] count = new int[arr.length];\n//        for (int i : arr) {\n//            count[i - 1]++;\n//        }\n//        int missing = -1, duplicate = -1;\n//        for (int i = 0; i < count.length; i++) {\n//            if (count[i] == 0)\n//                missing = i+1;\n//            else if (count[i] == 2)\n//                duplicate = i+1;\n//            if (missing != -1 && duplicate != -1) break;\n//        }\n//        System.out.println(Arrays.asList(duplicate, missing));\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 1, 2, 5, 3};\n        findMissingRepeatingNumbers(arr);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'db4d8916-074f-4526-8678-4b1e96cd2b76',
                  isFolder: false,
                  name: 'PascalsTriangle.java',
                  code: "import java.util.Arrays;\n\npublic class PascalsTriangle {\n    //    static int fact(int x) {\n//        int product = 1;\n//        for (int i = 2; i <= x; i++)\n//            product *= i;\n//        return product;\n//    }\n    static int getNCR(int n, int r) {\n//        int numerator = fact(n);\n//        int denominator = fact(r) * fact(n-r);\n//        return (int) (numerator / denominator);\n        long res = 1;\n        for (int i = 0; i < r; i++) {\n            res *= n - i;\n            res /= i + 1;\n        }\n        return (int) res;\n    }\n\n    //    Type 1:  Given row r and column c. Print the element at position (r, c) in Pascal's triangle.\n    public static int getTriangleValue(int row, int col) {\n        return getNCR(row - 1, col - 1);\n    }\n\n    //    Type 2: Given the row number n. Print the n-th row of Pascal's triangle.\n    public static int[] printRowPascalsTriangle(int n) {\n        int[] arr = new int[n];\n        int ans = 1;\n        arr[0] = ans;\n        for (int i = 1; i < n; i++) {\n            ans *= n - i;\n            ans /= i;\n            arr[i] = ans;\n        }\n//        for (int i = 0; i < n; i++) {\n//            ans[i] = getNCR(n-1, i);\n//        }\n        return arr;\n    }\n\n    //    Type 3: Given the number of rows n. Print the first n rows of Pascal's triangle.\n    public static void printPascalsTriangle(int n) {\n        int[][] ans = new int[n][];\n        for (int i = 1; i <= n; i++) {\n            ans[i-1] = printRowPascalsTriangle(i);\n        }\n        for (int[] a: ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n\n    public static void main(String[] args) {\n        int ans = getTriangleValue(5, 3);\n        System.out.println(ans);\n        int[] row = printRowPascalsTriangle(5);\n        System.out.println(Arrays.toString(row));\n        printPascalsTriangle(9);\n    }\n}",
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: '28e50951-e01b-4ca1-b4d3-54c9808bc0c4',
                  isFolder: false,
                  name: 'ReversePairs.java',
                  code: 'public class ReversePairs {\n    public static int countPairs(int[] A, int low, int mid, int high) {\n        int count = 0;\n        int right = mid + 1;\n        for (int i = low; i <= mid; i++) {\n            while (right <= high && A[i] > 2*A[right]) {\n                right++;\n            }\n            count += right - mid - 1;\n        }\n        return count;\n    }\n\n    public static void merge(int[] A, int low, int mid, int high) {\n        int left = low, right = mid + 1, i = 0;\n        int[] temp = new int[high - low + 1];\n        while (left <= mid && right <= high) {\n            if (A[left] <= A[right])\n                temp[i++] = A[left++];\n            else\n                temp[i++] = A[right++];\n        }\n        while (left <= mid)\n            temp[i++] = A[left++];\n        while (right <= high)\n            temp[i++] = A[right++];\n        for (int j = 0; j < temp.length; j++)\n            A[j + low] = temp[j];\n    }\n\n    public static int mergeSort(int[] A, int low, int high) {\n        if (low == high) return 0;\n        int mid = (low + high) / 2;\n        int count = 0;\n        count += mergeSort(A, low, mid);\n        count += mergeSort(A, mid + 1, high);\n        count += countPairs(A, low, mid,  high);\n        merge(A, low, mid, high);\n        return count;\n    }\n\n    public static int reversePairsCount(int[] A, int n) {\n        // Write your code here.\n        return mergeSort(A, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 1, 2, 3, 1};\n        int count = reversePairsCount(arr,  5);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'd69fdc1b-a315-4ffd-bd77-12006d7f1099',
                  isFolder: false,
                  name: 'SubArraysWithXORK.java',
                  code: 'import java.util.HashMap;\n\npublic class SubArraysWithXORK {\n    public static int getSubArrayCountWithXORK (int[] arr, int k) {\n//        Best solution\n        int count = 0;\n        int xor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        for (int i = 0; i < arr.length; i++) {\n            xor ^= arr[i];\n            if (hm.containsKey(xor^k)) {\n                count += hm.get(xor^k);\n            }\n            hm.put(xor, hm.getOrDefault(xor, 0)+1);\n        }\n        return count;\n\n//        Better Solution\n//        int count = 0;\n//        for (int i = 0; i < arr.length; i++) {\n//            int xor = 0;\n//            for (int j = i; j < arr.length; j++) {\n//                xor ^= arr[j];\n//                if (xor == k)\n//                    count++;\n//            }\n//        }\n//        return count;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 6, 7, 8, 9};\n        int count = getSubArrayCountWithXORK(arr, 5);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'd6a63c3f-0f0d-4e2e-8f3c-d6c2ddcaeb2d',
                  isFolder: false,
                  name: 'ThreeSum.java',
                  code: 'import java.util.*;\n\npublic class ThreeSum {\n    public static List<List<Integer>> threeSum(int[] arr) {\n//        HashSet<List<Integer>> hs = new HashSet<>();\n//        for (int i = 0; i < arr.length; i++) {\n//            HashMap<Integer, Integer> hm = new HashMap<>();\n//            for (int j = i+1; j < arr.length; j++) {\n//                int temp = -1 * (arr[i] + arr[j]);\n//                if (hm.containsKey(temp)) {\n//                    List<Integer> tempArr = new ArrayList<>(Arrays.asList(arr[i], arr[j], temp));\n//                    tempArr.sort(null);\n//                    hs.add(tempArr);\n//                }\n//                hm.put(arr[j], j);\n//            }\n//        }\n//        return new ArrayList<>(hs);\n        int n = arr.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(arr);\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && arr[i] == arr[i-1]) continue;\n            int j = i + 1;\n            int k = n - 1;\n            while (j < k) {\n                int sum = arr[i] + arr[j] + arr[k];\n                if (sum < 0) {\n                    j++;\n                } else if (sum > 0) {\n                    k--;\n                } else {\n                    ans.add(Arrays.asList(arr[i], arr[j], arr[k]));\n                    j++;\n                    k--;\n                    while (j < k && arr[j] == arr[j-1]) j++;\n                    while (j < k && arr[k] == arr[k+1]) k--;\n                }\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int[] arr = {-1, 0, 1, 0};\n        List<List<Integer>> ans = threeSum(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['HARD'],
                },
                {
                  id: 'c3a16f8e-8e89-40f3-8c93-3db8957f2192',
                  isFolder: false,
                  name: 'ArrayMaxSumSubarray.java',
                  code: 'import java.util.Arrays;\n\npublic class ArrayMaxSumSubarray {\n    public static int[] getMaxSubarraySumArray(int[] arr) {\n        int start = -1, end = -1;\n        int sum = 0, maxSum = arr[0];\n        int temp = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum == 0) temp = i;\n            sum += arr[i];\n            if (maxSum < sum) {\n                maxSum = sum;\n                start = temp;\n                end = i;\n            }\n            if (sum < 0) sum = 0;\n        }\n\n        System.out.println(start + " " + end);\n        return Arrays.copyOfRange(arr, start, end+1);\n    }\n\n    public static int getMaxSubarraySumLength(int[] arr) {\n        int start = -1, end = -1, temp = 0;\n        int sum = 0, maxSum = arr[0];\n        for (int i = 0; i < arr.length; i++) {\n            if (sum == 0) temp = i;\n            sum += arr[i];\n            if (maxSum < sum) {\n                maxSum = sum;\n                start = temp;\n                end = i;\n            }\n            if (sum < 0) sum = 0;\n        }\n        return end - start+1;\n    }\n\n    public static int getMaxSubarraySum(int[] arr) {\n        int sum = 0, maxSum = arr[0];\n        for (int j : arr) {\n            sum += j;\n            if (maxSum < sum) maxSum = sum;\n            if (sum < 0) sum = 0;\n        }\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n//        TESTING\n//        int[] arr = {-4, 1, -2, 1, 5, -3, 1, 3, -1, -2};\n//        int[] arr = {-4, -1, -2, -1, -5, -3, 1, -3, -1, -2};\n        int[] arr = {-4, 1, 2, 1, -5, 3, 1, 3, 1, -2};\n//        int[] arr = {-4, 5, 7, -6, 10, -15, 3};\n//        int[] arr = {-3, 2, -1, 4, -2};\n//        int[] arr = {-1,2};\n//        int[] arr = {-2,-1};\n        int ans = getMaxSubarraySumLength(arr);\n        int[] ansArray = getMaxSubarraySumArray(arr);\n        int ansSum = getMaxSubarraySum(arr);\n        System.out.println("Length: " + ans);\n        System.out.println("Sum: " + ansSum);\n        System.out.println("Array: " + Arrays.toString(ansArray));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: 'ccf730c4-1abf-4818-bd0a-4d7efe6bc1df',
                  isFolder: false,
                  name: 'LongestConsecutiveSequence.java',
                  code: 'import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class LongestConsecutiveSequence {\n    public static boolean found(int[] arr, int target) {\n        for (int i : arr)\n            if (target == i) return true;\n        return false;\n    }\n\n    public static int longestConsecutiveSequenceLength(int[] arr) {\n//        Brute force: O(N^2) time\n//        int longest = 1;\n//        for (int j : arr) {\n//            int count = 1;\n//            int x = j;\n//            while (found(arr, x+1)) {\n//                x++;\n//                count++;\n//            }\n//            longest = Math.max(longest, count);\n//        }\n//        return longest;\n\n//        Better Solution\n//        Arrays.sort(arr);\n//        int longest = 1;\n//        int currentCount = 0;\n//        int last = Integer.MIN_VALUE;\n//        for (int i = 0; i < arr.length; i++) {\n//            if (arr[i] - 1 == last) {\n//                currentCount++;\n//            } else if (arr[i] != last) {\n//                currentCount = 1;\n//            }\n//            longest = Math.max(longest, currentCount);\n//            last = arr[i];\n//        }\n//        return longest;\n\n//        Best\n        int longest = 1;\n        HashSet<Integer> hs = new HashSet<>();\n        for (int i : arr) {\n            hs.add(i);\n        }\n        for (int j : arr) {\n            if (!hs.contains(j - 1)) {\n                int count = 1;\n                int element = j;\n                while (hs.contains(element + 1)) {\n                    count++;\n                    element++;\n                }\n                longest = Math.max(longest, count);\n            }\n        }\n        return longest;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 9, 4, 5};\n        int ans = longestConsecutiveSequenceLength(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '2e905509-09be-4b33-980e-56d7864434ff',
                  isFolder: false,
                  name: 'NextPermutation.java',
                  code: 'import java.util.Arrays;\n\npublic class NextPermutation {\n    // Reverse\n    public static void reverse(int[] arr, int start, int end) {\n        while (start < end) {\n            swap(arr, start++, end--);\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static int[] nextPermutation(int[] arr) {\n        int n = arr.length;\n        int bp = -1;\n        for (int i = n - 1; i > 0; i--) {\n            if (arr[i] > arr[i - 1]) {\n                bp = i - 1;\n                break;\n            }\n        }\n        if (bp == -1) {\n            reverse(arr, 0, n - 1);\n            return arr;\n        }\n//        Ceiling\n        for (int j = n - 1; j > bp; j--) {\n            if (arr[j] > arr[bp]) {\n                swap(arr, j, bp);\n                break;\n            }\n        }\n        reverse(arr, bp+1, n - 1);\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 2};\n        int[] ans = nextPermutation(arr);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '4472c323-60e8-4365-8cd9-2b8763f3c64a',
                  isFolder: false,
                  name: 'RotateBy90.java',
                  code: 'import java.util.Arrays;\n\npublic class RotateBy90 {\n    public static  void reverse (int[] arr) {\n        int start = 0, end = arr.length - 1;\n        while (start < end) {\n            int temp = arr[start];\n            arr[start++] = arr[end];\n            arr[end--] = temp;\n        }\n    }\n    public static void rotateMatrix(int[][] mat) {\n        // Brute force solution\n//        int[][] newMat = new int[mat.length][mat[0].length];\n//        for (int r = 0; r < mat.length; r++) {\n//            for (int c = 0; c < mat[r].length; c++) {\n//                newMat[c][mat[r].length - r - 1] = mat[r][c];\n//            }\n//        }\n//        return newMat;\n//                if (r != c) System.out.println("r: "+r + " c: " + c + " A: " + mat[r][c] + " B: " + mat[c][r]);\n        // Best solution\n        for (int r = 0; r < mat.length; r++) {\n            for (int c = r; c < mat[r].length; c++) {\n                int temp = mat[r][c];\n                mat[r][c] = mat[c][r];\n                mat[c][r] = temp;\n            }\n        }\n        for (int[] row : mat) reverse(row);\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 9},\n        };\n        rotateMatrix(mat);\n        for (int[] a : mat) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: 'c9b434c6-112e-47dd-87c8-3c886375d439',
                  isFolder: false,
                  name: 'SetMatrixZero.java',
                  code: 'import java.util.Arrays;\n\npublic class SetMatrixZero {\n    //    Helper functions\n    public static void setRow(int[][] mat, int index) {\n        for (int i = 0; i < mat.length; i++)\n            mat[index][i] = -1;\n    }\n\n    public static void setCol(int[][] mat, int index) {\n        for (int i = 0; i < mat.length; i++)\n            mat[i][index] = -1;\n    }\n\n    public static int[][] setMatrixZero(int[][] mat) {\n//        Brute force\n//        for (int i = 0; i < mat.length; i++) {\n//            for (int j = 0; j < mat[i].length; j++) {\n//                if (mat[i][j] == 0) {\n//                    setRow(mat, i);\n//                    setCol(mat, j);\n//                }\n//            }\n//        }\n//        for (int i = 0; i < mat.length; i++)\n//            for (int j = 0; j < mat[i].length; j++)\n//                if (mat[i][j] == -1) mat[i][j] = 0;\n\n//        Better\n//        int[] rows = new int[mat.length];\n//        int[] cols = new int[mat[0].length];\n//        for (int i = 0; i < mat.length; i++) {\n//            for (int j = 0; j < mat[i].length; j++) {\n//                if (mat[i][j] == 0) {\n//                    rows[i] = -1;\n//                    cols[j] = -1;\n//                }\n//            }\n//        }\n//        for (int i = 0; i < mat.length; i++)\n//            for (int j = 0; j < mat[i].length; j++)\n//                if (cols[j] == -1 || rows[i] == -1) mat[i][j] = 0;\n\n//        Best\n        int col0 = 1;\n        for (int i = 0; i < mat.length; i++) {\n            if (mat[i][0] == 0) col0 = 0; // One column\n            // Rest of the columns\n            for (int j = 1; j < mat[i].length; j++) {\n                if (mat[i][j] == 0) {\n                    mat[i][0] = 0;\n                    mat[0][j] = 0;\n                }\n            }\n        }\n        for (int r = mat.length  - 1; r >= 0; r--) {\n            for (int c = mat[r].length - 1; c > 0; c--) {\n                if (mat[r][0] == 0 || mat[0][c] == 0) mat[r][c] = 0;\n            }\n            // First column\n            if (col0 == 0) {\n                mat[r][0] = 0;\n            }\n        }\n\n        return mat;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 1, 1, 1},\n                {1, 0, 0, 1},\n                {1, 1, 0, 1},\n                {1, 1, 1, 1}\n        };\n        int[][] ans = setMatrixZero(mat);\n        for (int[] a : ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: '42e5204a-8753-480c-9359-9b6f4ebe957f',
                  isFolder: false,
                  name: 'SpiralMatrix1.java',
                  code: 'import java.util.Arrays;\n\npublic class SpiralMatrix1 {\n    public static int[] printSpiralMatrix(int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n        int rStart = 0, rEnd = n - 1;\n        int cStart = 0, cEnd = m - 1;\n        int[] ans = new int[n*m];\n        int index = 0;\n        while (rStart <= rEnd && cStart <= cEnd) {\n//            LR\n            for (int i = cStart; i <= cEnd; i++) {\n                ans[index++] = mat[rStart][i];\n            }\n            rStart++;\n//            TB\n            for (int i = rStart; i <= rEnd; i++) {\n                ans[index++] = mat[i][cEnd];\n            }\n            cEnd--;\n            if (index == n*m) break;\n//            RL\n            for (int i = cEnd; i >= cStart; i--) {\n                ans[index++] = mat[rEnd][i];\n            }\n            rEnd--;\n//            BT\n            for (int i = rEnd; i >= rStart; i--) {\n                ans[index++] = mat[i][cStart];\n            }\n            cStart++;\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int[][] mat = {\n                { 1, 2, 3 },\n                { 4, 5, 6 },\n                { 7, 8, 9 }\n        };\n        int[] ans = printSpiralMatrix(mat);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
                {
                  id: 'fe486b0a-e8db-4779-8202-7fe8f9e3bb4f',
                  isFolder: false,
                  name: 'SubArraysWithGivenSum.java',
                  code: 'import java.util.HashMap;\n\npublic class SubArraysWithGivenSum {\n    public static int getSubArraysWithGivenSum(int[] arr, int k) {\n        // This solution wont handle negative numbers\n//        int l = 0, r = 0;\n//        int count = 0;\n//        int sum = 0;\n//        while (r < arr.length) {\n//            sum += arr[r];\n//            while (l <= r && sum > k)\n//                sum -= arr[l++];\n//            if (sum == k) count++;\n//            r++;\n//        }\n//        return count;\n//        This can handle positive and negative numbers\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        hm.put(0, 1);\n        int count = 0, sum = 0;\n        for (int j : arr) {\n            sum += j;\n            if (hm.containsKey(sum - k))\n                count += hm.get(sum - k);\n            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, -3, 1, 1, 1, 4, 2, -3};\n        int ans = getSubArraysWithGivenSum(arr, 3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['MEDIUM'],
                },
              ],
            },
            {
              id: 'dd2a1d71-8e58-4d55-9bf0-3f291eead4cb',
              isFolder: true,
              name: 'Binary Search',
              content: [
                {
                  id: '88a8b204-84d8-48c5-83a7-6fbf2de28eec',
                  isFolder: false,
                  name: 'CeilAndFloor.java',
                  code: 'import java.util.*;\nimport java.io.*;\n\npublic class CeilAndFloor {\n    public static int floor(int[] arr, int target, int n) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n\n    public static int ceil(int[] arr, int target, int n) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static int ceilingInSortedArray(int n, int x, int[] arr) {\n        // Write your code here.\n        Arrays.sort(arr);\n        int ceilElement = ceil(arr, x, n);\n        int floorElement = floor(arr, x, n);\n        if (ceilElement != n) {\n            ceilElement = arr[ceilElement];\n        } else {\n            ceilElement = -1;\n        }\n        if (floorElement != -1) {\n            floorElement = arr[floorElement];\n        }\n\n        System.out.print(floorElement + " ");\n        return ceilElement;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {48, 26, 2, 6, 10, 48, 11, 21, 47, 50, 50, 45, 43, 27};\n        int ans = ceilingInSortedArray(arr.length, 51, arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '3017d629-7964-4ca0-b6fb-439b3d1b9203',
                  isFolder: false,
                  name: 'CountOccurrencesSortedArrayWithDuplicates.java',
                  code: 'public class CountOccurrencesSortedArrayWithDuplicates {\n    public static int count(int[] arr, int n, int x) {\n        //Your code goes here\n        int first = bs(arr, x, true);\n        if (first == -1)\n            return 0;\n        int second = bs(arr, x, false);\n        return second - first + 1;\n    }\n\n    public static int bs(int[] arr, int target, boolean lookLeft) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] == target) {\n                ans = mid;\n                if (lookLeft)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            } else if (arr[mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 1, 2, 2, 3, 3};\n        int count = count(arr, arr.length,1);\n        System.out.println(count);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '7747661c-974a-4e5f-bbb8-73072312f923',
                  isFolder: false,
                  name: 'FindMinimumRotatedSortedArray.java',
                  code: 'public class FindMinimumRotatedSortedArray {\n    public static int getMinimumInRotatedSortedArray(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n//            Condition to handle duplicates\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                ans = Math.min(ans, arr[start]);\n                end--;\n                continue;\n            }\n            if (arr[mid] > arr[end]) {\n                // left sorted\n                ans = Math.min(ans, arr[start]);\n                start = mid + 1;\n            } else {\n                // right sorted\n                ans = Math.min(ans, arr[mid]);\n                end = mid - 1;\n            }\n        }\n        return ans;\n    }\n\n    public static int getPivot(int[] arr) {\n//        PIVOT: Index of the point till where the array is rotated (MAX Element)\n        int start = 0;\n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (mid < end && arr[mid] > arr[mid + 1]) return mid;\n            if (mid > start && arr[mid - 1] > arr[mid]) return mid - 1;\n            if (arr[mid] > arr[end])\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 1, 3, 3, 3, 3, 3};\n        int ans = getMinimumInRotatedSortedArray(arr);\n        System.out.println(ans);\n        int pivot = getPivot(arr);\n        System.out.println(pivot + 1);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '3113e231-2f33-4016-93ac-72a6ade12582',
                  isFolder: false,
                  name: 'FindPeakElement.java',
                  code: 'public class FindPeakElement {\n    public static int getPeakIndex(int[] arr) {\n//        Brute force solution\n//        int n = arr.length;\n//        if (n == 1 || arr[0] > arr[1]) return 0;\n//        if (arr[n-1] > arr[n-2]) return n-1;\n//        for (int i = 1; i < arr.length - 1; i++) {\n//            if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {\n//                return i;\n//            }\n//        }\n//        return -1;\n//        Optimised approach\n        int n = arr.length;\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            boolean isLeftBig = mid > start && arr[mid - 1] > arr[mid];\n            boolean isRightBig = mid < end && arr[mid + 1] > arr[mid];\n            if (!isLeftBig && !isRightBig) return mid;\n            if (isLeftBig) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1,2,1,3,4};\n        int ans = getPeakIndex(arr);\n        System.out.println(arr[ans]);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '446f2551-1fdb-4b74-ab0c-da9de5b6cc5a',
                  isFolder: false,
                  name: 'FirstAndLastPosition.java',
                  code: 'import java.util.* ;\nimport java.io.*;\npublic class FirstAndLastPosition {\n    public static int lower_bound(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) >= k) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static int upper_bound(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) > k) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public  static int bSearchFirstLast(ArrayList<Integer> arr, int target, boolean lookLeft) {\n        int start = 0;\n        int end = arr.size() - 1;\n        int ans = -1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr.get(mid) == target) {\n                ans = mid;\n                if (lookLeft)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n            else  if (arr.get(mid) > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return ans;\n    }\n\n    public static int[] firstAndLastPosition(ArrayList<Integer> arr, int n, int k) {\n        // Write your code here.\n//        int first = lower_bound(arr, n, k);\n//        int last = upper_bound(arr, n, k) - 1;\n        int first = bSearchFirstLast(arr, k, true);\n        int last = bSearchFirstLast(arr, k, false);\n        return new int[] {first, last};\n    }\n\n};',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '9241e424-df76-46c9-b895-aaeec7587622',
                  isFolder: false,
                  name: 'LowerBound.java',
                  code: 'public class LowerBound {\n//    Brute force is Linear search or a simple for loop\n\n//    If the arr has duplicates go left\n    public static int lowerBound(int []arr, int n, int x) {\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] >= x)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 3, 3, 5};\n//        int[] arr = {1, 2, 2, 2, 2, 2};\n        int ans = lowerBound(arr, arr.length, 2);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '1969dd3c-405f-49a1-b8a5-a78a88860f4f',
                  isFolder: false,
                  name: 'SearchIndexPosition.java',
                  code: 'public class SearchIndexPosition {\n    public static int searchInsert(int [] arr, int m){\n        // Write your code here.\n        int start = 0; \n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] >= m) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 4, 7};\n        int ans = searchInsert(arr, 9);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '444aba35-7159-48fa-81f4-997f4380f992',
                  isFolder: false,
                  name: 'SearchInRotatedArray1.java',
                  code: 'import java.util.*;\n\npublic class SearchInRotatedArray1 {\n    public static int search(ArrayList<Integer> arr, int n, int k) {\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int midValue = arr.get(mid);\n            if (midValue == k) return mid;\n            if (midValue < arr.get(end)) {\n                if (k > midValue && k <= arr.get(end))\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            } else {\n                if (k >= arr.get(start) && k < midValue)\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(8, 9, 4, 5));\n        int search = search(arr, 4, 8);\n        System.out.println(search);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '14dcb691-c8e3-43e7-9852-3b44dcfc4889',
                  isFolder: false,
                  name: 'SearchInRotatedArray2.java',
                  code: 'public class SearchInRotatedArray2 {\n    public static boolean searchInARotatedSortedArrayII(int[] arr, int k) {\n        int start = 0;\n        int end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] == k) return true;\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                start++;\n                end--;\n                continue;\n            }\n            if (arr[mid] < arr[end]) { //Right sorted\n                if (k > arr[mid] && k <= arr[end])\n                    start = mid + 1;\n                else\n                    end = mid - 1;\n            } else { // Left sorted\n                if (k >= arr[start] && k < arr[mid])\n                    end = mid - 1;\n                else\n                    start = mid + 1;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 1, 3, 3, 3, 3};\n        boolean found = searchInARotatedSortedArrayII(arr, 10);\n        System.out.println(found);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '7d6ed95a-cd12-487c-bdd1-ba3e908deefb',
                  isFolder: false,
                  name: 'SingleNonDuplicateElementSortedArray.java',
                  code: 'public class SingleNonDuplicateElementSortedArray {\n    public static int singleNonDuplicate(int[] arr) {\n//        Write the code here\n//        int n = arr.length;\n//        for (int i = 0; i < n; i++) {\n//            if (i == 0) {\n//                if (arr[0] != arr[1])\n//                    return 0;\n//            } else if (i == n - 1) {\n//                if (arr[n-1] != arr[n-2])\n//                    return n-1;\n//            } else {\n//                if (arr[i-1] != arr[i] && arr[i+1] != arr[i])\n//                    return i;\n//            }\n//        }\n//        return -1;\n        int n = arr.length;\n        if (n == 1) return arr[0];\n        if (arr[0] != arr[1]) return arr[0];\n        if (arr[n-1] != arr[n-2]) return arr[n-1];\n        int start = 1;\n        int end = n-2;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] != arr[mid + 1] && arr[mid] != arr[mid - 1]) return arr[mid];\n            if ((mid%2==0 && arr[mid] == arr[mid+1]) || (mid%2==1 && arr[mid] == arr[mid - 1])) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6};\n        int ans = singleNonDuplicate(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '70e7f2ec-779a-4e12-ada6-90138896ee61',
                  isFolder: false,
                  name: 'SortedArrayRotationCount.java',
                  code: 'public class SortedArrayRotationCount {\n    public static int findKRotation(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n        int ans = Integer.MAX_VALUE;\n        int idx = 0;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n//            For removing duplicates\n            if (arr[mid] == arr[start] && arr[mid] == arr[end]) {\n                if (ans > arr[mid]) {\n                    ans = arr[mid];\n                    idx = mid;\n                }\n                end--;\n                continue;\n            }\n            if (arr[mid] > arr[end]) {\n                if (ans > arr[start]) {\n                    ans = arr[start];\n                    idx = start;\n                }\n                start = mid + 1;\n            } else {\n                if (ans > arr[mid]) {\n                    ans = arr[mid];\n                    idx = mid;\n                }\n                end = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 4, 4, 4, 4, 4, 4, 4};\n        int ans = findKRotation(arr);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '653a9a69-d04c-402e-9bec-eb076aeed3e7',
                  isFolder: false,
                  name: 'UpperBound.java',
                  code: 'public class UpperBound {\n    public static int upperBound(int[] arr, int x, int n) {\n        // Write your code here.\n        int start = 0;\n        int end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (arr[mid] <= x) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 14, 16, 23};\n        int ans = upperBound(arr, 12, arr.length);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 1D arrays'],
                },
                {
                  id: '29fe6af1-74ca-41e8-bdfe-2c385f6d939d',
                  isFolder: false,
                  name: 'FindPeakElementInGrid.java',
                  code: 'import java.util.Arrays;\n\npublic class FindPeakElementInGrid {\n    public static int[] findPeakGrid(int [][]mat) {\n// Brute force solution\n//        int n = mat.length;\n//        int m = mat[0].length;\n//        int max = Integer.MIN_VALUE;\n//        int[] ans = {-1, -1};\n//        for (int i = 0; i < n; i++) {\n//            for (int j = 0; j < m; j++) {\n//                if (mat[i][j] > max) {\n//                    max = mat[i][j];\n//                    ans[0] = i;\n//                    ans[1] = j;\n//                }\n//            }\n//        }\n//        return ans;\n\n        // Optimal solution\n        int start = 0;\n        int end = mat[0].length - 1;\n        while (start <= end) {\n            int maxRow = 0;\n            int mid = start + (end - start)/2;\n            for (int i = 0; i < mat.length; i++) {\n                if (mat[maxRow][mid] < mat[i][mid])\n                    maxRow = i;\n            }\n            boolean leftBig = mid > start && mat[maxRow][mid] < mat[maxRow][mid-1];\n            boolean rightBig = mid < end && mat[maxRow][mid] < mat[maxRow][mid+1];\n            if (!leftBig && !rightBig) return new int[]{maxRow, mid};\n            if (leftBig) end = mid - 1;\n            else start = mid + 1;\n        }\n        return new int[]{-1, -1};\n    }\n\n    public static void main(String[] args) {\n        int[][] values = {\n                {6},\n                {1},\n                {10}\n        };\n        int[] ans = findPeakGrid(values);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '898ca873-429d-492a-9167-28e02d958af5',
                  isFolder: false,
                  name: 'MatrixMaximumOnesRow.java',
                  code: 'import java.util.ArrayList;\n\npublic class MatrixMaximumOnesRow {\n    public static int maximumOnesRow(ArrayList<ArrayList<Integer>> matrix, int n, int m) {\n        //\t  Brute force O(m*n)\n//        int maxRow = 0;\n//        int maxCount = 0;\n//        for (int i = 0; i < n; i++) {\n//            int count = 0;\n//            for (int j = 0; j < m; j++) {\n//                if (matrix.get(i).get(j) == 1) count++;\n//            }\n//            if (count > maxCount) {\n//                maxCount = count;\n//                maxRow = i;\n//            }\n//        }\n//        return maxRow;\n\n//        Optimal solution\n        int lastIdx = m - 1;\n        int maxRow = -1;\n        for (int i = 0; i < n; i++) {\n            if (lastIdx < 0) break;\n            if (matrix.get(i).get(lastIdx) == 1) {\n                while (lastIdx >= 0 && matrix.get(i).get(lastIdx) == 1) {\n                    lastIdx--;\n                }\n                maxRow = i;\n            }\n        }\n        return maxRow;\n    }\n\n    public static void main(String[] args) {\n        int[][] values = {\n                {0, 0, 1},\n                {0, 0, 1},\n                {0, 1, 1}\n        };\n\n        // Create a 2D ArrayList and populate it with values from the array\n        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();\n        for (int[] row : values) {\n            ArrayList<Integer> arrayListRow = new ArrayList<>();\n            for (int num : row) {\n                arrayListRow.add(num);\n            }\n            matrix.add(arrayListRow);\n        }\n        int ans = maximumOnesRow(matrix, 3,3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '811813f3-aadf-4a3c-ab65-4374240585d1',
                  isFolder: false,
                  name: 'MatrixMedian.java',
                  code: 'public class MatrixMedian {\n    public static int getCount(int[] arr, int target) {\n        int start = 0, end = arr.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static int findMedian(int[][] M, int m, int n) {\n        // Write your code here\n        int start = 1;\n        int end = 1000000000;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int count = 0;\n            for (int i = 0; i < M.length; i++) {\n                count += getCount(M[i], mid);\n            }\n            if (count <= (n*m)/2) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int row = 3, col = 3;\n        int[][] arr = {{1, 3, 8},\n                {2, 3, 4},\n                {1, 2, 5}};\n        System.out.println("The median of the row-wise sorted matrix is: "+ findMedian(arr, row, col));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '4324effb-13a5-4c72-944a-4891162f74d3',
                  isFolder: false,
                  name: 'Search2DMatrixRowsSorted.java',
                  code: 'import java.util.ArrayList;\n\npublic class Search2DMatrixRowsSorted {\n    //    A Row-wise sorted matrix where the first element of each row is\n//    greater than the last element of previous row\n    static boolean searchMatrix(ArrayList<ArrayList<Integer>> mat, int target) {\n        // Optimised\n        int n = mat.size();\n        int m = mat.get(0).size();\n        int start = 0, end = n*m - 1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int element = mat.get(mid/m).get(mid%m);\n            if (element == target) return true;\n            if (element > target) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        int[][] values = {\n                {1, 2, 4},\n                {6, 7, 8},\n                {9, 10, 34}\n        };\n\n        // Create a 2D ArrayList and populate it with values from the array\n        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();\n        for (int[] row : values) {\n            ArrayList<Integer> arrayListRow = new ArrayList<>();\n            for (int num : row) {\n                arrayListRow.add(num);\n            }\n            matrix.add(arrayListRow);\n        }\n        boolean ans = searchMatrix(matrix, 78);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: '4d675b89-88c8-4025-97d4-bd4e37b22bd4',
                  isFolder: false,
                  name: 'SearchRowColSortedMatrix.java',
                  code: 'import java.util.ArrayList;\n\npublic class SearchRowColSortedMatrix {\n    public static int bS(int[] arr, int target) {\n        int start = 0, end = arr.length;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] > target) end = mid - 1;\n            else start = mid + 1;\n        }\n        return -1;\n    }\n    public static boolean searchElement(int [][]mat, int target) {\n//        Better solution\n//        int n = mat.length;\n//        int m = mat[0].length;\n//        // Write your code here.\n//        for (int i = 0; i < n; i++) {\n//            if (mat[i][m-1] >= target) {\n//                int result = bS(mat[i], target);\n//                if (result != -1) return true;\n//                break;\n//            }\n//        }\n//        return false;\n        int j = mat[0].length - 1;\n        int i = 0;\n        while (i < mat.length && j >= 0) {\n            System.out.println(mat[i][j]);\n            if (mat[i][j] == target) return true;\n            if (mat[i][j] < target) i++;\n            else if (mat[i][j] > target) j--;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[][] matrix = {\n                {1, 2, 4},\n                {6, 7, 8},\n                {9, 10, 34}\n        };\n        boolean ans = searchElement(matrix, 11);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on 2D arrays'],
                },
                {
                  id: 'e4746b8d-6f0b-42e8-9679-e4e4b5dab604',
                  isFolder: false,
                  name: 'AggressiveCows.java',
                  code: 'import java.util.Arrays;\npublic class AggressiveCows {\n    public static boolean isPossible(int[] stalls, int k, int minDiff) {\n        int totalCows = 1;\n        int last = stalls[0];\n        for (int i = 1; i < stalls.length; i++) {\n            if (stalls[i] - last >= minDiff) {\n                totalCows++;\n                last = stalls[i];\n            }\n            if (totalCows >= k) return true;\n        }\n        return false;\n    }\n    public static int aggressiveCows(int []stalls, int k) {\n        int n = stalls.length;\n        Arrays.sort(stalls);\n//        Brute force\n//        int maxDifference = stalls[n-1] - stalls[0];\n//        for (int i = 1; i <= maxDifference; i++) {\n//            if (!isPossible(stalls, k, i)) return i-1;\n//        }\n//        return maxDifference;\n\n//        Optimised approach\n        int start = 1, end = stalls[n-1] - stalls[0];\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(stalls, k, mid)) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return end;\n    }\n    public static void main(String[] args) {\n        int[] stalls = {4,2,1,3,6};\n        int k = 2;\n        int ans = aggressiveCows(stalls, k);\n        System.out.println("The maximum possible minimum distance is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '6d224ff6-3ef3-4e8b-8463-16b256af7657',
                  isFolder: false,
                  name: 'BookAllocation.java',
                  code: 'import java.util.*;\npublic class BookAllocation {\n    public static boolean isPossible(ArrayList<Integer> arr, int j, int m) {\n        int students = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr.get(i) <= j) {\n                sum += arr.get(i);\n            } else {\n                sum = arr.get(i);\n                students++;\n            }\n        }\n        return students <= m;\n    }\n    public static int findPages(ArrayList<Integer> arr, int n, int m) {\n//        Brute force\n//        if (m > n) return -1;\n//        int min = arr.get(0);\n//        int max = arr.get(0);\n//        for (int i = 1; i < n; i++) {\n//            min = Math.max(min, arr.get(i));\n//            max += arr.get(i);\n//        }\n//        for (int j = min; j <= max; j++) {\n//            if (isPossible(arr, j, m)) return j;\n//        }\n//        return -1;\n\n//        Optimized\n        if (m > n) return -1;\n        int start = arr.get(0);\n        int end = arr.get(0);\n        for (int i = 1; i < n; i++) {\n            start = Math.max(start, arr.get(i));\n            end += arr.get(i);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, mid, m))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(25, 46, 28, 49, 24));\n        int n = 5;\n        int m = 4;\n        int ans = findPages(arr, n, m);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'eca69dcd-c458-489a-9302-a7238fcc3d65',
                  isFolder: false,
                  name: 'CapacityToShipPackages.java',
                  code: 'public class CapacityToShipPackages {\n    public static boolean isPossible(int[] arr, int d, int capaciity) {\n        int total = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] <= capaciity) {\n                sum += arr[i];\n            } else {\n                total++;\n                sum = arr[i];\n            }\n        }\n        return total <= d;\n    }\n\n    public static int leastWeightCapacity(int[] arr, int d) {\n        // Write your code here.\n//        Brute force\n//        int max = arr[0];\n//        int min = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            max += arr[i];\n//            min = Math.max(arr[i], min);\n//        }\n//        for (int i = min; i <= max; i++) {\n//            if (isPossible(arr, d, i)) return i;\n//        }\n//        return -1;\n\n//        Optimised approach\n        int start = arr[0], end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end += arr[i];\n            start = Math.max(arr[i], start);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, d, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] arr = {5, 4, 5, 2, 3, 4, 5, 6};\n        int ans = leastWeightCapacity(arr, 5);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '5a93cde4-c1a0-43b7-a3f2-8292681e8e53',
                  isFolder: false,
                  name: 'FindSmallestDivisor.java',
                  code: 'public class FindSmallestDivisor {\n    public static boolean isPossible(int[] arr, int limit, int divisor) {\n        int total = 0;\n        for (int i = 0; i < arr.length; i++) {\n            total += (arr[i] + divisor - 1) / divisor;\n        }\n        return total <= limit;\n    }\n    public static int smallestDivisor(int[] arr, int limit) {\n        // Write your coder here\n//        Brute force\n//        int maxi = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            maxi = Math.max(maxi, arr[i]);\n//        }\n//        for (int ans = 1; ans <= maxi; ans++) {\n//            if (isPossible(arr, limit, ans)) return ans;\n//        }\n//        return -1;\n\n//        Optimal approach\n        int start = 1;\n        int end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end = Math.max(end, arr[i]);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, limit, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int ans = smallestDivisor(arr, 8);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '9c657f14-dc92-4a53-ab5d-40bf4164a6d3',
                  isFolder: false,
                  name: 'KokoEatingBananas.java',
                  code: 'public class KokoEatingBananas {\n    public static boolean isPossible(int[] v, int h, int rate) {\n        int hourCount = 0;\n        for (int i = 0; i < v.length; i++) {\n            hourCount += (v[i] + rate - 1)/rate;\n            if (hourCount > h) return false;\n        }\n        return hourCount <= h;\n    }\n    public static int minimumRateToEatBananas(int []v, int h) {\n        // Write Your Code Here\n//        Brute force\n//        int max = v[0];\n//        for (int i: v) {\n//            max = Math.max(max, i);\n//        }\n//        for (int ans = 1; ans <= max; ans++) {\n//            if (isPossible(v, h, ans)) return ans;\n//        }\n//        return -1;\n\n//        Best approach: Binary search\n        int start = 1;\n        int end = v[0];\n        for (int i = 1; i < v.length; i++) {\n            end = Math.max(end, v[i]);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(v, h, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] v = {7, 15, 6, 3};\n        int h = 8;\n        int ans = minimumRateToEatBananas(v,h);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '813bf7db-ccf3-4cc6-a60b-38f97b21f184',
                  isFolder: false,
                  name: 'KthElementOf2SortedArrays.java',
                  code: 'import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class KthElementOf2SortedArrays {\n    public static int kthElement(ArrayList<Integer> a, ArrayList<Integer> b, int n, int m, int k) {\n//        Brute force solution\n//        int[] temp = new int[n + m];\n//        int left = 0, right = 0, i = 0;\n//        while (left < n && right < m) {\n//            if (a.get(left) <= b.get(right))\n//                temp[i++] = a.get(left++);\n//            else\n//                temp[i++] = b.get(right++);\n//        }\n//        while (left < n) temp[i++] = a.get(left++);\n//        while (right < m) temp[i++] = b.get(right++);\n//        return temp[k-1];\n\n//        Better solution\n//        int left = 0, right = 0, i = 0;\n//        while (left < n && right < m) {\n//            if (a.get(left) <= b.get(right)) {\n//                if (i == k - 1) return a.get(left);\n//                left++;\n//            } else {\n//                if (i == k - 1) return b.get(right);\n//                right++;\n//            }\n//            i++;\n//        }\n//        while (left < n) {\n//            if (i == k - 1) return a.get(left);\n//            left++;\n//            i++;\n//        }\n//        while (right < m) {\n//            if (i == k - 1) return b.get(right);\n//            right++;\n//            i++;\n//        }\n//        return Math.max(a.get(n-1), b.get(m-1));\n\n//        Optimal approach\n        if (n > m) return kthElement(b, a, m, n, k);\n        int start = Math.max(0, k-m), end = Math.min(k,n);\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int mid2 = k - mid;\n            int l1 = mid > 0 ? a.get(mid - 1) : Integer.MIN_VALUE;\n            int l2 = mid2 > 0 ? b.get(mid2 - 1) : Integer.MIN_VALUE;\n            int r1 = mid < n? a.get(mid) : Integer.MAX_VALUE;\n            int r2 = mid2 < m? b.get(mid2) : Integer.MAX_VALUE;\n            if (l1 <= r2 && l2 <= r1) return Math.max(l1, l2);\n            if (l1 > r2) end = mid - 1;\n            else start = mid + 1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Integer> arr1 = new ArrayList<>(Arrays.asList(2, 3, 6, 7, 9));\n        ArrayList<Integer> arr2 = new ArrayList<>(Arrays.asList(1, 4, 8, 10));\n        int m = arr1.size();\n        int n = arr2.size();\n        int k = 5;\n        System.out.println("The element at the kth position in the final sorted array is " + kthElement(arr1, arr2, m, n, k));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '7c2c62bc-c61a-4572-94d2-7bbe0dccd68d',
                  isFolder: false,
                  name: 'KthMissingPositiveNumber.java',
                  code: 'public class KthMissingPositiveNumber {\n    public static int missingK(int[] arr, int n, int k) {\n//        Brute force solution\n//        for (int i = 0; i < n; i++) {\n//            if (arr[i] > k) break;\n//            k++;\n//        }\n//        return k;\n\n//        Optimised approach\n        int start = 0;\n        int end = n-1;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int missing = arr[mid] - (mid + 1);\n            if (missing < k) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start + k;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, 4, 5, 7};\n        int ans = missingK(arr, arr.length, 3);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '5bbe9e54-ccca-4f80-88ba-d56d2dc5cb29',
                  isFolder: false,
                  name: 'MedianOfTwoSortedArrays.java',
                  code: 'public class MedianOfTwoSortedArrays {\n    public static double median(int[] a, int[] b) {\n//        Brute force solution\n//        Use another array ans add all elements in sorted order, then calculate median\n//        int n1 = a.length;\n//        int n2 = b.length;\n//        int[] temp = new int[n1 + n2];\n//        int left = 0, right = 0, i = 0;\n//        while (left < n1 && right < n2) {\n//            if (a[left] <= b[right]) {\n//                temp[i++] = a[left++];\n//            } else {\n//                temp[i++] = b[right++];\n//            }\n//        }\n//        while (left < n1) {\n//            temp[i++] = a[left++];\n//        }\n//        while (right < n2) {\n//            temp[i++] = b[right++];\n//        }\n////        returning median\n//        int m1 = temp.length / 2;\n//        if (temp.length % 2 == 0) {\n//            int m2 = m1 - 1;\n//            return (temp[m1] + temp[m2]) / 2.0;\n//        }\n//        return temp[m1];\n\n//        Better solution\n//        We don\'t need to store all the elements just medians elements are needed to calculate median\n//        int n1 = a.length, n2 = b.length;\n//        int left = 0, right = 0, i = 0;\n//        int m1 = (n1 + n2) / 2;\n//        int mid1 = -1,  mid2 = -1;\n//        while (left < n1 && right < n2) {\n//            if (a[left] <= b[right]) {\n//                if (i == m1 - 1) mid1 = a[left];\n//                else if (i == m1) mid2 = a[left];\n//                left++;\n//            } else {\n//                if (i == m1 - 1) mid1 = b[right];\n//                else if (i == m1) mid2 = b[right];\n//                right++;\n//            }\n//            i++;\n//        }\n//        while (left < n1) {\n//            if (i == m1 - 1) mid1 = a[left];\n//            else if (i == m1) mid2 = a[left];\n//            i++;\n//            left++;\n//        }\n//        while (right < n2) {\n//            if (i == m1 - 1) mid1 = b[right];\n//            else if (i == m1) mid2 = b[right];\n//            i++;\n//            right++;\n//        }\n//        if ((n1 + n2) % 2 == 1) return mid2;\n//        return (double)(mid1 + mid2) / 2.0;\n\n//        Optimal solution\n//        Use binary search to get the mid value of the merged array (without merging)\n        int n1 = a.length, n2 = b.length;\n        if (n1 > n2) return median(b, a);\n        int n = n1 + n2;\n        int minElements = (n + 1) / 2;\n        int start = 0, end = n1;\n        while (start <= end) {\n            int mid1 = start + (end - start) / 2;\n            int mid2 = minElements - mid1;\n            int l1 = Integer.MIN_VALUE, l2 = Integer.MIN_VALUE;\n            int r1 = Integer.MAX_VALUE, r2 = Integer.MAX_VALUE;\n            if (mid1 > 0) l1 = a[mid1 - 1];\n            if (mid2 > 0) l2 = b[mid2 - 1];\n            if (mid1 < n1) r1 = a[mid1];\n            if (mid2 < n2) r2 = b[mid2];\n            if (l1 <= r2 && l2 <= r1) {\n                double median = Math.max(l1, l2);\n                if (n % 2 == 0) {\n                    median += Math.min(r1, r2);\n                    return median / 2.0;\n                }\n                return median;\n            }\n            if (l1 > r2) end = mid1 - 1;\n            else start = mid1 + 1;\n        }\n        return 0.0;\n    }\n\n    public static void main(String[] args) {\n        int[] a = {2, 4, 6};\n        int[] b = {1, 3};\n        System.out.println("The median of two sorted arrays is " + median(a, b));\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '754b695d-235d-4d21-9075-8b3cb95f18b2',
                  isFolder: false,
                  name: 'MinimiseMaximumDistanceBetweenGasStations.java',
                  code: 'import java.util.*;\n\npublic class MinimiseMaximumDistanceBetweenGasStations {\n    public static double minimiseMaxDistance(int []arr, int k){\n//        Brute force\n//        1. Make a sections array to store the count of added gas stations in each section\n//        int[] sections = new int[arr.length - 1];\n//        for (int i = 0; i < k; i++) {\n//            double maxVal = -1;\n//            int maxIdx = -1;\n//            for (int j = 0; j < sections.length; j++) {\n//                double distance = arr[j+1] - arr[j];\n//                double sectionLength = distance/(sections[j]+1);\n//                if (sectionLength > maxVal) {\n//                    maxVal = sectionLength;\n//                    maxIdx = j;\n//                }\n//            }\n//            sections[maxIdx]++;\n//        }\n//        2. Iterate sections to get the maxLength of the difference\n//        double maxLength = 0;\n//        for (int i  = 0; i < sections.length; i++) {\n//            double distance = arr[i+1] - arr[i];\n//            double len = distance / (sections[i]+ 1);\n//            maxLength = Math.max(maxLength, len);\n//        }\n//        return maxLength;\n\n//        Optimised approach - Priority queue\n//        Add all sections current length to the pq\n//        Iterate on range k and update the highest element pair in pq\n//        return the pq.peek();\n        PriorityQueue<Map.Entry<Double, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByKey(Collections.reverseOrder()));\n        for (int i = 0; i < arr.length - 1; i++) {\n            pq.add(new AbstractMap.SimpleEntry<>((double) arr[i+1] - arr[i], i));\n        }\n        int[] sections = new int[arr.length - 1];\n        for (int j = 0; j < k; j++) {\n            int idx = pq.remove().getValue();\n            sections[idx]++;\n            double distance = arr[idx+1] - arr[idx];\n            double sectionLength = distance / (sections[idx] + 1);\n            pq.add(new AbstractMap.SimpleEntry<>(sectionLength, idx));\n        }\n        return pq.remove().getKey();\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int k = 4;\n        double ans = minimiseMaxDistance(arr, k);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '9ccb2af6-299f-4df4-9e5e-3aef09bdd6ce',
                  isFolder: false,
                  name: 'NthRoot.java',
                  code: 'public class NthRoot {\n    public static int getNthPower(int num, int pow, int m) {\n        long ans = 1;\n        for (int i = 0; i < pow; i++) {\n            ans *= num;\n            if (ans > m) return 1;\n        }\n        if (ans == m) return 0;\n        return -1;\n    }\n    public static int getNthRoot(int n, int m) {\n//        for (int i = 1; i < m; i++) {\n//            int x = getNthPower(i, n);\n//            if (x == m) return i;\n//        }\n//        return -1;\n\n        int start = 0;\n        int end = m;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int res = getNthPower(mid, n, m);\n            if (res == 0) return mid;\n            if (res == 1) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\n    public static void main(String[] args) {\n        int n = 9;\n        int m = 262144;\n        int ans = getNthRoot(n,m);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '3e387174-b89d-449d-a812-d416ccc85cf7',
                  isFolder: false,
                  name: 'PaintersPartition.java',
                  code: 'import java.util.ArrayList;\n\npublic class PaintersPartition {\n    public static boolean isPossible(ArrayList<Integer> arr, int k, int maxArea) {\n        int sum = 0;\n        int totalPainters = 1;\n        for (int i = 0; i < arr.size(); i++) {\n            if (sum + arr.get(i) <= maxArea) {\n                sum += arr.get(i);\n            } else {\n                sum = arr.get(i);\n                totalPainters++;\n            }\n        }\n        return totalPainters <= k;\n    }\n    public static int findLargestMinDistance(ArrayList<Integer> arr, int k) {\n        int min = arr.get(0);\n        int max = arr.get(0);\n        for (int i = 1; i < arr.size(); i++) {\n            min = Math.max(min, arr.get(i));\n            max += arr.get(i);\n        }\n\n//        Brute force\n//        for (int i = min; i <= max; i++) {\n//            if (isPossible(arr, k, i)) return i;\n//        }\n//        return -1;\n\n//        Optimised solution\n        int start = min, end = max;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, k, mid))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n\n    }\n    public static void main(String[] args) {\n\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: 'd4101f08-af6b-46ae-ae13-88b3511c0fb5',
                  isFolder: false,
                  name: 'RoseGarden.java',
                  code: 'public class RoseGarden {\n    public static boolean isPossible(int[] arr, int r, int b, int d) {\n        int totalBouquets = 0;\n        int rCount = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] <= d) {\n                rCount++;\n            } else {\n                totalBouquets += rCount / r;\n                rCount = 0;\n            }\n        }\n        totalBouquets += rCount / r;\n        return totalBouquets >= b;\n    }\n\n    public static int roseGarden(int[] arr, int r, int b) {\n//        Brute force\n//        int max = arr[0];\n//        for (int i = 1; i < arr.length; i++) {\n//            max = Math.max(max, arr[i]);\n//        }\n//        for (int ans = 1; ans <= max; ans++) {\n//            if (isPossible(arr, r, b, ans)) return ans;\n//        }\n//        return -1;\n\n//        Optimised approach\n        if (b*r > arr.length) return -1;\n        int start = arr[0];\n        int end = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            end = Math.max(arr[i], end);\n            start = Math.min(arr[i], start);\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, r, b, mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 3, 6, 8, 13, 17, 6, 16};\n        int ans = roseGarden(arr, 2, 2);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '12b523db-b7a0-4634-a9e5-c49484d107dc',
                  isFolder: false,
                  name: 'SplitArrayLargestSum.java',
                  code: 'public class SplitArrayLargestSum {\n\n    public static boolean isPossible(int[] arr, int limit, int splits) {\n        int totalSplits = 1;\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (sum + arr[i] <= limit) {\n                sum += arr[i];\n            } else {\n                sum = arr[i];\n                totalSplits++;\n            }\n            if (totalSplits > splits) return false;\n        }\n        return true;\n    }\n\n    public static int largestSubarraySumMinimized(int []arr, int k) {\n        // Write Your Code Here\n//        Brute same as book allocation problem\n        int n = arr.length;\n        if (k > n) return -1;\n        int start = arr[0];\n        int end = arr[0];\n        for (int i = 1; i < n; i++) {\n            start = Math.max(start, arr[i]);\n            end += arr[i];\n        }\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            if (isPossible(arr, mid, k))\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return start;\n    }\n    public static void main(String[] args) {\n        int[] a = {10, 20, 30, 40};\n        int k = 2;\n        int ans = largestSubarraySumMinimized(a, k);\n        System.out.println("The answer is: " + ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
                {
                  id: '4d9a5bf7-77bc-430c-99c2-5684e5658e80',
                  isFolder: false,
                  name: 'SquareRoot.java',
                  code: 'public class SquareRoot {\n    public static int getSQRT(int x) {\n//        Brute force\n//        int ans = 1;\n//        for (int i = 1; i <= x; i++) {\n//            if (i*i <= x) {\n//                ans = i;\n//            } else {\n//                break;\n//            }\n//        }\n//        return ans;\n\n//        Optimised approach\n        int start = 1;\n        int end = x;\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n            int root = x/mid;\n            if (mid == root) {\n                return mid;\n            }\n            if (mid > root) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return end;\n    }\n    public static void main(String[] args) {\n        int num = 21;\n        int ans = getSQRT(num);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['BS on Answers'],
                },
              ],
            },
            {
              id: 'ce3ac693-6850-4298-aa50-a3b751c483fd',
              isFolder: true,
              name: 'Binary Search Trees',
              content: [
                {
                  id: '214e7dc0-5ea6-4e04-9797-fcc27451bf95',
                  isFolder: false,
                  name: 'MinMaxInBST.java',
                  code: 'public class MinMaxInBST {\n    public static int minValue(TreeNode root) {\n        // Write your code here.\n        TreeNode temp = root;\n        if (root == null) return -1;\n        while (temp.left != null) {\n            temp = temp.left;\n        }\n        return temp.val;\n    }\n    public static int maxValue(TreeNode root) {\n        // Write your code here.\n        TreeNode temp = root;\n        if (root == null) return -1;\n        while (temp.right != null) {\n            temp = temp.right;\n        }\n        return temp.val;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-element-in-bst_8160462',
                  notes: '',
                  tags: ['Concepts'],
                },
                {
                  id: '43be28de-7b97-444a-8b46-8e5cebdd4640',
                  isFolder: false,
                  name: 'SearchInBST.java',
                  code: 'public class SearchInBST {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if (root == null) return null;\n        if (root.val == val) return root;\n        if (val > root.val) return searchBST(root.right, val);\n        return searchBST(root.left, val);\n    }\n}',
                  link: 'https://leetcode.com/problems/search-in-a-binary-search-tree/',
                  notes: '',
                  tags: ['Concepts'],
                },
                {
                  id: 'c6448727-d1ae-4871-b3fa-24cd37a07733',
                  isFolder: false,
                  name: 'BSTFromPreorder.java',
                  code: 'import java.util.*;\npublic class BSTFromPreorder {\n    public TreeNode bstFromPreorder(int[] preorder) {\n        if (preorder.length == 0) return null;\n        TreeNode root = new TreeNode(preorder[0]);\n        int start = 1;\n        for (int i = 1; i < preorder.length; i++) {\n            if (preorder[0] < preorder[i]) break;\n            start++;\n        }\n        int[] left = Arrays.copyOfRange(preorder, 1, start);\n        int[] right = Arrays.copyOfRange(preorder, start, preorder.length);\n        root.left = bstFromPreorder(left);\n        root.right = bstFromPreorder(right);\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: 'a1903d5f-7d9e-4b11-bdc2-3644fa9f66c8',
                  isFolder: false,
                  name: 'CeilBST.java',
                  code: 'public class CeilBST {\n    public  static int findCeil(TreeNode node, int x) {\n        // Write your code here\n        TreeNode curr = node;\n        int ceil = -1;\n        while (curr != null) {\n            if (curr.val == x) {\n                return curr.val;\n            }\n            if (curr.val > x) {\n                ceil = curr.val;\n                curr = curr.left;\n            } else {\n                curr = curr.right;\n            }\n        }\n        return ceil;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/ceil-from-bst_920464',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '96d4d02b-594f-4377-91c7-b6df4cec86db',
                  isFolder: false,
                  name: 'DeleteNodeBST.java',
                  code: 'public class DeleteNodeBST {\n    public int getMinNodeVal(TreeNode root) {\n        TreeNode curr = root;\n        while (curr.left != null)\n            curr = curr.left;\n        return curr.val;\n    }\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) return null;\n        if (key > root.val)\n            root.right = deleteNode(root.right, key);\n        else if (key < root.val)\n            root.left = deleteNode(root.left, key);\n        else {\n            if (root.left == null)\n                root = root.right;\n            else if (root.right == null)\n                root = root.left;\n            else {\n                root.val = getMinNodeVal(root.right);\n                root.right = deleteNode(root.right, root.val);\n            }\n        }\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/delete-node-in-a-bst/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '79bc4188-15c8-4326-b4fb-05b629f913fa',
                  isFolder: false,
                  name: 'FixBST.java',
                  code: 'public class FixBST {\n    TreeNode node1, node2, prev;\n    public void inoFix(TreeNode root) {\n        if (root == null) return;\n        inoFix(root.left);\n        if (prev != null && prev.val > root.val) {\n            if (node1 == null) {\n                node1 = prev;\n            }\n            node2 = root;\n        }\n        prev = root;\n        inoFix(root.right);\n    }\n    public void recoverTree(TreeNode root) {\n        inoFix(root);\n        int temp = node1.val;\n        node1.val = node2.val;\n        node2.val = temp;\n    }\n}',
                  link: 'https://leetcode.com/problems/recover-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '5537ac45-1564-48c8-a0e7-2f15afe1377e',
                  isFolder: false,
                  name: 'FloorBST.java',
                  code: 'public class FloorBST {\n    public static int Floor(TreeNode node, int x) {\n        TreeNode curr = node;\n        int floor = -1;\n        while (curr != null) {\n            if (curr.val == x) return x;\n            if (curr.val < x) {\n                floor = curr.val;\n                curr = curr.right;\n            } else {\n                curr = curr.left;\n            }\n        }\n        return floor;\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/floor-from-bst_625868',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '2a711c7e-a0e9-4ea9-827d-1a3a5fe6b199',
                  isFolder: false,
                  name: 'InorderSuccessorPredecessorOfBST.java',
                  code: 'import java.util.*;\npublic class InorderSuccessorPredecessorOfBST {\n    public static List<Integer> predecessorSuccessor(TreeNode root, int key) {\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        // predecessor\n        int p = -1;\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.val < key) {\n                p = curr.val;\n                curr = curr.right;\n            } else {\n                curr = curr.left;\n            }\n        }\n        // successor\n        int s = -1;\n        curr = root;\n        while (curr != null) {\n            if (curr.val > key) {\n                s = curr.val;\n                curr = curr.left;\n            } else {\n                curr = curr.right;\n            }\n        }\n        ans.add(p);\n        ans.add(s);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/predecessor-and-successor-in-bst_893049',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '81e5f54c-d2fa-4edd-b76d-19e669a20ceb',
                  isFolder: false,
                  name: 'InsertNodeBST.java',
                  code: 'public class InsertNodeBST {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) return new TreeNode(val);\n        if (val > root.val) {\n            root.right = insertIntoBST(root.right, val);\n        } else {\n            root.left = insertIntoBST(root.left, val);\n        }\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/insert-into-a-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '54e17526-9817-4146-a2c2-075d1d5c0fcb',
                  isFolder: false,
                  name: 'KthSmallestElementBST.java',
                  code: 'public class KthSmallestElementBST {\n    public static void solve(TreeNode root, int[] ans, int k) {\n        if (root == null) return;\n        solve(root.left, ans, k);\n        ans[1]++;\n        if (ans[1] == k) {\n            ans[0] = root.val;\n            return;\n        }\n        solve(root.right, ans, k);\n    }\n    public int kthSmallest(TreeNode root, int k) {\n        int[] ans = { -1, 0 };\n        solve(root, ans, k);\n        return ans[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/kth-smallest-element-in-a-bst/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: 'f60b4ec6-16f3-4c5b-a3e7-124685fc8dc6',
                  isFolder: false,
                  name: 'LCAOfBST.java',
                  code: 'public class LCAOfBST {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right ,p,q);\n        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left ,p,q);\n        return root;\n    }\n}',
                  link: 'https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: 'f783081b-101d-460f-bea1-115614b953d9',
                  isFolder: false,
                  name: 'Merge2BST.java',
                  code: '// https://www.codingninjas.com/studio/problems/merge-two-bsts_920474\nimport java.util.*;\npublic class Merge2BST {\n    public static List<Integer> mergeLL(TreeNode list1, TreeNode list2, List<Integer> ans) {\n        TreeNode i = list1;\n        TreeNode j = list2;\n        while (i != null && j != null) {\n            if (i.val <= j.val) {\n                ans.add(i.val);\n                i = i.right;\n            } else {\n                ans.add(j.val);\n                j = j.right;\n            }\n        }\n        while (i != null) {\n            ans.add(i.val);\n            i = i.right;\n        }\n        while (j != null) {\n            ans.add(j.val);\n            j = j.right;\n        }\n        return ans;\n    }\n    public static List<Integer> merge(List<Integer> list1, List<Integer> list2) {\n        List<Integer> ans = new ArrayList<>();\n        int i = 0, j = 0;\n        while (i < list1.size() && j < list2.size()) {\n            int l1 = list1.get(i), l2 = list2.get(j);\n            if (l1 <= l2) {\n                ans.add(l1);\n                i++;\n            } else {\n                ans.add(l2);\n                j++;\n            }\n        }\n        while (i < list1.size()) ans.add(list1.get(i++));\n        while (j < list2.size()) ans.add(list2.get(j++));\n        return ans;\n    }\n    public static void ino(TreeNode root, List<Integer> ans) {\n        if (root == null) return;\n        Stack<TreeNode> st = new Stack<>();\n        TreeNode node = root;\n        while (node != null || !st.isEmpty()) {\n            while (node != null) {\n                node = st.push(node).left;\n            }\n            node = st.pop();\n            ans.add(node.val);\n            node = node.right;\n        }\n    }\n\n    static TreeNode head = new TreeNode(0);\n    public static void sortedFlatten(TreeNode root) {\n        if (root == null) return;\n        sortedFlatten(root.left);\n        head.right = root;\n        head = head.right;\n        head.left = null;\n        sortedFlatten(root.right);\n    }\n\n    public static List<Integer> mergeBST(TreeNode root1, TreeNode root2) {\n        // Write your code here.\n        // List<Integer> list1 = new ArrayList<>();\n        // List<Integer> list2 = new ArrayList<>();\n        // return merge(list1, list2);\n        TreeNode list1 = head;\n        sortedFlatten(root1);\n        head = new TreeNode(0);\n        TreeNode list2 = head;\n        sortedFlatten(root2);\n        List<Integer> ans = new ArrayList<>();\n        return mergeLL(list1.right, list2.right, ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '0d540221-ee4f-4c58-8c16-725abf185823',
                  isFolder: false,
                  name: 'SizeOfLargestBST.java',
                  code: 'public class SizeOfLargestBST {\n    static class TreeInfo {\n        int size, max, min;\n        TreeInfo(int s, int min, int max) {\n            this.size = s;\n            this.min = min;\n            this.max = max;\n        }\n    }\n    public static TreeInfo solve(TreeNode root) {\n        if (root == null)\n            return new TreeInfo(0, Integer.MAX_VALUE, Integer.MIN_VALUE);\n        if (root.left == null && root.right == null)\n            return new TreeInfo(1, root.val, root.val);\n        TreeInfo l = solve(root.left);\n        TreeInfo r = solve(root.right);\n        if (root.val > l.max && root.val < r.min) {\n            int min = Math.min(l.min, root.val);\n            int max = Math.max(r.max, root.val);\n            return new TreeInfo(l.size + r.size + 1, min, max);\n        }\n        return new TreeInfo(Math.max(l.size, r.size), Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    public static int largestBST(TreeNode root) {\n        // Write your code here.\n        TreeInfo temp = solve(root);\n        return temp.size;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/size-of-largest-bst-in-binary-tree_893103',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: '054daf9c-e310-42f9-ace3-2caa8e7eda67',
                  isFolder: false,
                  name: 'TwoSum4.java',
                  code: 'import java.util.*;\npublic class TwoSum4 {\n    public static void ino(TreeNode root, List<Integer> ans) {\n        if (root == null) return;\n        ino(root.left, ans);\n        ans.add(root.val);\n        ino(root.right, ans);\n    }\n    public boolean findTarget(TreeNode root, int k) {\n        List<Integer> inorder = new ArrayList<>();\n        ino(root, inorder);\n        int i = 0, j = inorder.size() - 1;\n        while (i < j) {\n            int sum = inorder.get(i) + inorder.get(j);\n            if (sum > k) j--;\n            else if (sum < k) i++;\n            else return true;\n        }\n        return false;\n    }\n}',
                  link: 'https://leetcode.com/problems/two-sum-iv-input-is-a-bst/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
                {
                  id: 'a41cd638-1cfe-4532-a5b8-01cd0115564d',
                  isFolder: false,
                  name: 'ValidateBST.java',
                  code: 'public class ValidateBST {\n    public static boolean solve(TreeNode root, Integer low, Integer high) {\n        if (root == null) return true;\n        if (low != null && root.val <= low) return false;\n        if (high != null && root.val >= high) return false;\n        return solve(root.left, low, root.val) && solve(root.right, root.val, high);\n    }\n    public boolean isValidBST(TreeNode root) {\n        return solve(root, null, null);\n    }\n}',
                  link: 'https://leetcode.com/problems/validate-binary-search-tree/',
                  notes: '',
                  tags: ['Practice Problems'],
                },
              ],
            },
            {
              id: '6be5a334-0bf3-4713-ad77-b42dc38edfd8',
              isFolder: true,
              name: 'Binary Trees',
              content: [
                {
                  id: '623ef047-7653-4366-ba35-14bf286a7cf3',
                  isFolder: false,
                  name: 'AllNodesDistanceKInBinaryTree.java',
                  code: 'import java.util.*;\npublic class AllNodesDistanceKInBinaryTree {\n    public static void markParents(TreeNode root, HashMap<Integer, TreeNode> hm) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node.left != null) {\n                q.add(node.left);\n                hm.put(node.left.val, node);\n            }\n            if (node.right != null) {\n                q.add(node.right);\n                hm.put(node.right.val, node);\n            }\n        }\n    }\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\n        HashMap<Integer, TreeNode> hm = new HashMap<>();\n        markParents(root, hm);\n        Queue<TreeNode> q = new LinkedList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        q.add(target);\n        hs.add(target.val);\n        int range = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            if (range == k) break;\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                TreeNode parent = hm.getOrDefault(node.val, null);\n                if (parent != null && !hs.contains(parent.val)) {\n                    q.add(parent);\n                    hs.add(parent.val);\n                }\n                if (node.left != null && !hs.contains(node.left.val)) {\n                    q.add(node.left);\n                    hs.add(node.left.val);\n                }\n                if (node.right != null && !hs.contains(node.right.val)) {\n                    q.add(node.right);\n                    hs.add(node.right.val);\n                }\n            }\n            range++;\n        }\n        List<Integer> ans = new ArrayList<>();\n        while (!q.isEmpty()) ans.add(q.poll().val);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '3fee30d3-930c-466a-ac02-15f667b5e232',
                  isFolder: false,
                  name: 'AllPathsToLeafNodeFromRoot.java',
                  code: 'import java.util.*;\npublic class AllPathsToLeafNodeFromRoot {\n    public static void solve(TreeNode root, String path, List<String> ans) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) ans.add(path + root.val);\n        solve(root.left, path + root.val +" ", ans);\n        solve(root.right, path + root.val + " ", ans);\n    }\n    public static List<String> allRootToLeaf(TreeNode root) {\n        // Write your code here.\n        List<String> ans = new ArrayList<>();\n        solve(root, "", ans);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/all-root-to-leaf-paths-in-binary-tree._983599',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'a644d0d3-b5bd-4845-8ce9-7e29a067792a',
                  isFolder: false,
                  name: 'BinaryTreeFromInorderPostorder.java',
                  code: 'import java.util.Arrays;\n\npublic class BinaryTreeFromInorderPostorder {\n    public static TreeNode solve(int[] inorder, int[] postorder) {\n        if (inorder.length == 0 || postorder.length == 0) return null;\n        TreeNode root = new TreeNode(postorder[postorder.length - 1]);\n        int start = 0;\n        for (int j : inorder) {\n            if (j == postorder[postorder.length - 1]) break;\n            start++;\n        }\n        int[] left_inorder = Arrays.copyOfRange(inorder, 0, start);\n        int[] left_postorder = Arrays.copyOfRange(postorder, 0, start);\n        int[] right_inorder = Arrays.copyOfRange(inorder, start + 1, inorder.length);\n        int[] right_postorder = Arrays.copyOfRange(postorder, start, postorder.length - 1);\n        root.left = solve(left_inorder, left_postorder);\n        root.right = solve(right_inorder, right_postorder);\n        return root;\n    }\n\n    public static TreeNode buildTree(int[] inorder, int[] postorder) {\n        return solve(inorder, postorder);\n    }\n\n    public static void main(String[] args) {\n        int[] inorder = {9, 3, 15, 20, 7};\n        int[] postorder = {9, 15, 7, 20, 3};\n        TreeNode root = buildTree(inorder, postorder);\n        System.out.println(root.val);\n        System.out.println(root.left.val);\n        System.out.println(root.right.val);\n        System.out.println(root.right.left.val);\n        System.out.println(root.right.right.val);\n    }\n}',
                  link: 'https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'a1c18fbe-e12e-49f8-844a-c17a4de0e468',
                  isFolder: false,
                  name: 'BinaryTreeFromInorderPreorder.java',
                  code: 'import java.util.Arrays;\n\npublic class BinaryTreeFromInorderPreorder {\n    public static TreeNode solve(int[] preorder, int[] inorder) {\n        if (preorder.length == 0 || inorder.length == 0) return null;\n        TreeNode root = new TreeNode(preorder[0]);\n        int start = 0;\n        for (int j : inorder) {\n            if (j == preorder[0]) break;\n            start++;\n        }\n        int[] left_inorder = Arrays.copyOfRange(inorder, 0, start);\n        int[] left_preorder = Arrays.copyOfRange(preorder, 1, start+1);\n        int[] right_inorder = Arrays.copyOfRange(inorder, start+1, inorder.length);\n        int[] right_preorder = Arrays.copyOfRange(preorder, start+1, preorder.length);\n        root.left = solve(left_preorder, left_inorder);\n        root.right = solve(right_preorder, right_inorder);\n        return root;\n    }\n\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\n        return solve(preorder, inorder);\n    }\n\n    public static void main(String[] args) {\n        int[] inorder = {9, 3, 15, 20, 7};\n        int[] preorder = {3, 9, 20, 15, 7};\n        TreeNode root = buildTree(preorder, inorder);\n        System.out.println(root.val);\n        System.out.println(root.left.val);\n        System.out.println(root.right.val);\n        System.out.println(root.right.left.val);\n        System.out.println(root.right.right.val);\n    }\n}',
                  link: 'https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '820cd46d-6913-42e3-951e-54dac6742968',
                  isFolder: false,
                  name: 'CountTotalNodesInBinaryTree.java',
                  code: 'public class CountTotalNodesInBinaryTree {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        int l = countNodes(root.left);\n        int r = countNodes(root.right);\n        return l + r + 1;\n    }\n}',
                  link: 'https://leetcode.com/problems/count-complete-tree-nodes/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '755623cb-da68-426e-84d7-93553a67537b',
                  isFolder: false,
                  name: 'FlattenBinaryTreeToLinkedList.java',
                  code: 'public class FlattenBinaryTreeToLinkedList {\n    public void flatten(TreeNode root) {\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left != null) {\n                TreeNode temp = curr.left;\n                while (temp.right != null) {\n                    temp = temp.right;\n                }\n                temp.right = curr.right;\n                curr.right = curr.left;\n                curr.left = null;\n            }\n            curr = curr.right;\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/flatten-binary-tree-to-linked-list/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'f777ac2a-3624-4c49-8152-0438bc643d6e',
                  isFolder: false,
                  name: 'ImmediateChildrenSumProperty.java',
                  code: 'public class ImmediateChildrenSumProperty {\n    public static int solve(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return root.val;\n        int l = solve(root.left);\n        int r = solve(root.right);\n        if (l == - 1 || r == - 1 || root.val != (l + r)) return -1;\n        return root.val;\n    }\n    public static boolean isParentSum(TreeNode root) {\n        // Write your code here.\n        // int[] flag = {1};\n        int val = solve(root);\n        return val != -1;\n        // return flag[0] == 1;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/children-sum-property_8357239',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '41c530a1-ad6c-49a3-b4bf-86d26e9b8fa7',
                  isFolder: false,
                  name: 'LowestCommonAncestor.java',
                  code: 'public class LowestCommonAncestor {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // return solve(root, p, q);\n        if (root == null || root == p || root == q) return root;\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\n        if (l != null && r != null) return root;\n        return l != null ? l : r;\n    }\n}',
                  link: 'https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'c7a1b8cb-8496-465d-8c85-8e041feade4f',
                  isFolder: false,
                  name: 'MaximumWidthOfBinaryTree.java',
                  code: 'import java.util.*;\npublic class MaximumWidthOfBinaryTree {\n    static class Pair {\n        int idx;\n        TreeNode node;\n        Pair (TreeNode n, int i) {\n            this.idx = i;\n            this.node = n;\n        }\n    }\n    public int widthOfBinaryTree(TreeNode root) {\n        ArrayDeque<Pair> q = new ArrayDeque<>();\n        q.add(new Pair(root, 0));\n        int maxWidth = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            if (size > 1) {\n                Pair min = q.peekFirst();\n                Pair max = q.peekLast();\n                maxWidth = Math.max(max.idx - min.idx + 1, maxWidth);\n            }\n            for (int i = 0; i < size; i++) {\n                Pair p = q.pollFirst();\n                if (p.node.left != null) {\n                    q.add(new Pair(p.node.left, 2*p.idx + 1));\n                }\n                if (p.node.right != null) {\n                    q.add(new Pair(p.node.right, 2*p.idx + 2));\n                }\n            }\n        }\n        return maxWidth;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-width-of-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'f2befe17-0af3-4dbe-b69e-2a6143c78883',
                  isFolder: false,
                  name: 'MorrisTraversalInorder.java',
                  code: 'import java.util.*;\npublic class MorrisTraversalInorder {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left == null) {\n                ans.add(curr.val);\n                curr = curr.right;\n            } else {\n                TreeNode prev = curr.left;\n                while (prev.right != null && prev.right != curr) {\n                    prev = prev.right;\n                }\n                if (prev.right == null) {\n                    prev.right = curr;\n                    curr = curr.left;\n                } else {\n                    prev.right = null;\n                    ans.add(curr.val);\n                    curr = curr.right;\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-inorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'f2ee207e-56d6-4b36-b3eb-ffe2fea22b7e',
                  isFolder: false,
                  name: 'MorrisTraversalPreorder.java',
                  code: 'import java.util.*;\npublic class MorrisTraversalPreorder {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left == null) {\n                ans.add(curr.val);\n                curr = curr.right;\n            } else {\n                TreeNode prev = curr.left;\n                while (prev.right != null && prev.right != curr) {\n                    prev = prev.right;\n                }\n                if (prev.right == null) {\n                    prev.right = curr;\n                    ans.add(curr.val);\n                    curr = curr.left;\n                } else {\n                    prev.right = null;\n                    curr = curr.right;\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-preorder-traversal/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '999e18e9-aec3-4b78-8bd8-b98a6e633fde',
                  isFolder: false,
                  name: 'SerializeAndDeserialize.java',
                  code: 'public class SerializeAndDeserialize {\n    public static void preorder(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append("N,");\n            return;\n        }\n        sb.append(root.val).append(",");\n        preorder(root.left, sb);\n        preorder(root.right, sb);\n    }\n\n    // Encodes a tree to a single string.\n    public static String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        preorder(root, sb);\n        sb.deleteCharAt(sb.length() - 1);\n        return sb.toString();\n    }\n\n    public static TreeNode solve(String[] arr, int[] idx) {\n        if (idx[0] == arr.length || arr[idx[0]].compareTo("N") == 0) {\n            idx[0]++;\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]]));\n        idx[0]++;\n        root.left = solve(arr, idx);\n        root.right = solve(arr, idx);\n        return root;\n    }\n    // Decodes your encoded data to tree.\n    public static TreeNode deserialize(String data) {\n        String[] arr = data.split(",");\n        return solve(arr, new int[] {0});\n    }\n}',
                  link: 'https://leetcode.com/problems/serialize-and-deserialize-binary-tree/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'c83a064e-70dc-49ad-b608-19ca511e4359',
                  isFolder: false,
                  name: 'TimeToBurnBinaryTree.java',
                  code: 'import java.util.*;\npublic class TimeToBurnBinaryTree {\n    public static TreeNode getNode(TreeNode root, int val) {\n        if (root == null) return null;\n        if (root.val == val) return root;\n        TreeNode l = getNode(root.left, val);\n        TreeNode r = getNode(root.right, val);\n        return l == null ? r : l;\n    }\n    public static void markParents(TreeNode root, HashMap<Integer, TreeNode> hm) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node.left != null) {\n                q.add(node.left);\n                hm.put(node.left.val, node);\n            }\n            if (node.right != null) {\n                q.add(node.right);\n                hm.put(node.right.val, node);\n            }\n        }\n    }\n    public static int timeToBurnTree(TreeNode root, int start) {\n        TreeNode target = getNode(root, start);\n        HashMap<Integer, TreeNode> hm = new HashMap<>();\n        markParents(root, hm);\n        Queue<TreeNode> q = new LinkedList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        q.add(target);\n        hs.add(target.val);\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            boolean flag = false;\n            for(int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                TreeNode parent = hm.getOrDefault(node.val, null);\n                if (parent != null && !hs.contains(parent.val)) {\n                    hs.add(parent.val);\n                    q.add(parent);\n                    flag = true;\n                }\n                if (node.left != null && !hs.contains(node.left.val)) {\n                    hs.add(node.left.val);\n                    q.add(node.left);\n                    flag = true;\n                }\n                if (node.right != null && !hs.contains(node.right.val)) {\n                    hs.add(node.right.val);\n                    q.add(node.right);\n                    flag = true;\n                }\n            }\n            if (flag) count++;\n        }\n        return count;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/time-to-burn-tree_1469067',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'ac975890-7de0-48f8-994f-2d877f9cd0b2',
                  isFolder: false,
                  name: 'BalancedBinaryTree.java',
                  code: 'public class BalancedBinaryTree {\n    public int solve(TreeNode root) {\n        if (root == null) return 0;\n        int left = solve(root.left);\n        int right = solve(root.right);\n        if (left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;\n        return Math.max(left, right) + 1;\n    }\n    public boolean isBalanced(TreeNode root) {\n        return solve(root) != -1;\n    }\n}',
                  link: 'https://leetcode.com/problems/balanced-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'bd66436f-2628-4edd-8a3e-fe794f5a9109',
                  isFolder: false,
                  name: 'BinaryTreeMaximumPathSum.java',
                  code: 'class BinaryTreeMaximumPathSum {\n    public static int solve(TreeNode root, int[] maxSum) {\n        if (root == null) return 0;\n        int l = Math.max(0, solve(root.left, maxSum));\n        int r = Math.max(0, solve(root.right, maxSum));\n        maxSum[0] = Math.max(maxSum[0], l + r + root.val);\n        return Math.max(l, r) + root.val;\n    }\n    public int maxPathSum(TreeNode root) {\n        int[] maxSum = new int[1];\n        maxSum[0] = Integer.MIN_VALUE;\n        solve(root, maxSum);\n        return maxSum[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-maximum-path-sum/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '9721f747-4b8d-4217-a6c9-811615e7f470',
                  isFolder: false,
                  name: 'BottomViewBinaryTree.java',
                  code: 'import java.util.*;\npublic class BottomViewBinaryTree {\n    static class Pair{\n        int idx;\n        TreeNode node;\n        Pair(int idx, TreeNode node) {\n            this.idx = idx;\n            this.node = node;\n        }\n    }\n    public static ArrayList<Integer> verticalTraversal(TreeNode root) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        Queue<Pair> q = new LinkedList<>();\n        int min = 0, max = 0;\n        q.add(new Pair(0, root));\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                TreeNode node = p.node;\n                hm.put(p.idx, node.val);\n                if (node.left != null) {\n                    min = Math.min(min, p.idx - 1);\n                    q.add(new Pair(p.idx - 1, node.left));\n                }\n                if (node.right != null) {\n                    max = Math.max(max, p.idx + 1);\n                    q.add(new Pair(p.idx + 1, node.right));\n                }\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) ans.add(hm.get(i));\n        return ans;\n    }\n    //Function to return a list containing the bottom view of the given tree.\n    public ArrayList <Integer> bottomView(TreeNode root)\n    {\n        // Code here\n        return verticalTraversal(root);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/bottom-view-of-binary-tree_893110',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'a9ea0ff9-e2f6-4edf-bfea-8b1808c7a031',
                  isFolder: false,
                  name: 'BoundaryTraversalOfBinaryTree.java',
                  code: 'import java.util.*;\npublic class BoundaryTraversalOfBinaryTree {\n    public static boolean isLeaf(TreeNode root) {\n        return root != null && root.left == null && root.right == null;\n    }\n    public static void addLeafNodes(TreeNode root, List<Integer> ans) {\n        if (root == null) return;\n        if (isLeaf(root)) ans.add(root.val);\n        addLeafNodes(root.left, ans);\n        addLeafNodes(root.right, ans);\n    }\n    public static void addLeftNodes(TreeNode curr, List<Integer> ans) {\n        while (curr != null) {\n            if (!isLeaf(curr)) ans.add(curr.val);\n            curr = curr.left != null ? curr.left : curr.right;\n        }\n    }\n    public static void addRightNodes(TreeNode curr, List<Integer> ans) {\n        Stack<Integer> st = new Stack<>();\n        while (curr != null) {\n            if (!isLeaf(curr)) st.add(curr.val);\n            curr = curr.right != null ? curr.right : curr.left;\n        }\n        while (!st.isEmpty()) ans.add(st.pop());\n    }\n    public static List<Integer> traverseBoundary(TreeNode root){\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        if (root == null) return ans;\n        ans.add(root.val);\n        addLeftNodes(root.left, ans);\n        addLeafNodes(root, ans);\n        addRightNodes(root.right, ans);\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/boundary-traversal-of-binary-tree_790725',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '9895f0c3-ccae-4774-a072-415ff9dd398a',
                  isFolder: false,
                  name: 'DiameterOfBinaryTree.java',
                  code: 'public class DiameterOfBinaryTree {\n    public static int solve(TreeNode root, int[] ans) {\n        // Write your code here.\n        if (root == null) return 0;\n        int l = solve(root.left, ans);\n        int r = solve(root.right, ans);\n        ans[0] = Math.max(ans[0], l+r);\n        return 1 + Math.max(l,r);\n    }\n    public int diameterOfBinaryTree(TreeNode root) {\n        int[] ans = new int[1];\n        solve(root, ans);\n        return ans[0];\n    }\n}',
                  link: 'https://leetcode.com/problems/diameter-of-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'b915f1c8-d269-4c21-8c40-162e5d1b75e2',
                  isFolder: false,
                  name: 'HeightOfABinaryTree.java',
                  code: 'public class HeightOfABinaryTree {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int depthL = maxDepth(root.left);\n        int depthR = maxDepth(root.right);\n        return Math.max(depthL, depthR) + 1;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-depth-of-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '73c9ce10-0fe5-43eb-af8f-8fdf4566ee8a',
                  isFolder: false,
                  name: 'LeftRightViewBinaryTree.java',
                  code: 'import java.util.*;\npublic class LeftRightViewBinaryTree {\n    void solve(TreeNode root, List<Integer> ans, int lvl) {\n        if (root == null) return;\n        if (ans.size() <= lvl) ans.add(root.val);\n        solve(root.right, ans, lvl + 1);\n        solve(root.left, ans, lvl + 1);\n    }\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        solve(root, ans, 0);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-right-side-view/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '26bcde03-5ac0-4133-9b90-3eb5c5989652',
                  isFolder: false,
                  name: 'SameTree.java',
                  code: 'class SameTree {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}',
                  link: 'https://leetcode.com/problems/same-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'd2dc3f48-2fef-4dca-9047-58cdebaaa0e1',
                  isFolder: false,
                  name: 'SymmetricBinaryTree.java',
                  code: 'public class SymmetricBinaryTree {\n    public static boolean solve(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return solve(p.left, q.right) && solve(p.right, q.left);\n    }\n    public boolean isSymmetric(TreeNode root) {\n        return root == null || solve(root.left, root.right);\n    }\n}',
                  link: 'https://leetcode.com/problems/symmetric-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'd834571f-f922-4a88-8598-45840e46c66e',
                  isFolder: false,
                  name: 'TopViewBinaryTree.java',
                  code: 'import java.util.*;\npublic class TopViewBinaryTree {\n    static class Pair{\n        int idx;\n        TreeNode node;\n        Pair(int idx, TreeNode node) {\n            this.idx = idx;\n            this.node = node;\n        }\n    }\n    public static ArrayList<Integer> verticalTraversal(TreeNode root) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        Queue<Pair> q = new LinkedList<>();\n        int min = 0, max = 0;\n        q.add(new Pair(0, root));\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                TreeNode node = p.node;\n                if (!hm.containsKey(p.idx))\n                    hm.put(p.idx, node.val);\n                if (node.left != null) {\n                    min = Math.min(min, p.idx - 1);\n                    q.add(new Pair(p.idx - 1, node.left));\n                }\n                if (node.right != null) {\n                    max = Math.max(max, p.idx + 1);\n                    q.add(new Pair(p.idx + 1, node.right));\n                }\n            }\n        }\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) ans.add(hm.get(i));\n        return ans;\n    }\n    static ArrayList<Integer> topView(TreeNode root) {\n        // add your code\n        return verticalTraversal(root);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/top-view-of-binary-tree_799401',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '338b2301-f52c-445e-a421-e37af54f435e',
                  isFolder: false,
                  name: 'VerticalOrderTraversalBinaryTree.java',
                  code: 'import java.util.*;\n\npublic class VerticalOrderTraversalBinaryTree {\n    static class Pair{\n        int idx, row;\n        TreeNode node;\n        Pair(int idx, int row, TreeNode node) {\n            this.idx = idx;\n            this.row = row;\n            this.node = node;\n        }\n    }\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\n        PriorityQueue<Pair> q = new PriorityQueue<>((a,b) -> a.row == b.row ? a.node.val - b.node.val : a.row - b.row);\n        int min = 0, max = 0;\n        q.add(new Pair(0, 0, root));\n        int row = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                TreeNode node = p.node;\n                if (!hm.containsKey(p.idx))\n                    hm.put(p.idx, new ArrayList<>());\n                hm.get(p.idx).add(node.val);\n                if (node.left != null) {\n                    min = Math.min(min, p.idx - 1);\n                    q.add(new Pair(p.idx - 1, row, node.left));\n                }\n                if (node.right != null) {\n                    max = Math.max(max, p.idx + 1);\n                    q.add(new Pair(p.idx + 1, row, node.right));\n                }\n            }\n            row++;\n        }\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) ans.add(hm.get(i));\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '4030c5d7-90ba-478d-850a-10156cd34614',
                  isFolder: false,
                  name: 'ZigZagLevelOrderTraversal.java',
                  code: 'import java.util.*;\nclass ZigZagLevelOrderTraversal {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) return ans;\n        boolean flip = true;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            List<Integer> temp = new ArrayList<>();\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                if (node != null) {\n                    if (flip) temp.add(node.val);\n                    else temp.add(0, node.val);\n\n                    if (node.left != null) q.add(node.left);\n                    if (node.right != null) q.add(node.right);\n                }\n            }\n            flip ^= true;\n            ans.add(temp);\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'dd5338ba-3f20-4d5d-b81d-9868ef3cc331',
                  isFolder: false,
                  name: 'BinarySearchTree.java',
                  code: 'import java.util.*;\n\npublic class BinarySearchTree {\n    public static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) {\n            this.val = val;\n            this.left = this.right = null;\n        }\n    }\n    public static class Pair {\n        TreeNode node;\n        int s;\n        Pair (TreeNode n, int s) {\n            this.node = n;\n            this.s = s;\n        }\n    }\n    TreeNode treeRoot;\n\n    TreeNode buildTree () {\n        return treeRoot;\n    }\n\n    //    TREE TRAVERSALS\n    //    DFS\n    public void printTree(String type) {\n        System.out.print(type + " traversal of Tree: [ ");\n        switch (type) {\n            case "Inorder" -> printTreeInOrder(treeRoot);\n            case "Preorder" -> printTreePreOrder(treeRoot);\n            case "Postorder" -> printTreePostOrder(treeRoot);\n        }\n        System.out.print("]\\n");\n    }\n\n    private void printTreeInOrder(TreeNode root) {\n//        Recursive\n//        if (root == null) return;\n//        printTreeInOrder(root.left);\n//        System.out.print(root.val + " ");\n//        printTreeInOrder(root.right);\n\n//        Iterative\n        Stack<TreeNode> st = new Stack<>();\n        TreeNode node = root;\n        while (node != null || !st.isEmpty()) {\n            while (node != null) {\n                st.push(node);\n                node = node.left;\n            }\n            node = st.pop();\n            System.out.print(root.val + " ");\n            node = node.right;\n        }\n    }\n\n    private void printTreePreOrder(TreeNode root) {\n//        Recursive\n//        if (root == null) return;\n//        System.out.print(root.val + " ");\n//        printTreePreOrder(root.left);\n//        printTreePreOrder(root.right);\n\n//        Iterative\n        Stack<TreeNode> st = new Stack<>();\n        TreeNode node = root;\n        while (node != null || !st.isEmpty()) {\n            while (node != null) {\n                System.out.print(root.val + " ");\n                st.push(node);\n                node = node.left;\n            }\n            node = st.pop().right;\n        }\n    }\n\n    private void printTreePostOrder(TreeNode root) {\n//        Recursive\n//        if (root == null) return;\n//        printTreePostOrder(root.left);\n//        printTreePostOrder(root.right);\n//        System.out.print(root.val + " ");\n\n//        Iterative (2 stack)\n//        if (root == null) return;\n//        Stack<TreeNode> st = new Stack<>();\n//        Stack<Integer> st2 = new Stack<>();\n//        st.push(root);\n//        while (!st.isEmpty()) {\n//            TreeNode temp = st.pop();\n//            st2.push(temp.val);\n//            if (temp.left != null) st.push(temp.left);\n//            if (temp.right != null) st.push(temp.right);\n//        }\n//        while (!st2.isEmpty()) {\n//            System.out.print(st2.pop() + " ");\n//        }\n\n//        Iterative (1 Stack)\n        TreeNode curr = root;\n        Stack<TreeNode> st = new Stack<>();\n        while (curr != null || !st.isEmpty()) {\n            if (curr != null) {\n                st.push(curr);\n                curr = curr.left;\n            } else {\n                TreeNode temp = st.peek().right;\n                if (temp == null) {\n                    temp = st.pop();\n                    System.out.print(temp.val + " ");\n                    while (!st.isEmpty() && temp == st.peek().right) {\n                        temp = st.pop();\n                        System.out.print(temp.val + " ");\n                    }\n                } else {\n                    curr = temp;\n                }\n            }\n        }\n    }\n\n    //    Level order traversal / BFS\n    public void levelOrderTraversal() {\n        Queue<TreeNode> q = new LinkedList<>();\n        if (treeRoot != null) q.add(treeRoot);\n        int level = 0;\n        while (!q.isEmpty()) {\n            System.out.print("level " + level + ": ");\n            int lvlLength = q.size();\n            for (int i = 0; i < lvlLength; i++) {\n                TreeNode temp = q.poll();\n                if (temp != null) {\n                    System.out.print(temp.val + " ");\n                    if (temp.left != null) q.add(temp.left);\n                    if (temp.right != null) q.add(temp.right);\n                }\n            }\n            level++;\n            System.out.println();\n        }\n    }\n\n    public void reverseLevelOrderTraversal() {\n        Queue<TreeNode> q = new LinkedList<>();\n        Stack<Integer> st = new Stack<>();\n        if (treeRoot != null) q.add(treeRoot);\n        int level = 0;\n        while (!q.isEmpty()) {\n            int lvlLength = q.size();\n            for (int i = 0; i < lvlLength; i++) {\n                TreeNode temp = q.poll();\n                if (temp != null) {\n                    st.add(temp.val);\n                    if (temp.right != null) q.add(temp.right);\n                    if (temp.left != null) q.add(temp.left);\n                }\n            }\n            st.push(null);\n            level++;\n        }\n        while (!st.isEmpty()) {\n            if (st.peek() == null) {\n                System.out.print("\\nlevel " + --level + ": ");\n                st.pop();\n            }\n            System.out.print(st.pop() + " ");\n        }\n    }\n\n\n    //    Insert\n    public void insert(int val) {\n        treeRoot = insert(treeRoot, val);\n    }\n\n    private TreeNode insert(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n        if (val >= root.val) {\n            root.right = insert(root.right, val);\n        } else {\n            root.left = insert(root.left, val);\n        }\n        return root;\n    }\n\n    //    Remove\n    public void remove(int val) {\n        treeRoot = remove(treeRoot, val);\n    }\n\n    public int findMinNodeValue() {\n        TreeNode node = findMinNode(treeRoot);\n        return node.val;\n    }\n\n    private TreeNode findMinNode(TreeNode root) {\n        TreeNode temp = root;\n        while (temp != null && temp.left != null) {\n            temp = temp.left;\n        }\n        return temp;\n    }\n\n    private TreeNode remove(TreeNode root, int val) {\n        if (root == null) return null;\n        if (val > root.val) {\n            root.right = remove(root.right, val);\n        } else if (val < root.val) {\n            root.left = remove(root.left, val);\n        } else {\n            if (root.left == null) return root.right;\n            if (root.right == null) return root.left;\n            TreeNode minNode = findMinNode(root.right);\n            root.val = minNode.val;\n            root.right = remove(root.right, minNode.val);\n        }\n        return root;\n    }\n\n    private void preInPostSingleTraversal(TreeNode root) {\n        Stack<Pair> st = new Stack<>();\n        List<Integer> inorder = new ArrayList<>();\n        List<Integer> preorder = new ArrayList<>();\n        List<Integer> postorder = new ArrayList<>();\n        st.push(new Pair(root, 1));\n        while (!st.isEmpty()) {\n            Pair temp = st.pop();\n            if (temp.s == 1) {\n                preorder.add(temp.node.val);\n                st.push(new Pair(temp.node, temp.s+1));\n                if (temp.node.left != null) {\n                    st.push(new Pair(temp.node.left, 1));\n                }\n            } else if (temp.s == 2) {\n                inorder.add(temp.node.val);\n                st.push(new Pair(temp.node, temp.s+1));\n                if (temp.node.right != null) {\n                    st.push(new Pair(temp.node.right, 1));\n                }\n            } else {\n                postorder.add(temp.node.val);\n            }\n        }\n        System.out.println("Pre: " + preorder);\n        System.out.println("In: " + inorder);\n        System.out.println("Post: " + postorder);\n\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n        int[] input = {7, 3, 5, 11, 17, 1, 8};\n        for (int j : input) tree.insert(j);\n//        tree.printTree("Inorder");\n//        tree.printTree("Preorder");\n//        tree.printTree("Postorder");\n//        tree.remove(7);\n//        tree.printTree("Inorder");\n//        HW\n        tree.levelOrderTraversal();\n//        tree.reverseLevelOrderTraversal();\n//        inorder, preorder, postorder traversal using iteration\n//        tree.preInPostSingleTraversal(tree.treeRoot);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Traversals'],
                },
              ],
            },
            {
              id: 'a81c1923-ea79-4a91-96c2-dae371f23a5d',
              isFolder: false,
              name: 'AdvancedMaths.java',
              code: 'import java.util.*;\n\npublic class AdvancedMaths {\n    public static List< Integer > countPrimes(int n) {\n        // Write your code here.\n        List<Integer> ans = new ArrayList<>();\n        boolean[] check = new boolean[n+1];\n        check[0] = true;\n        check[1] = true;\n        for (int i = 2; i <= n; i++) {\n            if (!check[i]) {\n                if (n%i == 0) {\n                    ans.add(i);\n                }\n                for (int j = i*2; j <= n; j += i) {\n                    check[j] = true;\n                }\n            }\n        }\n        return ans;\n    }\n\n//    https://www.codingninjas.com/studio/problems/power-of-numbers_8157729\n    public static long fastExponentiation(int n, int p) {\n        if (p == 0) return 1;\n        else if (p == 1) return n;\n        else {\n            long R = fastExponentiation(n, p/2)%(long)(10e9+7);\n            if (p%2 == 0) return (R*R)%1000000007;\n            else return (((R*n)%1000000007)*R)%1000000007;\n        }\n    }\n    public static int power(int N, int R){\n        // Write your code here.\n        int ans = (int) fastExponentiation(N, R);\n        return ans;\n    }\n\n//    https://www.codingninjas.com/studio/problems/subsequences-of-string_985087\n    public static ArrayList<String> subsequences(String str) {\n        // Write your code here\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 1; i < Math.pow(2, str.length()); i++) {\n            StringBuilder sb = new StringBuilder();\n            int idx = 0;\n            while(idx < str.length()) {\n                if (((i >> idx)&1) == 1) {\n                    sb.append(str.charAt(idx));\n                }\n                idx++;\n            }\n            ans.add(sb.toString());\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        ArrayList<String> ans = subsequences("hq");\n        System.out.println(ans);\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: 'd2170b1c-67ba-4f81-9c14-8f9857ebfe02',
              isFolder: false,
              name: 'InterviewProblems.java',
              code: 'public class InterviewProblems {\n    public static int getCount(int n) {\n        return LearnBitManipulationQuestions.getCount(n);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/flip-bits_8160405\n    public static int flipBits(int A, int B) {\n        // Write your code here.\n        int Xor = A ^ B;\n        return getCount(Xor);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/one-odd-occurring_4606074\n    public static int missingNumber(int n, int[] arr) {\n        // Write your code here.\n        int ans = 0;\n        for (int num : arr) {\n            ans ^= num;\n        }\n        return ans;\n    }\n\n    //    https://www.codingninjas.com/studio/problems/l-to-r-xor_8160412\n    public static int getXOR(int n) {\n        if (n % 4 == 0) return n;\n        if (n % 4 == 1) return 1;\n        if (n % 4 == 2) return n + 1;\n        return 0;\n    }\n\n    public static int findXOR(int L, int R) {\n        // Write your code here.\n        int lXor = getXOR(L - 1);\n        int rXor = getXOR(R);\n        return lXor ^ rXor;\n    }\n\n    public static int[] twoOddNum(int []arr){\n        int xor = 0;\n        for (int j : arr) {\n            xor ^= j;\n        }\n        int pos = 0;\n        while ((xor & 1) == 0) {\n            pos++;\n            xor >>= 1;\n        }\n        int xor1 = 0, xor2 = 0;\n        for (int num : arr) {\n            if (((num >> pos) & 1) == 1) xor1 ^= num;\n            else xor2 ^= num;\n        }\n        return new int[]{Math.max(xor1, xor2), Math.min(xor1, xor2)};\n    }\n\n    public static void main(String[] args) {\n\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: 'e0ea8f5a-1102-45d3-9ff5-ae2bcb89c7e9',
              isFolder: false,
              name: 'LearnBitManipulationQuestions.java',
              code: 'public class LearnBitManipulationQuestions {\n    public static int[] bitManipulation(int num, int i) {\n        int[] ans = new int[3];\n        int mask = 1 << (i - 1);\n        // 1. get ith bit\n        ans[0] = (num & mask) != 0 ? 1 : 0;\n        // 2. set ith bit\n        num = num | mask;\n        ans[1] = num;\n        // 3. clear ith bit\n        ans[2] = num & ~mask;\n        return ans;\n    }\n\n    public static boolean isKthBitSet(int n, int k) {\n        int mask = 1 << (k - 1);\n        return (n & mask) != 0;\n    }\n\n    public static String oddEven(int N) {\n        // Write your code here.\n        return (N & 1) == 0 ? "even" : "odd";\n    }\n\n    public static boolean isPowerOfTwo(int n) {\n        // Write your code here.\n        return (n & (n - 1)) == 0;\n    }\n\n    //    Count set bits in range 1 - N\n    public static int getCount(int n) {\n        int count = 0;\n        while (n != 0) {\n            n = (n & (n - 1));\n            count++;\n        }\n        return count;\n    }\n\n    public static int countSetBits(int n) {\n        //Write your code here\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            count += getCount(i);\n        }\n        return count;\n    }\n\n    //    https://www.codingninjas.com/studio/problems/set-the-rightmost-unset-bit_8160456\n    public static int setBits(int N) {\n        // Write your code here\n        int n = N;\n        if ((n & (n + 1)) == 0) return N;\n        int idx = 0;\n        while (n > 0) {\n            if ((n & 1) == 0) break;\n            idx++;\n            n >>= 1;\n        }\n        return N | (1 << idx);\n    }\n\n    //    https://www.codingninjas.com/studio/problems/swap-two-numbers_1380853\n    public static void swapNumber(int[] a, int[] b) {\n        // Write your code here.\n        a[0] = a[0] ^ b[0];\n        b[0] = a[0] ^ b[0];\n        a[0] = a[0] ^ b[0];\n    }\n\n//    https://www.codingninjas.com/studio/problems/flip-bits_8160405\n    public static int flipBits(int A, int B){\n        // Write your code here.\n        int Xor = A^B;\n        return getCount(Xor);\n    }\n\n//    https://www.codingninjas.com/studio/problems/one-odd-occurring_4606074\n    public static int missingNumber(int n, int []arr){\n        // Write your code here.\n        int ans = 0;\n        for (int num : arr) {\n            ans ^= num;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n//        int n = 11;\n//        int i = 2;\n//        int[] ans = bitManipulation(n, i);\n//        System.out.println(Arrays.toString(ans));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: 'd040d484-10f3-44f6-9092-73345a67d588',
              isFolder: false,
              name: 'SieveOfEratosthenes.java',
              code: 'import java.util.*;\npublic class SieveOfEratosthenes {\n    static List<Integer> getPrime(int n) {\n        List<Integer> ans = new ArrayList<>();\n        boolean[] check = new boolean[n+1];\n        check[0] = true;\n        check[1] = true;\n        for (int i = 2; i <= n; i++) {\n            if (!check[i]) {\n                ans.add(i);\n                for (int j = i*2; j <= n; j += i)\n                    check[j] = true;\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args) {\n        int n = 10;\n        System.out.println(getPrime(n));\n    }\n}',
              link: null,
              notes: '',
              tags: ['Bit_Manipulation'],
            },
            {
              id: '85c9a68e-9eb6-4547-b2d4-eee6ece22956',
              isFolder: true,
              name: 'Graphs',
              content: [
                {
                  id: '758f8088-2241-466a-8d89-5dab3abbc2a6',
                  isFolder: false,
                  name: 'Graph.java',
                  code: 'import java.util.*;\n\npublic class Graph {\n    static class Edge {\n        int source, destination;\n\n        Edge(int s, int d) {\n            this.source = s;\n            this.destination = d;\n        }\n\n        @Override\n        public String toString() {\n            return "Edge{ src=" + source + ", dest=" + destination + \'}\';\n        }\n    }\n\n    static int getNeighbours(List<Edge> adjListItem) {\n        System.out.print("Neighbours: ");\n        for (Edge e : adjListItem) {\n            System.out.print(e.destination + " ");\n        }\n        return adjListItem.size();\n    }\n\n    static void buildGraph(List<Edge>[] adjList) {\n        for (int i = 0; i < adjList.length; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n        adjList[0].add(new Edge(0, 1));\n        adjList[0].add(new Edge(0, 2));\n\n        adjList[1].add(new Edge(1, 0));\n        adjList[1].add(new Edge(1, 3));\n\n        adjList[2].add(new Edge(2, 0));\n        adjList[2].add(new Edge(2, 4));\n\n        adjList[3].add(new Edge(3, 1));\n        adjList[3].add(new Edge(3, 4));\n\n        adjList[4].add(new Edge(4, 2));\n        adjList[4].add(new Edge(4, 5));\n\n        adjList[5].add(new Edge(5, 3));\n        adjList[5].add(new Edge(5, 4));\n        adjList[5].add(new Edge(5, 6));\n\n        adjList[6].add(new Edge(6, 5));\n    }\n\n    static void bfs(List<Edge>[] adjList) {\n        boolean[] visited = new boolean[adjList.length];\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n    static void bfsDisjoint(List<Edge>[] adjList, boolean[] visited, int start) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(start);\n        while (!q.isEmpty()) {\n            int curr = q.poll();\n            if (!visited[curr]) {\n                System.out.print(curr + " ");\n                visited[curr] = true;\n                for (int i = 0; i < adjList[curr].size(); i++) {\n                    int destination = adjList[curr].get(i).destination;\n                    q.add(destination);\n                }\n            }\n        }\n    }\n\n    static void dfs(List<Edge>[] adjList, boolean[] visited, int curr) {\n        System.out.print(curr + " ");\n        visited[curr] = true;\n        for (int i = 0; i < adjList[curr].size(); i++) {\n            int dist = adjList[curr].get(i).destination;\n            if (!visited[dist]) {\n                dfs(adjList, visited, dist);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 7;\n        List<Edge>[] adjList = new List[V];\n        buildGraph(adjList);\n        for (int i = 0; i < adjList.length; i++) {\n            System.out.println(i + ": " + adjList[i]);\n        }\n//        Print neighbour information\n//        int len = getNeighbours(adjList[2]);\n//        System.out.println("\\n2 has " + len + " neighbours");\n\n//        BFS\n//        bfs(adjList);\n//        boolean[] visited = new boolean[adjList.length];\n//        for (int i = 0; i < visited.length; i++) {\n//            if (!visited[i]) {\n//                bfsDisjoint(adjList, visited, i);\n//            }\n//        }\n\n//        DFS\n        boolean[] visited = new boolean[adjList.length];\n        dfs(adjList, visited, 0);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '5cee1b89-04f9-4f02-8a18-fedbeb004afa',
                  isFolder: false,
                  name: 'BipartiteGraph.java',
                  code: 'import java.util.*;\n\npublic class BipartiteGraph {\n    public boolean dfs(int[][] graph, int[] visited, int curr, int color) {\n        visited[curr] = color;\n        for (int i = 0; i < graph[curr].length; i++) {\n            if (visited[graph[curr][i]] == 0) {\n                if (!dfs(graph, visited, graph[curr][i], color == 5 ? 10 : 5)) return false;\n            } else if (visited[curr] == visited[graph[curr][i]]) return false;\n        }\n        return true;\n    }\n\n    public boolean bfs(int[][] graph, int[] visited, int curr) {\n        boolean flip = false;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(curr);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            int color = flip ? 5 : 10;\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                visited[node] = color;\n                for (int j = 0; j < graph[node].length; j++) {\n                    if (visited[graph[node][j]] == 0) {\n                        q.add(graph[node][j]);\n                    } else if (visited[node] == visited[graph[node][j]]) {\n                        return false;\n                    }\n                }\n            }\n            flip = !flip;\n        }\n        return true;\n    }\n    public boolean isBipartite(int[][] graph) {\n        int V = graph.length;\n        int[] visited = new int[V];\n        for (int i = 0; i < V; i++) {\n            if (visited[i] == 0) {\n                // if (!bfs(graph, visited, i)) return false;\n                if (!dfs(graph, visited, i, 5)) return false;\n            }\n        }\n        return true;\n    }\n}',
                  link: 'https://leetcode.com/problems/is-graph-bipartite/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '9a1cd60b-592f-4829-93d9-822ae3a4883f',
                  isFolder: false,
                  name: 'CycleDetectionDirectedGraphDFS.java',
                  code: 'import java.util.*;\n\npublic class CycleDetectionDirectedGraphDFS {\n    public static boolean dfsCyclic(List<List<Integer>> adj, boolean[] visited, int curr, boolean[] dfsVisited) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        dfsVisited[curr] = true;\n        for (int ele : list) {\n            if (!visited[ele]) {\n                if (dfsCyclic(adj, visited, ele, dfsVisited)) return true;\n            } else if (dfsVisited[ele]) return true;\n        }\n        dfsVisited[curr] = false;\n        return false;\n    }\n    public static Boolean isCyclic(int[][] edges, int v, int e) {\n        // Write your code here.\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < v; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < e; i++) {\n            adj.get(edges[i][0]).add(edges[i][1]);\n        }\n        boolean[] visited = new boolean[v];\n        boolean[] dfsVisited = new boolean[v];\n        for (int i = 0; i < v; i++) {\n            if (!visited[i]) {\n                if (dfsCyclic(adj, visited, i, dfsVisited)) return true;\n            }\n        }\n        return false;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/detect-cycle-in-a-directed-graph-_920545',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'c39361fb-7871-45d7-9ebb-dceea8f759f4',
                  isFolder: false,
                  name: 'CycleDetectionUndirectedGraph.java',
                  code: 'import java.util.*;\npublic class CycleDetectionUndirectedGraph {\n    boolean bfsCyclic(List<List<Integer>> adj, boolean[] visited, int curr) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(curr);\n        int[] parents = new int[visited.length];\n        parents[curr] = -1;\n        while (!q.isEmpty()) {\n            int node = q.poll();\n            visited[node] = true;\n            List<Integer> list = adj.get(node);\n            for (int ele : list) {\n                if (!visited[ele]) {\n                    q.add(ele);\n                    parents[ele] = node;\n                } else if (parents[node] != ele) return true;\n            }\n        }\n        return false;\n    }\n    boolean dfsCyclic(List<List<Integer>> adj, boolean[] visited, int curr, int parent) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (int ele : list) {\n            if (!visited[ele]) {\n                if (dfsCyclic(adj, visited, ele, curr)) return true;\n            }\n            else if (parent != ele) return true;\n        }\n        return false;\n    }\n    boolean detectCycle(int V, List<List<Integer>> adj) {\n        // Write your code here.\n        boolean[] visited = new boolean[V];\n        for (int i = 0; i < V; i++) {\n            if (!visited[i] && dfsCyclic(adj, visited, i, -1)) return true;\n//            if (!visited[i] && bfsCyclic(adj, visited, i)) return true;\n        }\n        return false;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/detect-cycle-in-an-undirected-graph-_758967',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '9fe1011e-cc64-4af4-aa1c-0ee2b9e14309',
                  isFolder: false,
                  name: 'DistinctIslands.java',
                  code: 'import java.util.*;\npublic class DistinctIslands {\n    static void dfs(int[][] mat, int i, int j, List<List<Integer>> ans, int ogI, int ogJ) {\n        if (i < 0 || j < 0 || i >= mat.length || j >= mat[0].length || mat[i][j] != 1) return;\n        ans.add(new ArrayList<>(Arrays.asList(i - ogI, j - ogJ)));\n        mat[i][j] = 2;\n        dfs(mat, i, j+1, ans, ogI, ogJ);\n        dfs(mat, i+1, j, ans, ogI, ogJ);\n        dfs(mat, i, j-1, ans, ogI, ogJ);\n        dfs(mat, i-1, j, ans, ogI, ogJ);\n    }\n    public static int distinctIsland(int [][] mat, int m, int n) {\n        //write your code here\n        Set<List<List<Integer>>> hs = new HashSet<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    List<List<Integer>> ans = new ArrayList<>();\n                    dfs(mat, i, j, ans, i, j);\n                    hs.add(ans);\n                }\n            }\n        }\n        return hs.size();\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/distinct-islands_630460',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: 'b5164493-7ecf-46ac-a433-103ef87c62db',
                  isFolder: false,
                  name: 'FloodFill.java',
                  code: 'import java.util.*;\npublic class FloodFill {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n    static boolean checkInBounds (int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n        int m = image.length;\n        int n = image[0].length;\n        int startColor = image[sr][sc];\n        int[][] directions = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n        boolean[][] visited = new boolean[m][n];\n        Queue<Pair> q = new LinkedList<>();\n        q.add(new Pair(sr, sc));\n        image[sr][sc] = color;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                visited[p.row][p.col] = true;\n                for (int[] direction : directions) {\n                    int r = p.row + direction[0];\n                    int c = p.col + direction[1];\n                    if (checkInBounds(r, c, m, n) && !visited[r][c] && image[r][c] == startColor) {\n                        image[r][c] = color;\n                        q.add(new Pair(r, c));\n                    }\n                }\n            }\n        }\n        return image;\n    }\n}',
                  link: 'https://leetcode.com/problems/flood-fill/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '7f39d370-1a81-4fcd-989f-28a8b815a4cd',
                  isFolder: false,
                  name: 'Matrix01.java',
                  code: 'import java.util.*;\npublic class Matrix01 {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n    public boolean isInBound(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int[][] updateMatrix(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[][] ans = new int[m][n]; // for good practice\n        Queue<Pair> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 1) {\n                    ans[i][j] = -1;\n                } else {\n                    q.add(new Pair(i,j));\n                }\n            }\n        }\n        int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                for (int j = 0; j < 4; j++) {\n                    int r = p.row + dirs[j][0];\n                    int c = p.col + dirs[j][1];\n                    if (isInBound(r,c,m,n) && ans[r][c] == -1) {\n                        ans[r][c] = ans[p.row][p.col] + 1;\n                        q.add(new Pair(r,c));\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/01-matrix/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '960d61fe-9565-4325-b0e9-d487018daca6',
                  isFolder: false,
                  name: 'NumberOfEnclaves.java',
                  code: 'public class NumberOfEnclaves {\n    void dfs(int[][] grid, int i, int j) {\n        if (i < 0  || i >= grid.length  || j < 0  || j >= grid[0].length || grid[i][j] != 1) return;\n        grid[i][j] = 2;\n        dfs(grid, i, j + 1);\n        dfs(grid, i + 1, j);\n        dfs(grid, i, j - 1);\n        dfs(grid, i - 1, j);\n    }\n    public int numEnclaves(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 1) dfs(grid, i, 0);\n            if (grid[i][n-1] == 1) dfs(grid, i, n - 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[0][i] == 1) dfs(grid, 0, i);\n            if (grid[m - 1][i] == 1) dfs(grid, m-1, i);\n        }\n        int count = 0;\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                if(grid[i][j] == 1) count++;\n\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-enclaves/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '49b6fd7f-2e6a-4ce7-ac01-b24ae25b0a52',
                  isFolder: false,
                  name: 'NumberOfProvinces.java',
                  code: 'public class NumberOfProvinces {\n    public static void dfs(int[][] isConnected, boolean[] visited, int curr) {\n        visited[curr] = true;\n        for (int i = 0; i < isConnected[curr].length; i++) {\n            if (isConnected[curr][i] == 1) {\n                if (!visited[i])\n                    dfs(isConnected, visited, i);\n            }\n        }\n    }\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                count++;\n                dfs(isConnected, visited, i);\n            }\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/number-of-provinces/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '0f3d4793-c4e7-4edc-910a-5ed87826d353',
                  isFolder: false,
                  name: 'RottingOranges.java',
                  code: 'import java.util.*;\npublic class RottingOranges {\n    static class Pair {\n        int row, col;\n        Pair(int r, int c) {\n            row = r;\n            col = c;\n        }\n    }\n    public boolean isInBound(int r, int c, int m, int n) {\n        return r >= 0 && c >= 0 && r < m && c < n;\n    }\n    public int orangesRotting(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<Pair> q = new LinkedList<>();\n        int fresh = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) q.add(new Pair(i, j));\n                else if (grid[i][j] == 1) fresh++;\n            }\n        }\n        if (fresh == 0) return 0;\n        // if (fresh > 0 && q.isEmpty()) return -1;\n        boolean[][] visited = new boolean[m][n];\n        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                Pair p = q.poll();\n                visited[p.row][p.col] = true;\n                for (int d = 0; d < 4; d++) {\n                    int r = directions[d][0] + p.row;\n                    int c = directions[d][1] + p.col;\n                    if (isInBound(r,c,m,n) && !visited[r][c] && grid[r][c] == 1) {\n                        grid[r][c] = 2;\n                        q.add(new Pair(r, c));\n                        fresh--;\n                    }\n                }\n            }\n            if (!q.isEmpty()) count++;\n        }\n        return fresh == 0 ? count : -1;\n    }\n}',
                  link: 'https://leetcode.com/problems/rotting-oranges/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '7bb7e615-88e9-4049-bdd8-63d7cf4f0187',
                  isFolder: false,
                  name: 'SurroundedRegions.java',
                  code: "public class SurroundedRegions {\n    void dfs(char[][] board, int i, int j) {\n        if (i < 0\n                || i >= board.length\n                || j < 0\n                || j >= board[0].length\n                || board[i][j] != 'O') return;\n        board[i][j] = 'A';\n        dfs(board, i, j + 1);\n        dfs(board, i + 1, j);\n        dfs(board, i, j - 1);\n        dfs(board, i - 1, j);\n    }\n    public void solve(char[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n        for (int i = 0; i < n; i++) {\n            if (board[0][i] == 'O') dfs(board, 0, i);\n            if (board[m - 1][i] == 'O') dfs(board, m-1, i);\n        }\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') dfs(board, i, 0);\n            if (board[i][n-1] == 'O') dfs(board, i, n - 1);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(board[i][j] == 'O')\n                    board[i][j] = 'X';\n                else if(board[i][j] == 'A')\n                    board[i][j] = 'O';\n            }\n        }\n    }\n}",
                  link: 'https://leetcode.com/problems/surrounded-regions/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '6fdb870d-ba12-4c63-baa2-6242b1b359e8',
                  isFolder: false,
                  name: 'WordLadder1.java',
                  code: "import java.util.*;\n\npublic class WordLadder1 {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> hs = new HashSet<>(wordList);\n        Queue<String> q = new LinkedList<>();\n        q.add(beginWord);\n        hs.remove(beginWord);\n        int count = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                String s = q.poll();\n                if (s.equals(endWord)) return count;\n                for (int l = 0; l < s.length(); l++) {\n                    char old = s.charAt(l);\n                    char[] replaceArray = s.toCharArray();\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\n                        replaceArray[l] = ch;\n                        String str = new String(replaceArray);\n                        if (hs.contains(str)) {\n                            q.add(str);\n                            hs.remove(str);\n                        }\n                    }\n                    replaceArray[l] = old;\n                }\n            }\n            count++;\n        }\n        return 0;\n    }\n}",
                  link: 'https://leetcode.com/problems/word-ladder/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '454e7aa9-443c-44f3-b4d2-27570d51315c',
                  isFolder: false,
                  name: 'WordLadder2.java',
                  code: "import java.util.*;\n\npublic class WordLadder2 {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> ans = new ArrayList<>();\n        List<String> removeList = new ArrayList<>();\n        HashSet<String> hs = new HashSet<>(wordList);\n        Queue<List<String>> q = new LinkedList<>();\n        q.add(new ArrayList<>(Collections.singletonList(beginWord)));\n        removeList.add(beginWord);\n        while (!q.isEmpty() && ans.isEmpty()) {\n            int size = q.size();\n            removeList.forEach(hs::remove);\n            for (int i = 0; i < size; i++) {\n                List<String> temp = q.poll();\n                String last = temp.getLast();\n                for (int s = 0; s < last.length(); s++) {\n                    char[] arr = last.toCharArray();\n                    char old = arr[s];\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\n                        arr[s] = ch;\n                        String str = new String(arr);\n                        if (hs.contains(str)) {\n                            List<String> newList = new ArrayList<>(temp);\n                            newList.add(str);\n                            if (str.equals(endWord)) ans.add(newList);\n                            else q.add(newList);\n                            removeList.add(str);\n                        }\n                    }\n                    arr[s] = old;\n                }\n            }\n        }\n        return ans;\n    }\n}",
                  link: 'https://leetcode.com/problems/word-ladder-ii/',
                  notes: '',
                  tags: ['Problems on DFS and BFS'],
                },
                {
                  id: '58b97840-42f2-4044-81ae-cbb60efde54d',
                  isFolder: false,
                  name: 'CourseSchedule.java',
                  code: 'import java.util.*;\n\npublic class CourseSchedule {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] prerequisite : prerequisites) {\n            indegree[prerequisite[0]]++;\n            adj.get(prerequisite[1]).add(prerequisite[0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                count++;\n                for (int j = 0; j < adj.get(node).size(); j++) {\n                    int ele = adj.get(node).get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count == numCourses;\n    }\n}',
                  link: 'https://leetcode.com/problems/course-schedule/',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: '76054a0e-ffa6-4547-81f9-217d7c47ee5a',
                  isFolder: false,
                  name: 'CourseSchedule2.java',
                  code: 'import java.util.*;\n\npublic class CourseSchedule2 {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] prerequisite : prerequisites) {\n            indegree[prerequisite[0]]++;\n            adj.get(prerequisite[1]).add(prerequisite[0]);\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        int[] ans = new int[numCourses];\n        int count = 0;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans[count++] = node;\n                for (int j = 0; j < adj.get(node).size(); j++) {\n                    int ele = adj.get(node).get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count == numCourses ? ans : new int[]{};\n    }\n}',
                  link: 'https://leetcode.com/problems/course-schedule-ii/',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: '908ed4ef-0f5d-403c-b128-fa2bf6d51c87',
                  isFolder: false,
                  name: 'CycleInDetectionDirectedGraphBFS.java',
                  code: 'import java.util.*;\n\npublic class CycleInDetectionDirectedGraphBFS {\n    public static boolean detectCycleInDirectedGraph(int n, ArrayList<ArrayList<Integer>> edges) {\n        // Write your code here.\n        int e = edges.size();\n        int[] indegree = new int[n];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)  {\n            adj.add(new ArrayList<>());\n        }\n        for(int i = 0; i < e; i++){\n            List<Integer> list = edges.get(i);\n            int x = list.get(0) - 1;\n            int y = list.get(1) - 1;\n            adj.get(x).add(y);\n            indegree[y]++;\n        }\n        Queue<Integer> q = new LinkedList<>();\n        int count = 0;\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                count++;\n                List<Integer> list = adj.get(node);\n                for (int j = 0; j < list.size(); j++) {\n                    int ele = list.get(j);\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        return count != n;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/detect-cycle-in-a-directed-graph_1062626',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: 'de4abda7-e293-4207-b6ce-c5c872d46b80',
                  isFolder: false,
                  name: 'FindEventualSafeStates.java',
                  code: 'import java.util.*;\n\npublic class FindEventualSafeStates {\n    public boolean dfs(int[][] graph, boolean[] visited, int[] dfsVisited, int curr) {\n        visited[curr] = true;\n        dfsVisited[curr] = 1;\n        for (int i = 0; i < graph[curr].length; i++) {\n            if (!visited[graph[curr][i]]) {\n                if (!dfs(graph, visited, dfsVisited, graph[curr][i])) return false;\n            } else if (dfsVisited[graph[curr][i]] == 1) return false;\n        }\n        dfsVisited[curr] = 0;\n        return true;\n    }\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        // DFS\n        // boolean[] visited = new boolean[graph.length];\n        // int[] dfsVisited = new int[graph.length];\n        // for (int i = 0; i < graph.length; i++) {\n        //     if (!visited[i]) {\n        //         dfs(graph, visited, dfsVisited, i);\n        //     }\n        // }\n        // List<Integer> ans = new ArrayList<>();\n        // for (int i = 0; i < graph.length; i++) {\n        //     if (dfsVisited[i] == 0) {\n        //         ans.add(i);\n        //     }\n        // }\n        // return ans;\n\n\n        // BFS\n        List<List<Integer>> adjRev = new ArrayList<>();\n        int V = graph.length;\n        int[] indegree = new int[V];\n        for (int i = 0; i < V; i++) {\n            adjRev.add(new ArrayList<>());\n        }\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < graph[i].length; j++) {\n                indegree[i]++;\n                adjRev.get(graph[i][j]).add(i);\n            }\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < V; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans.add(node);\n                List<Integer> list = adjRev.get(node);\n                for (int ele : list) {\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n        Collections.sort(ans);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/find-eventual-safe-states/',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
                {
                  id: 'd2cf61ce-c434-4233-a15a-cef998f88dbe',
                  isFolder: false,
                  name: 'TopologicalSort.java',
                  code: 'import java.util.*;\n\npublic class TopologicalSort {\n    public static void bfs(List<List<Integer>> adj, List<Integer> ans, int[] indegree) {\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < indegree.length; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.poll();\n                ans.add(node);\n                List<Integer> list = adj.get(node);\n                for (int ele : list) {\n                    indegree[ele]--;\n                    if (indegree[ele] == 0) {\n                        q.add(ele);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void dfs(List<List<Integer>> adj, boolean[] visited, int curr, Stack<Integer> st) {\n        visited[curr] = true;\n        List<Integer> list = adj.get(curr);\n        for (Integer it : adj.get(curr)) {\n            if (!visited[it]) {\n                dfs(adj, visited, it, st);\n            }\n        }\n        st.push(curr);\n    }\n\n    public static List<Integer> topologicalSort(int[][] edges, int e, int v) {\n        // Write your code here!\n        int[] indegree = new int[v];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < v; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < e; i++) {\n            int x = edges[i][0];\n            int y = edges[i][1];\n            adj.get(x).add(y);\n            indegree[edges[i][1]]++;\n        }\n//        Stack<Integer> st = new Stack<>();\n//        boolean[] visited = new boolean[v];\n        List<Integer> ans = new ArrayList<>();\n        bfs(adj, ans, indegree);\n//        for (int i = 0; i < v; i++) {\n//            if (!visited[i]) {\n//                dfs(adj, visited, i, st);\n//            }\n//        }\n//         while (!st.isEmpty()) {\n//             ans.add(st.pop());\n//         }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/topological-sorting_973003',
                  notes: '',
                  tags: ['Topo sort and Problems'],
                },
              ],
            },
            {
              id: '8bb00ea1-6083-44f4-85f9-0493044c373d',
              isFolder: true,
              name: 'Greedy Algorithms',
              content: [
                {
                  id: '14d5d00d-fe60-4168-8d7c-c88dc56b600c',
                  isFolder: false,
                  name: 'AssignCookies.java',
                  code: 'import java.util.*;\npublic class AssignCookies {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0, j = 0;\n        int count = 0;\n        while (j < s.length && i < g.length) {\n            if (s[j] >= g[i]) {\n                count++;\n                i++;\n            }\n            j++;\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/assign-cookies/',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: '1fdb910f-19cf-4ac6-8677-4d4ee0032e54',
                  isFolder: false,
                  name: 'FractionalKnapsack.java',
                  code: 'import java.util.*;\npublic class FractionalKnapsack {\n    static class Item {\n        int value, weight;\n        Item(int x, int y) {\n            this.value = x;\n            this.weight = y;\n        }\n    }\n    static class Pair {\n        Item item;\n        double ratio;\n        Pair(Item a, double r) {\n            this.item = a;\n            this.ratio = r;\n        }\n    }\n    //Function to get the maximum total value in the knapsack.\n    static double fractionalKnapsack(int W, Item[] arr, int n) {\n        // Your code here\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Double.compare(b.ratio, a.ratio));\n        for (int i = 0; i < n; i++)\n            pq.add(new Pair(arr[i], (double) arr[i].value / arr[i].weight));\n        double result = 0;\n        while (W > 0 && !pq.isEmpty()) {\n            Pair p = pq.poll();\n            if (p.item.weight <= W) {\n                W -= p.item.weight;\n                result += p.item.value;\n            } else {\n                result += p.ratio * W;\n                break;\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Item[] items = new Item[3];\n        items[0] = new Item(60,10);\n        items[1] = new Item(100, 20);\n        items[2] = new Item(120, 30);\n        double ans = fractionalKnapsack(50, items, 3);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://practice.geeksforgeeks.org/problems/fractional-knapsack-1587115620/1',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: 'cb1f323b-e52c-438b-aa95-9fe316389c26',
                  isFolder: false,
                  name: 'LemonadeChange.java',
                  code: 'public class LemonadeChange {\n    public boolean lemonadeChange(int[] bills) {\n        int ten = 0, five = 0;\n        for (int bill : bills) {\n            if (bill == 5) five++;\n            else if (bill == 10) {\n                ten++;\n                if (five >= 1) five--;\n                else return false;\n            } else if (bill == 20) {\n                if (ten >= 1 && five >= 1) {\n                    ten--;\n                    five--;\n                }\n                else if (five >= 3)\n                    five -= 3;\n                else return false;\n            }\n        }\n        return true;\n    }\n}',
                  link: 'https://leetcode.com/problems/lemonade-change/',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: '3a146995-5c12-4368-9cde-83cad602cc18',
                  isFolder: false,
                  name: 'MinNumberOfCoins.java',
                  code: 'import java.util.*;\npublic class MinNumberOfCoins {\n    public static List<Integer> MinimumCoins(int V) {\n        // Write your code here.\n        int[] arr = { 1000, 500, 100, 50, 20, 10, 5, 2, 1 };\n        List<Integer> result = new ArrayList<>();\n        int i = 0;\n        while (V > 0 && i < arr.length) {\n            if (arr[i] <= V) {\n                result.add(arr[i]);\n                V -= arr[i];\n                continue;\n            }\n            i++;\n        }\n        return result;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-minimum-number-of-coins_975277',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: 'e7af52b1-9bb3-4f92-82ad-ce1c2a5911fb',
                  isFolder: false,
                  name: 'ValidParenthesisString.java',
                  code: "public class ValidParenthesisString {\n    public boolean checkValidString(String s) {\n        int leftMin = 0, leftMax = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') {\n                leftMin++;\n                leftMax++;\n            } else if (ch == ')') {\n                leftMin--;\n                leftMax--;\n            } else {\n                leftMin--;\n                leftMax++;\n            }\n            if (leftMax < 0) return false;\n            if (leftMin < 0) leftMin = 0;\n        }\n        return leftMin == 0;\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-parenthesis-string/',
                  notes: '',
                  tags: ['Easy Problems'],
                },
                {
                  id: 'b49e29af-cd99-478e-8860-e195bb84c9d6',
                  isFolder: false,
                  name: 'Candy.java',
                  code: 'import java.util.*;\n\npublic class Candy {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        if (n == 1) return 1;\n        int[] result = new int[n];\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i-1]) {\n                result[i] = result[i-1] + 1;\n            }\n        }\n        for (int i = n-2; i >= 0; i--) {\n            if (ratings[i] > ratings[i+1]) {\n                result[i] = Math.max(result[i], result[i+1] + 1);\n            }\n        }\n        System.out.println(Arrays.toString(result));\n        int count = n;\n        for (int x : result) {\n            count += x;\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/candy/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '9cf3cfe8-abad-49e5-a992-d239f855b2fc',
                  isFolder: false,
                  name: 'InsertInterval.java',
                  code: 'import java.util.*;\n\npublic class InsertInterval {\n\n    public static int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> list = new ArrayList<>();\n        for (int[] interval: intervals) {\n            if (newInterval == null || interval[1] < newInterval[0]) {\n                list.add(interval);\n            } else if (interval[0] > newInterval[1]) {\n                list.add(newInterval);\n                list.add(interval);\n                newInterval = null;\n            } else {\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\n            }\n        }\n        if (newInterval != null) list.add(newInterval);\n        return list.toArray(new int[list.size()][]);\n    }\n\n    public static void main(String[] args) {\n        int[][] intervals = {{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}};\n        int[] newInterval = {4, 8};\n        int[][] ans = insert(intervals, newInterval);\n        for (int[] a : ans) {\n            System.out.println(Arrays.toString(a));\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/insert-interval/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '776191f9-ae0e-4697-9e3d-973524eed19b',
                  isFolder: false,
                  name: 'JobSequencingProblem.java',
                  code: "import java.util.Arrays;\n\npublic class JobSequencingProblem {\n//    In coding ninja's platform the jobs are given in  2D array form the concept remains the same\n    static class Job {\n        int id, profit, deadline;\n\n        Job(int x, int y, int z) {\n            this.id = x;\n            this.deadline = y;\n            this.profit = z;\n        }\n    }\n\n    static int[] JobScheduling(Job[] arr, int n) {\n        Arrays.sort(arr, (a,b) -> (b.profit - a.profit));\n        int maxi = 0;\n        for (int i = 0; i < n; i++) {\n            maxi = Math.max(maxi, arr[i].deadline);\n        }\n        int[] result = new int[maxi + 1];\n        int totalProfit = 0, totalJobs = 0;\n        for (int i = 0; i < n; i++) {\n            for (int idx = arr[i].deadline; idx > 0; idx--) {\n                if (result[idx] == 0) {\n                    result[idx] = arr[i].profit;\n                    totalJobs++;\n                    totalProfit += arr[i].profit;\n                    break;\n                }\n            }\n        }\n        return new int[] {totalJobs, totalProfit};\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/job-sequencing-problem_1169460',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'c7db603e-8ea9-4803-8c4e-8850fbc3991f',
                  isFolder: false,
                  name: 'JumpGame.java',
                  code: 'public class JumpGame {\n    public boolean canJump(int[] nums) {\n        int goal = nums.length - 1;\n        for (int i = nums.length - 2; i >= 0; i--)\n            if (goal <= (nums[i] + i))\n                goal = i;\n        return goal == 0;\n    }\n}',
                  link: 'https://leetcode.com/problems/jump-game/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'c261f825-8653-442f-ae6e-596bcd5d9524',
                  isFolder: false,
                  name: 'JumpGame2.java',
                  code: 'public class JumpGame2 {\n    public int jump(int[] nums) {\n        int count = 0;\n        int l = 0, r = 0;\n        while (r < nums.length - 1) {\n            int max = 0;\n            for (int i = l; i <= r; i++) {\n                max = Math.max(max, i + nums[i]);\n            }\n            l = r + 1;\n            r = max;\n            count++;\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/jump-game-ii/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '1c473674-fe99-4dd2-91f0-6180ff5b535f',
                  isFolder: false,
                  name: 'MergeIntervals.java',
                  code: 'import java.util.*;\npublic class MergeIntervals {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        int start = intervals[0][0], end = intervals[0][1];\n        List<int[]> list = new ArrayList<>();\n        for (int[] interval : intervals) {\n            if (interval[0] <= end) {\n                end = Math.max(end, interval[1]);\n            } else {\n                list.add(new int[] {start, end});\n                start = interval[0];\n                end = interval[1];\n            }\n        }\n        list.add(new int[] {start, end});\n        return list.toArray(new int[list.size()][]);\n    }\n}',
                  link: 'https://leetcode.com/problems/merge-intervals/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'a7370722-ac2a-49f9-8d93-507563ff5021',
                  isFolder: false,
                  name: 'MinimumPlatforms.java',
                  code: 'import java.util.*;\n\npublic class MinimumPlatforms {\n\n    public static int calculateMinPlatforms(int[] arr, int[] dep, int n) {\n        // Write your code here.\n        Arrays.sort(arr);\n        Arrays.sort(dep);\n        int max = 0, platforms = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            if (arr[i] <= dep[j]) {\n                i++;\n                platforms++;\n            } else {\n                j++;\n                platforms--;\n            }\n            max = Math.max(max, platforms);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {900, 940, 950, 1100, 1500, 1800};\n        int[] dep = {910, 1200, 1120, 1130, 1900, 2000};\n        int ans = calculateMinPlatforms(arr, dep, arr.length);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-number-of-platforms_799400',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'c135aece-4875-4958-986f-cf762953875b',
                  isFolder: false,
                  name: 'NMeetingsInARoom.java',
                  code: 'import java.util.*;\npublic class NMeetingsInARoom {\n    public static class Pair {\n        int start, end;\n        Pair (int s, int e) {\n            this.start = s;\n            this.end = e;\n        }\n    }\n    public static int maxMeetings(int start[], int end[], int n) {\n        // add your code here\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.end - b.end);\n        for (int i = 0; i < n; i++) pq.add(new Pair(start[i], end[i]));\n        int endTime = 0, count = 0;\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            if (p.start > endTime) {\n                count++;\n                endTime = p.end;\n            }\n        }\n        return count;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/maximum-meetings_1062658',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: '76b2d07c-1ef8-43e0-9048-bd1cc42b89d2',
                  isFolder: false,
                  name: 'NonOverlappingIntervals.java',
                  code: 'import java.util.*;\n\npublic class NonOverlappingIntervals {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\n        int count = 0;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.length; i++) {\n            int[] interval = intervals[i];\n            if (end <= interval[0]) {\n                end = interval[1];\n            } else {\n                count++;\n                end = Math.min(end, interval[1]);\n            }\n        }\n        return count;\n    }\n}',
                  link: 'https://leetcode.com/problems/non-overlapping-intervals/',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
                {
                  id: 'f279fb54-cd1d-48ff-aaf2-f224be7362d3',
                  isFolder: false,
                  name: 'SJF.java',
                  code: 'import java.util.*;\n\npublic class SJF {\n    static class Job {\n        int at, bt;\n        Job(int a, int b) {\n            this.at = a;\n            this.bt = b;\n        }\n        @Override\n        public String toString() {\n            return \'{\' + "at=" + at + " bt=" + bt + \'}\';\n        }\n    }\n\n    public static float sjf(int n, int[] arrivalTime, int[] burstTime) {\n        // Write your code here.\n        Job[] jobs = new Job[n];\n        for (int i = 0; i < n; i++) {\n            jobs[i] = new Job(arrivalTime[i], burstTime[i]);\n        }\n        Arrays.sort(jobs, (a, b) -> a.at - b.at);\n        List<Job> list = new ArrayList<>();\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> a.bt - b.bt);\n        int currTime = 0,  i = 0;\n        while (i < n || !pq.isEmpty()) {\n            while (i < n && currTime >= jobs[i].at) pq.add(jobs[i++]);\n            if (pq.isEmpty()) {\n                currTime = jobs[i].at;\n                continue;\n            }\n            Job j = pq.poll();\n            list.add(j);\n            currTime += j.bt;\n        }\n        int xTime = list.get(0).at, ct = 0;\n        for (int j = 0; j < n; j++) {\n            Job job = list.get(j);\n            xTime += ct - job.at;\n            if (ct < job.at)\n                ct = job.at;\n            ct += job.bt;\n        }\n        return (float) xTime / n;\n    }\n\n    public static void main(String[] args) {\n        int[] arrivalTime = {1,1};\n        int[] burstTime = {3,4};\n//        int[] arrivalTime = {0, 5, 26, 0, 17, 13, 6, 2, 24};\n//        int[] burstTime = {22, 15, 21, 11, 14, 10, 27, 18, 24};\n        float ans = sjf(arrivalTime.length, arrivalTime, burstTime);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sjf_1172165',
                  notes: '',
                  tags: ['Medium Hard Problems'],
                },
              ],
            },
            {
              id: 'a108d2e3-14b9-4491-b8d1-0e067f2311e7',
              isFolder: true,
              name: 'Heaps',
              content: [
                {
                  id: '4631576a-4055-4007-8fac-e1e6129e584d',
                  isFolder: false,
                  name: 'ConnectNRopesWithMinCost.java',
                  code: 'import java.util.*;\n\npublic class ConnectNRopesWithMinCost {\n    static int minCost(int[] arr, int n) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i : arr) pq.add(i);\n        int cost = 0;\n        while (pq.size() != 1) {\n            int sum = pq.poll() + pq.poll();\n            cost += sum;\n            pq.add(sum);\n        }\n        return cost;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/connect-n-ropes-with-minimum-cost_625783',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'a0c66b9f-ebbc-43bc-9df6-9c3ff4b27baf',
                  isFolder: false,
                  name: 'DesignTwitter.java',
                  code: "import java.util.*;\n\npublic class DesignTwitter {\n    static class Tweet {\n        int userId;\n        int tweetId;\n        int tweetFrequency;\n\n        Tweet(int uId, int tId, int f) {\n            this.userId = uId;\n            this.tweetId = tId;\n            this.tweetFrequency = f;\n        }\n    }\n\n    static class Twitter {\n\n        HashMap<Integer, HashSet<Integer>> followMap;\n        int frequency = 0;\n        PriorityQueue<Tweet> pq;\n\n        public Twitter() {\n            followMap = new HashMap<>();\n            pq = new PriorityQueue<>((a, b) -> b.tweetFrequency - a.tweetFrequency);\n        }\n\n        public void postTweet(int userId, int tweetId) {\n            pq.add(new Tweet(userId, tweetId, frequency));\n            frequency++;\n        }\n\n        public List<Integer> getNewsFeed(int userId) {\n            Deque<Tweet> q = new ArrayDeque<>();\n            List<Integer> op = new ArrayList<>();\n            int count = 10;\n            while (count > 0 && !pq.isEmpty()) {\n                Tweet t = pq.poll();\n                q.add(t);\n                if (\n                        userId == t.userId ||\n                                (followMap.containsKey(userId) && followMap.get(userId).contains(t.userId))\n                ) {\n                    count--;\n                    op.add(t.tweetId);\n                }\n            }\n            while (!q.isEmpty()) pq.add(q.poll());\n            System.out.println(followMap);\n            return op;\n        }\n\n        public void follow(int followerId, int followeeId) {\n            if (!followMap.containsKey(followerId)) {\n                followMap.put(followerId, new HashSet<>());\n            }\n            followMap.get(followerId).add(followeeId);\n        }\n\n        public void unfollow(int followerId, int followeeId) {\n            if (followMap.containsKey(followerId)) {\n                followMap.get(followerId).remove(followeeId);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Twitter twitter = new Twitter();\n        twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\n        System.out.println(twitter.getNewsFeed(1));  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\n        twitter.follow(1, 2);    // User 1 follows user 2.\n        twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\n        System.out.println(twitter.getNewsFeed(1));  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\n        twitter.unfollow(1, 2);  // User 1 unfollows user 2.\n        System.out.println(twitter.getNewsFeed(1));  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n    }\n}",
                  link: 'https://leetcode.com/problems/design-twitter/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '39e9fe35-8419-4dd3-9b64-b5e3c0b963d5',
                  isFolder: false,
                  name: 'FindMedianFromDataStream.java',
                  code: 'import java.util.*;\n\npublic class FindMedianFromDataStream {\n    static class MedianFinder {\n        PriorityQueue<Integer> maxHeap;\n        PriorityQueue<Integer> minHeap;\n        public MedianFinder() {\n            maxHeap = new PriorityQueue<>((a,b) -> b - a);\n            minHeap = new PriorityQueue<>();\n        }\n\n        public void addNum(int num) {\n            if (num < findMedian()) maxHeap.add(num);\n            else minHeap.add(num);\n            if (minHeap.size() - maxHeap.size() > 1) maxHeap.add(minHeap.poll());\n            else if (maxHeap.size() - minHeap.size() > 1) minHeap.add(maxHeap.poll());\n        }\n\n        public double findMedian() {\n            if (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;\n            if (minHeap.size() == maxHeap.size())\n                return (minHeap.peek() + maxHeap.peek())/2.0;\n            if (minHeap.size() > maxHeap.size())\n                return minHeap.peek();\n            return maxHeap.peek();\n        }\n    }\n\n    public static void main(String[] args) {\n        MedianFinder medianFinder = new MedianFinder();\n        medianFinder.addNum(1);    // arr = [1]\n        medianFinder.addNum(2);    // arr = [1, 2]\n        System.out.println(medianFinder.findMedian()); // return 1.5 (i.e., (1 + 2) / 2)\n        medianFinder.addNum(3);    // arr[1, 2, 3]\n        System.out.println(medianFinder.findMedian()); // return 2.0\n    }\n}',
                  link: 'https://leetcode.com/problems/find-median-from-data-stream/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '42b1ff86-8e85-4f84-9385-105967948822',
                  isFolder: false,
                  name: 'KthLargest.java',
                  code: 'import java.util.*;\n\nclass KthLargest {\n    PriorityQueue<Integer> pq;\n    int size;\n\n    public KthLargest(int k, int[] nums) {\n        pq = new PriorityQueue<>();\n        size = k;\n        for (int num : nums) {\n            pq.add(num);\n            if (pq.size() > k) pq.poll();\n        }\n    }\n\n    public int add(int val) {\n        pq.add(val);\n        if (pq.size() > size) pq.poll();\n        return pq.peek();\n    }\n}',
                  link: 'https://leetcode.com/problems/kth-largest-element-in-a-stream/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '6aaf0ee6-d659-4072-aa25-f7c2928ae835',
                  isFolder: false,
                  name: 'MaximumSumCombination.java',
                  code: '// link: https://practice.geeksforgeeks.org/problems/maximum-sum-combination/1\n\nimport java.util.*;\n\npublic class MaximumSumCombination {\n    static List<Integer> maxCombinations(int N, int c, int a[], int b[]) {\n        List<Integer> al = new ArrayList<Integer>();\n        Arrays.sort(a);\n        Arrays.sort(b);\n        int n = N-1;\n        PriorityQueue<Pair> pq = new PriorityQueue<>((p,q) -> q.v - p.v);\n        pq.add(new Pair(a[n] + b[n], n, n));\n        Set<String> set = new HashSet<>();\n        set.add(n + " " + n);\n\n        while (!pq.isEmpty()) {\n            Pair cur = pq.poll();\n            al.add(cur.v);\n            if (al.size() == c) break;\n            int x = cur.x, y = cur.y;\n            if (x-1 >= 0 && !set.contains((x-1) + " " + y)) {\n                pq.add(new Pair(a[x-1] + b[y], x-1, y));\n                set.add((x-1) + " " + y);\n            }\n            if (y-1 >= 0 && !set.contains(x + " " + (y-1))) {\n                pq.add(new Pair(a[x] + b[y-1], x, y-1));\n                set.add(x + " " + (y-1));\n            }\n        }\n        return al;\n    }\n    static class Pair {\n        int v, x, y;\n        Pair(int v, int x, int y) {\n            this.v = v;\n            this.x = x;\n            this.y = y;\n        }\n        // public int compareTo(Pair p) { return p.v - this.v; }\n    }\n\n    public static void main(String[] args) {\n        int[] A = {9, 9, 10, 6, 1, 6, 4};\n        int[] B = {5, 3, 4, 2, 10, 4, 9};\n        int k = 4;\n        List<Integer> ans = maxCombinations(A.length, k, A, B);\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '879bd29a-7376-48f6-8297-b164509cc9cc',
                  isFolder: false,
                  name: 'TopKFrequentElements.java',
                  code: 'import java.util.*;\n\npublic class TopKFrequentElements {\n    static class Pair {\n        int key, freq;\n        Pair(int k, int f) {\n            this.key = k;\n            this.freq = f;\n        }\n    }\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> a.freq - b.freq);\n        for (Map.Entry<Integer, Integer> m : map.entrySet()) {\n            pq.add(new Pair(m.getKey(), m.getValue()));\n            if (pq.size() > k) pq.poll();\n        }\n        int[] ans = new int[k];\n        for (int i = 0; i < k; i++) {\n            ans[i] = pq.poll().key;\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/top-k-frequent-elements/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '7447ba2f-3f3f-4097-9e7b-9615255ae006',
                  isFolder: false,
                  name: 'MaxHeap.java',
                  code: 'import java.util.*;\n\npublic class MaxHeap {\n    public static void swap(List<Integer> heap, int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n\n    //    MAX HEAP push: SWAP if PARENT < CHILD\n    public static void push(List<Integer> heap, int value) {\n        heap.add(value);\n        int i = heap.size() - 1;\n        while (heap.get((i - 1) / 2) < heap.get(i)) {\n            swap(heap, i, (i - 1) / 2);\n            i = (i - 1) / 2;\n        }\n    }\n\n    public static int pop(List<Integer> heap) {\n        if (heap.isEmpty()) return -1;\n        if (heap.size() == 1) return heap.remove(0);\n        int val = heap.get(0);\n        heap.set(0, heap.get(heap.size() - 1));\n        heap.remove(heap.size() - 1);\n        int i = 0;\n        while (2 * i + 1 < heap.size()) {\n            int lIdx = 2*i + 1;\n            int rIdx = 2*i + 2;\n            int leftChild = heap.get(lIdx);\n            if (rIdx < heap.size() && heap.get(rIdx) >= leftChild && heap.get(rIdx) > heap.get(i)) {\n                swap(heap, rIdx, i);\n                i = rIdx;\n            } else if (leftChild > heap.get(i)) {\n                swap(heap, lIdx, i);\n                i = lIdx;\n            } else break;\n        }\n        return val;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> heap = new ArrayList<>();\n\n        System.out.println(pop(heap));\n        push(heap, 76);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        push(heap, 62);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        push(heap, 58);\n        push(heap, 8);\n        push(heap, 4);\n        push(heap, 52);\n        System.out.println(pop(heap));\n        push(heap, 74);\n        System.out.println(pop(heap));\n        System.out.println(heap);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '9d494638-bd63-4ffc-99c6-420588ba64fc',
                  isFolder: false,
                  name: 'MinHeap.java',
                  code: 'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MinHeap {\n    public static void swap(List<Integer> heap, int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n\n    //    MAX HEAP push: SWAP if PARENT < CHILD\n    public static void push(List<Integer> heap, int value) {\n        heap.add(value);\n        int i = heap.size() - 1;\n        while (heap.get((i - 1) / 2) > heap.get(i)) {\n            swap(heap, i, (i - 1) / 2);\n            i = (i - 1) / 2;\n        }\n    }\n\n    public static void percolateDownMinHeap(List<Integer> heap, int i) {\n        while (2 * i + 1 < heap.size()) {\n            int lIdx = 2*i + 1;\n            int rIdx = 2*i + 2;\n            int leftChild = heap.get(lIdx);\n            if (rIdx < heap.size() && heap.get(rIdx) <= leftChild && heap.get(rIdx) < heap.get(i)) {\n                swap(heap, rIdx, i);\n                i = rIdx;\n            } else if (leftChild < heap.get(i)) {\n                swap(heap, lIdx, i);\n                i = lIdx;\n            } else break;\n        }\n    }\n    public static int pop(List<Integer> heap) {\n        if (heap.isEmpty()) return -1;\n        if (heap.size() == 1) return heap.remove(0);\n        int val = heap.get(0);\n        heap.set(0, heap.get(heap.size() - 1));\n        heap.remove(heap.size() - 1);\n        percolateDownMinHeap(heap, 0);\n        return val;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> heap = new ArrayList<>();\n        push(heap, 50);\n        push(heap, 10);\n        push(heap, 70);\n        push(heap, 20);\n        push(heap, 30);\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(pop(heap));\n        System.out.println(heap);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '6beb44c7-7510-4035-90e9-fa06c9096a7e',
                  isFolder: false,
                  name: 'HandOfStraights.java',
                  code: 'import java.util.*;\n\npublic class HandOfStraights {\n    public static boolean isNStraightHand(int[] hand, int groupSize) {\n        if (hand.length < groupSize || hand.length % groupSize != 0) return false;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int j : hand) hm.put(j, hm.getOrDefault(j, 0) + 1);\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (Map.Entry<Integer, Integer> m : hm.entrySet()) pq.add(m.getKey());\n\n        while (!pq.isEmpty()) {\n            int first = pq.peek();\n            for (int i = first; i < first + groupSize; i++) {\n                if (hm.containsKey(i)) {\n                    int count = hm.get(i) - 1;\n                    hm.put(i, count);\n                    if (count == 0) {\n                        if (i != pq.peek()) return false;\n                        pq.poll();\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] hand = {1,2,3,6,2,3,4,7,8};\n        int groupSize = 3;\n        System.out.println(isNStraightHand(hand, groupSize));\n\n    }\n}',
                  link: 'https://leetcode.com/problems/hand-of-straights/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'd45abc52-a248-4264-bf12-ea6a476cde0f',
                  isFolder: false,
                  name: 'KthLargestElement.java',
                  code: 'import java.util.*;\npublic class KthLargestElement {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int num : nums) {\n            pq.add(num);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        return pq.poll();\n    }\n}',
                  link: 'https://leetcode.com/problems/kth-largest-element-in-an-array/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '028768a3-b6f4-4414-acee-5dc0d0d0a246',
                  isFolder: false,
                  name: 'KthSmallestElement.java',
                  code: 'import java.util.*;\npublic class KthSmallestElement {\n    public static int kthSmallest(int[] arr, int l, int r, int k) {\n        //Your code here\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for (int i = l; i <= r; i++) {\n            pq.add(arr[i]);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        return pq.poll();\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'a5f6edb4-ed09-4663-abb0-5abe9b24bd47',
                  isFolder: false,
                  name: 'MergeKElements.java',
                  code: 'public class MergeKElements {\n    public static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n    public ListNode merge(ListNode a, ListNode b) {\n        ListNode temp = new ListNode(0);\n        ListNode curr = temp;\n        while (a != null && b != null) {\n            if (a.val <= b.val) {\n                curr.next = a;\n                a = a.next;\n            } else {\n                curr.next = b;\n                b = b.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = a != null ? a : b;\n        return temp.next;\n    }\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += 2*interval)\n                lists[i] = merge(lists[i], lists[i + interval]);\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
                  link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'da4e96bc-3e64-449a-93d9-674e70e0f0d6',
                  isFolder: false,
                  name: 'MergeKSortedLists.java',
                  code: 'public class MergeKSortedLists {\n     public class ListNode {\n         int val;\n         ListNode next;\n\n         ListNode() {\n         }\n\n         ListNode(int val) {\n             this.val = val;\n         }\n\n         ListNode(int val, ListNode next) {\n             this.val = val;\n             this.next = next;\n         }\n     }\n    public ListNode merge(ListNode a, ListNode b) {\n        ListNode temp = new ListNode(0);\n        ListNode curr = temp;\n        while (a != null && b != null) {\n            if (a.val <= b.val) {\n                curr.next = a;\n                a = a.next;\n            } else {\n                curr.next = b;\n                b = b.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = a != null ? a : b;\n        return temp.next;\n    }\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += 2*interval)\n                lists[i] = merge(lists[i], lists[i + interval]);\n            interval *= 2;\n        }\n        return size > 0 ? lists[0] : null;\n    }\n}',
                  link: 'https://leetcode.com/problems/merge-k-sorted-lists/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '4aab5a03-81c7-4bef-9e57-34b0103b9ff7',
                  isFolder: false,
                  name: 'NearlySorted.java',
                  code: 'import java.util.*;\npublic class NearlySorted {\n    public static int[] nearlySorted(int[] arr, int n, int k) {\n        // Write your code here.\n        int[] ans = new int[n];\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        int idx = 0;\n        for (int i = 0; i < arr.length; i++) {\n            pq.add(arr[i]);\n            if (pq.size() > k) {\n                ans[idx++] = pq.poll();\n            }\n        }\n        while (!pq.isEmpty()) {\n            ans[idx++] = pq.poll();\n        }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/nearly-sorted_982937',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '2d1e0dbb-be1d-40c3-987f-57c61b03033a',
                  isFolder: false,
                  name: 'ReplaceEachElementWithItsRank.java',
                  code: 'import java.util.*;\npublic class ReplaceEachElementWithItsRank {\n    public static List<Integer> replaceWithRank(List<Integer> arr, int n) {\n        // Write your code here\n        List<Integer> ans = new ArrayList<>(arr);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        Collections.sort(arr);\n        int rank = 1;\n        for (int element : arr)\n            if (!map.containsKey(element)) map.put(element, rank++);\n        for (int i = 0; i < arr.size(); i++)\n            ans.set(i, map.get(ans.get(i)));\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/replace-each-element-of-array-with-its-corresponding-rank_975384',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'd06557b0-3d49-4994-98ac-0eb5a45b12cd',
                  isFolder: false,
                  name: 'TaskScheduler.java',
                  code: "import java.util.*;\n\npublic class TaskScheduler {\n    static class Pair {\n        int val, time;\n        Pair(int v, int t) {\n            this.val = v;\n            this.time = t;\n        }\n    }\n    public static int leastInterval(char[] tasks, int n) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int task : tasks)\n            hm.put(task, hm.getOrDefault(task, 0) + 1);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        for (Map.Entry<Integer, Integer> m: hm.entrySet())\n            pq.add(m.getValue());\n        Queue<Pair> q = new LinkedList<>();\n        int time = 0;\n        while (!pq.isEmpty() || !q.isEmpty()) {\n            time++;\n            if (!pq.isEmpty()) {\n                int val = pq.poll() - 1;\n                if (val > 0) q.add(new Pair(val, time + n));\n            }\n            if (!q.isEmpty() && q.peek().time <= time)\n                pq.add(q.poll().val);\n        }\n        return time;\n\n    }\n\n    public static void main(String[] args) {\n        char[] tasks = {'A', 'A', 'A', 'B', 'B', 'B'};\n        int n = 2;\n        int ans = leastInterval(tasks, n);\n        System.out.println(ans);\n    }\n}",
                  link: 'https://leetcode.com/problems/task-scheduler/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
              ],
            },
            {
              id: '13878baa-c4ad-488c-9fd0-480db6ff445d',
              isFolder: true,
              name: 'LinkedList',
              content: [
                {
                  id: '442bfaf3-c722-41cf-a095-08de9e93d078',
                  isFolder: false,
                  name: 'CopyListWithRandomPointer.java',
                  code: 'public class CopyListWithRandomPointer {\n    class Node {\n        int val;\n        Node next;\n        Node random;\n        public Node(int val) {\n            this.val = val;\n            this.next = null;\n            this.random = null;\n        }\n    }\n    public Node copyRandomList(Node head) {\n        // Optimised solution\n        if (head == null) return null;\n        // Step 1: Create a new linked list in between the nodes of current LL\n        Node curr = head;\n        while (curr != null) {\n            Node newNode = new Node(curr.val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            curr = newNode.next;\n        }\n        // Step 2: Assign random pointers to the deep copy\n        curr = head;\n        while (curr != null) {\n            if (curr.random != null)\n                curr.next.random = curr.random.next;\n            curr = curr.next.next;\n        }\n        // Step 3: Separate both the linked list and return Head\n        Node copy = head.next;\n        Node temp = copy;\n        curr = head;\n        while (temp != null) {\n            curr.next = temp.next;\n            curr = curr.next;\n            if (curr == null) break;\n            temp.next = curr.next;\n            temp = temp.next;\n        }\n        // curr.next = null;\n        return copy;\n    }\n}',
                  link: 'https://leetcode.com/problems/copy-list-with-random-pointer',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: 'e46249b0-0e99-4458-a2a8-4609f28854bb',
                  isFolder: false,
                  name: 'FlattenLL.java',
                  code: 'public class FlattenLL {\n    public class Node {\n        public int data;\n        public Node next;\n        public Node child;\n\n        Node()\n        {\n            this.data = 0;\n            this.next = null;\n            this.child = null;\n        }\n        Node(int data)\n        {\n            this.data = data;\n            this.next = null;\n            this.child = null;\n        }\n        Node(int data, Node next, Node child)\n        {\n            this.data = data;\n            this.next = next;\n            this.child = child;\n        }\n    }\n\n    public static Node merge(Node left, Node right) {\n        Node temp = new Node(0);\n        Node tHead = temp;\n        while (left != null && right != null) {\n            if (left.data <= right.data) {\n                temp.child = left;\n                left = left.child;\n            } else {\n                temp.child = right;\n                right = right.child;\n            }\n            temp = temp.child;\n        }\n        if (left != null)\n            temp.child = left;\n        else\n            temp.child = right;\n        return tHead.child;\n    }\n    public static Node flatList(Node head) {\n        if (head == null || head.next == null) return head;\n        head.next = flatList(head.next);\n        head = merge(head, head.next);\n        return head;\n    }\n    public static Node flattenLinkedList(Node head) {\n        //Write your code here\n        return flatList(head);\n    }\n\n}',
                  link: 'https://www.codingninjas.com/studio/problems/flatten-a-linked-list_1112655',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '89eb8504-62b2-45e1-8717-61ded257700e',
                  isFolder: false,
                  name: 'ReverseNodesInKGroups.java',
                  code: 'public class ReverseNodesInKGroups {\n    public static ListNode revLL(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = head;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode curr = head, start = head, prev = head;\n        ListNode newHead = new ListNode(0, head);\n        ListNode temp = newHead;\n\n        while (curr != null) {\n            for (int i = 1; i <= k; i++) {\n                if (curr.next == null && i < k) return newHead.next;\n                prev = curr;\n                curr = curr.next;\n            }\n            prev.next = null;\n            temp.next = revLL(start);\n            start.next = curr;\n            temp = start;\n            start = curr;\n        }\n        return newHead.next;\n    }\n}',
                  link: 'https://leetcode.com/problems/reverse-nodes-in-k-group/',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: 'ed730966-da1c-40c5-98de-ee0406b5b91b',
                  isFolder: false,
                  name: 'RotateList.java',
                  code: 'public class RotateList {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        int length = 1;\n        ListNode end = head;\n        while (end.next != null) {\n            length++;\n            end = end.next;\n        }\n        k = k%length;\n        if (k == 0) return head;\n        ListNode prev = null;\n        ListNode start = head;\n        for (int i = 0; i <length - k; i++) {\n            prev = start;\n            start = start.next;\n        }\n        prev.next = null;\n        end.next = head;\n        head = start;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/rotate-list/',
                  notes: '',
                  tags: ['Hard Problems of LL'],
                },
                {
                  id: '3eb7015e-121e-4288-b5a8-7a57679ef353',
                  isFolder: false,
                  name: 'AddOneToNumberLL.java',
                  code: 'public class AddOneToNumberLL {\n    public static Node revLL(Node head) {\n\t\tNode prev = null;\n\t\tNode curr = head, next = head;\n\t\twhile (curr != null) {\n\t\t\tnext = curr.next;\n\t\t\tcurr.next = prev;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\treturn prev;\n\t}\n\n\tpublic static Node addNode(Node head) {\n\t\t// Write your code here.\n\t\thead = revLL(head);\n\t\tNode curr = head;\n\t\tint carry = 1;\n\t\twhile (curr.next != null) {\n\t\t\tcarry = curr.data + carry;\n\t\t\tcurr.data = carry % 10;\n\t\t\tcarry = carry / 10;\n\t\t\tif (carry == 0) break;\n\t\t\tcurr = curr.next;\n\t\t}\n\t\tif (carry != 0) {\n\t\t\tcurr.next = new Node(carry);\n\t\t}\n\t\thead = revLL(head);\n\t\treturn head;\n\t}\n}',
                  link: 'https://www.codingninjas.com/studio/problems/add-one-to-a-number-represented-as-linked-list_920557',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'e4060e91-fa22-4813-ad69-2b6ef0d04ace',
                  isFolder: false,
                  name: 'AddTwoNumbersLL.java',
                  code: 'public class AddTwoNumbersLL {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode sum = new ListNode(0);\n        ListNode sumHead = sum;\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int d1 = l1 != null ? l1.val : 0;\n            int d2 = l2 != null ? l2.val : 0;\n            carry += d1 + d2;\n            sum.next = new ListNode(carry%10);\n            sum = sum.next;\n            carry /= 10;\n            l1 = l1 != null ? l1.next : null;\n            l2 = l2 != null ? l2.next : null;\n        }\n        return sumHead.next;\n    }\n}',
                  link: 'https://leetcode.com/problems/add-two-numbers/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '7f04931f-c0a6-4c42-bdd3-604c9b87bee2',
                  isFolder: false,
                  name: 'DeleteMiddleNode.java',
                  code: 'public class DeleteMiddleNode {\n    public ListNode deleteMiddle(ListNode head) {\n        if (head.next == null) return null;\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = slow.next;\n        slow.next = null;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '27d06071-4ba8-454c-92e6-5266a7a65960',
                  isFolder: false,
                  name: 'IntersectionOfTwoLinkedLists.java',
                  code: 'public class IntersectionOfTwoLinkedLists {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode d1 = headA;\n        ListNode d2 = headB;\n        while (d1 != d2) {\n            d1 = d1 == null ? headB : d1.next;\n            d2 = d2 == null ? headA : d2.next;\n        }\n        return d1;\n    }\n}',
                  link: 'https://leetcode.com/problems/intersection-of-two-linked-lists/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'debd6d1c-f7f4-4f60-a264-7e9979768dfc',
                  isFolder: false,
                  name: 'LengthOfLoopInLL.java',
                  code: 'public class LengthOfLoopInLL {\n\n    public static int lengthOfLoop(Node head) {\n        // Write your code here\n        if (head == null || head.next == null) {\n            return 0;\n        }\n        int len = 1;\n        Node s = head, f = head, s2 = head;\n        while (f != null && f.next != null) {\n            s = s.next;\n            f = f.next.next;\n            if (f == s) {\n                while (s != s2) {\n                    s = s.next;\n                    s2 = s2.next;\n                }\n                s = s.next;\n                while (s != s2) {\n                    s = s.next;\n                    len++;\n                }\n            }\n        }\n        return len;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-length-of-loop_8160455',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '653d164d-f674-4d7a-b317-0bde46d68c63',
                  isFolder: false,
                  name: 'ListNode.java',
                  code: 'public class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '65b109de-1eff-4c36-8e50-b1713407261c',
                  isFolder: false,
                  name: 'Node.java',
                  code: 'public class Node {\n    public int data;\n    public Node next;\n\n    Node() {\n        this.data = 0;\n        this.next = null;\n    }\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    Node(int data, Node next) {\n        this.data = data;\n        this.next = next;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '8021be78-848b-464b-b016-2785ab8e7125',
                  isFolder: false,
                  name: 'OddEvenLinkedList.java',
                  code: 'public class OddEvenLinkedList {\n    public static ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenhead = even;\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        odd.next = evenhead;\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/odd-even-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '6e4de10c-4867-442a-9eab-0476d7024caa',
                  isFolder: false,
                  name: 'PalindromeLinkedList.java',
                  code: '// Definition for singly-linked list.\nclass PalindromeLinkedList {\n    public static ListNode revLL(ListNode head) {\n        ListNode curr = head, prev = null, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n        ListNode slow = head, curr = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        slow = revLL(slow);\n        while (slow != null) {\n            if (slow.val != curr.val) return false;\n            slow = slow.next;\n            curr = curr.next;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println("Hello");\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-linked-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '93100229-055d-4bbf-a957-037aa0bff205',
                  isFolder: false,
                  name: 'RemoveNthNodeFromLastOfLL.java',
                  code: 'public class RemoveNthNodeFromLastOfLL {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode curr = head;\n        int l = 1;\n        while (curr.next != null) {\n            curr = curr.next;\n            l++;\n        }\n        int len = l - n;\n        if (len == 0) {\n            head = head.next;\n        } else {\n            curr = head;\n            while (len != 1) {\n                len--;\n                curr = curr.next;\n            }\n            curr.next = curr.next.next;\n        }\n        return head;\n    }\n}',
                  link: 'https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'a6c848ce-41ff-4270-b441-70fe8e7904df',
                  isFolder: false,
                  name: 'Sort012LinkedList.java',
                  code: 'public class Sort012LinkedList {\n    public static Node sortList(Node head) {\n        // Write your code here\n        Node zeroHead = new Node(0), onesHead = new Node(0), twosHead = new Node(0);\n        Node zero = zeroHead, ones = onesHead, twos = twosHead;\n        Node curr = head;\n        while (curr != null) {\n            if (curr.data == 0) {\n                zero.next = curr;\n                zero = zero.next;\n            } else if (curr.data == 1) {\n                ones.next = curr;\n                ones = ones.next;\n            } else {\n                twos.next = curr;\n                twos = twos.next;\n            }\n            curr = curr.next;\n        }\n        twos.next = null;\n        ones.next = twosHead.next;\n        zero.next = onesHead.next;\n        return zeroHead.next;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sort-linked-list-of-0s-1s-2s_1071937',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: '9593ab38-9421-4457-a58d-189a6cd9dab0',
                  isFolder: false,
                  name: 'SortLinkedList.java',
                  code: 'public class SortLinkedList {\n    public static ListNode merge(ListNode left, ListNode right) {\n        ListNode temp = new ListNode(0);\n        ListNode tHead = temp;\n        while (left != null && right != null) {\n            if (left.val <= right.val) {\n                temp.next = left;\n                left = left.next;\n            } else {\n                temp.next = right;\n                right = right.next;\n            }\n            temp = temp.next;\n        }\n        if (left != null)\n            temp.next = left;\n        else\n            temp.next = right;\n        return tHead.next;\n    }\n\n    public static ListNode mergeSort(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode s = head, f = head.next;\n        while (f != null && f.next != null) {\n            s = s.next;\n            f = f.next.next;\n        }\n        ListNode head2 = s.next;\n        s.next = null;\n        head = mergeSort(head);\n        head2 = mergeSort(head2);\n        return merge(head, head2);\n    }\n    public ListNode sortList(ListNode head) {\n        return mergeSort(head);\n    }\n}',
                  link: 'https://leetcode.com/problems/sort-list/',
                  notes: '',
                  tags: ['Medium Problem of LL'],
                },
                {
                  id: 'f2afd98c-f613-40e8-ae14-b432c18334fb',
                  isFolder: false,
                  name: 'DeleteAllCommonOccurances.java',
                  code: 'public class DeleteAllCommonOccurances {\n    public static Node deleteAllOccurrences(Node head, int k) {\n        // Write your code here.\n        while (head != null && head.data == k) {\n            head = head.next;\n        }\n        if (head == null) return null;\n        Node start = head, curr = head.next;\n        while (curr != null) {\n            if (curr.data != k) {\n                start.next = curr;\n                curr.prev = start;\n                start = curr;\n            }\n            curr = curr.next;\n        }\n        start.next = null;\n        return head;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/delete-all-occurrences-of-a-given-key-in-a-doubly-linked-list_8160461',
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: '80509e4d-de8f-4ea2-b7b6-efdd3cfa2d50',
                  isFolder: false,
                  name: 'Node.java',
                  code: 'public class Node {\n    public int data;\n    public Node next;\n    public Node prev;\n\n    Node() {\n        this.data = 0;\n        this.next = null;\n        this.prev = null;\n    }\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n    }\n\n    Node(int data, Node next, Node prev) {\n        this.data = data;\n        this.next = next;\n        this.prev = prev;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: '38a44ca3-bcf7-4d81-b0ea-c38184bcccd4',
                  isFolder: false,
                  name: 'PairWithGivenSum.java',
                  code: 'import java.util.*;\n\npublic class PairWithGivenSum {\n    public static List<List<Integer>> findPairs (Node head, int k) {\n        Node start = head, end = head;\n        while (end.next != null && end.data + start.data <= k) {\n            end = end.next;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n        while (start != null && end != null && start.data < end.data) {\n            int s = start.data + end.data;\n            if (s > k)\n                end = end.prev;\n            else if (s < k)\n                start = start.next;\n            else {\n                output.add(new ArrayList<>(Arrays.asList(start.data, end.data)));\n                start = start.next;\n                end = end.prev;\n            }\n        }\n        return output;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/find-pairs-with-given-sum-in-doubly-linked-list_1164172',
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
                {
                  id: '5bc2efdf-0ab2-4e63-90b4-ff79c8906dcd',
                  isFolder: false,
                  name: 'RemoveDuplicatesSortedDLL.java',
                  code: '//  Link: https://www.codingninjas.com/studio/problems/remove-duplicates-from-a-sorted-doubly-linked-list_2420283\n\npublic class RemoveDuplicatesSortedDLL {\n    public static Node uniqueSortedList(Node head) {\n        // Write your code here.\n        if (head == null || head.next == null) return head;\n        Node start = head;\n        Node curr = head.next;\n        while (curr != null) {\n            if (start.data != curr.data) {\n                start.next = curr;\n                start = start.next;\n            }\n            curr = curr.next;\n        }\n        start.next = null;\n        return head;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Medium Problems of DLL'],
                },
              ],
            },
            {
              id: '7dfb3a0e-018f-4b1c-9ab6-88611c6fc73e',
              isFolder: false,
              name: 'Patterns.java',
              code: '// !ignore\nimport java.util.Scanner;\n\npublic class Patterns {\n    public static void printBlockPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printTriangleNumberPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(j + 1);\n            System.out.println();\n        }\n    }\n\n    public static void printTriangleNumberPattern2(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(i + 1);\n            System.out.println();\n        }\n    }\n\n    public static void printDownTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = n; j > i; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDownTriangleNumberPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++)\n                System.out.print(j + 1 - i);\n            System.out.println();\n        }\n    }\n\n    public static void printEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i - 1; j++)\n                System.out.print(" ");\n            for (int j = 0; j < 2 * i + 1; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDownEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++)\n                System.out.print(" ");\n            for (int j = 0; j < 2 * (n - i) - 1; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printDiamondPattern(int n) {\n        printEQTrianglePattern(n);\n        printDownEQTrianglePattern(n);\n    }\n\n    public static void printHalfDiamondPattern(int n) {\n        printTrianglePattern(n);\n        printDownTrianglePattern(n - 1);\n    }\n\n    public static void print01TrianglePattern(int n) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                System.out.print((i + j) % 2 == 0 ? 1 : 0);\n            }\n            System.out.println();\n        }\n    }\n\n    public static void printHalfButterflyNumberPattern(int n) {\n        for (int i = 1; i <= n; i++) {\n//            Num\n            for (int j = 1; j <= i; j++)\n                System.out.print(j + " ");\n//            Space\n            for (int k = 0; k < (n - i) * 2; k++)\n                System.out.print("  ");\n//            Num\n            for (int j = i; j > 0; j--)\n                System.out.print(j + " ");\n            System.out.println();\n        }\n    }\n\n    public static void printNumberTrianglePattern(int n) {\n        int start = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print(start++ + " ");\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (j + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printDownAlphabetTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i; j++)\n                System.out.print((char) (j + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetTrianglePattern2(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (i + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetEQTrianglePattern(int n) {\n        for (int i = 0; i < n; i++) {\n//            Space\n            for (int j = n; j > i; j--) {\n                System.out.print(" ");\n            }\n//            Num\n            for (int j = 0; j <= i; j++)\n                System.out.print((char) (j + 65));\n//            Num\n            for (int j = i; j > 0; j--)\n                System.out.print((char) (j + 64));\n            System.out.println();\n        }\n    }\n\n    public static void printAlphabetReverseTrianglePattern(int n) {\n        for (int i = n; i > 0; i--) {\n//            Num\n            for (int j = n - i; j >= 0; j--)\n                System.out.print((char) (n - j - 1 + 65));\n            System.out.println();\n        }\n    }\n\n    public static void printInnerDiamondPattern(int n) {\n        for (int i = n; i > 0; i--) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < n - i; j++)\n                System.out.print("  ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < n - i; j++)\n                System.out.print("  ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printButterflyPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            for (int j = 0; j < n - i - 1; j++)\n                System.out.print("  ");\n            for (int j = 0; j <= i; j++)\n                System.out.print("*");\n            System.out.println();\n        }\n        for (int i = n - 1; i > 0; i--) {\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            for (int j = 0; j < 2 * (n - i); j++)\n                System.out.print(" ");\n            for (int j = i; j > 0; j--)\n                System.out.print("*");\n            System.out.println();\n        }\n    }\n\n    public static void printEmptyRectPattern(int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || i == n - 1 || j == 0 || j == n-1) {\n                    System.out.print("*");\n                } else {\n                    System.out.print(" ");\n                }\n            }\n            System.out.println();\n        }\n    }\n    public static void printNumberRectPattern(int n) {\n        for (int i = 0; i < 2*n -1; i++) {\n            for (int j = 0;  j < 2*n -1; j++) {\n                int down = 2*n -2 - i;\n                int right = 2*n -2 - j;\n                System.out.print(n - Math.min(Math.min(i, down), Math.min(j, right)));\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n//        printBlockPattern(n);\n//        printTrianglePattern(n);\n//        printTriangleNumberPattern(n);\n//        printTriangleNumberPattern2(n);\n//        printDownTrianglePattern(n);\n//        printDownTriangleNumberPattern(n);\n//        printEQTrianglePattern(n);\n//        printDownEQTrianglePattern(n);\n//        printDiamondPattern(n);\n//        printHalfDiamondPattern(n);\n//        print01TrianglePattern(n);\n//        printHalfButterflyNumberPattern(n);\n//        printNumberTrianglePattern(n);\n//        printAlphabetTrianglePattern(n);\n//        printDownAlphabetTrianglePattern(n);\n//        printAlphabetTrianglePattern2(n);\n//        printAlphabetEQTrianglePattern(n);\n//        printAlphabetReverseTrianglePattern(n);\n//        printInnerDiamondPattern(n);\n//        printButterflyPattern(n);\n        printEmptyRectPattern(n);\n//        printNumberRectPattern(n);\n        sc.close();\n    }\n}',
              link: null,
              notes: '',
              tags: ['Pattern'],
            },
            {
              id: 'b8607728-fa32-41e2-af35-144ab25122f2',
              isFolder: true,
              name: 'Recursion',
              content: [
                {
                  id: '828b8973-68ce-40fd-9273-22c733a675a6',
                  isFolder: false,
                  name: 'CountGoodNumbers.java',
                  code: 'public class CountGoodNumbers {\n    public static long power(long num, long n) {\n        if (n == 0) return 1;\n        if (n == 1) return num;\n        long r = power(num, n/2);\n        if (n%2 == 0) return (r*r)%1000000007;\n        return (r*r*num)%1000000007;\n    }\n    public int countGoodNumbers(long n) {\n        long primePower = power(4, n/2);\n        long evenPower = power(5, n/2);\n        if (n%2 == 1)\n            evenPower *= 5;\n        return (int)((evenPower * primePower)%1000000007);\n    }\n}',
                  link: 'https://leetcode.com/problems/count-good-numbers/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '7fd5dace-7581-44e8-adb0-9d00477ab27d',
                  isFolder: false,
                  name: 'Pow.java',
                  code: 'public class Pow {\n    public static double fastExpo(double x, int n) {\n        if (n == 0) return 1;\n        if (n == 1) return x;\n        double r = fastExpo(x, n/2);\n        return n%2 == 0 ? r*r : r*x*r;\n    }\n    public double myPow(double x, int n) {\n        // if (n == 0) return 1;\n        // double ans = x;\n        // for (int i = 2; i <= Math.abs(n); i++)\n        //     ans = ans * x;\n        // if (n < 0) {\n        //     ans = 1/ans;\n        // }\n        // return ans;\n        boolean isNegative = n < 0;\n        n = Math.abs(n);\n        double fast = fastExpo(x, n);\n        return isNegative ? 1/fast : fast;\n    }\n}',
                  link: 'https://leetcode.com/problems/powx-n/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '5feb1199-775f-47a4-80a4-7813940031c4',
                  isFolder: false,
                  name: 'RecursiveATOI.java',
                  code: "public class RecursiveATOI {\n    public static int solve(char[] arr, int i, double num, boolean isNegative, boolean signed) {\n        if (i >= arr.length || signed && ((arr[i] == '+' || arr[i] == '-') || !Character.isDigit(arr[i]))) {\n            num = isNegative ? -num : num;\n            if (num > Integer.MAX_VALUE)\n                num = Integer.MAX_VALUE;\n            else if (num < Integer.MIN_VALUE)\n                num = Integer.MIN_VALUE;\n            return (int) num;\n        }\n        if (arr[i] == '+' || arr[i] == '-') {\n            isNegative = arr[i] == '-';\n            signed = true;\n        } else if (arr[i] - '0' >= 0 && arr[i] - '0' <= 9) {\n            num = num * 10 + (arr[i] - '0');\n            signed = true;\n        } else if (Character.isDigit(arr[i]) && arr[i] != ' ') {\n            i = arr.length;\n        }\n        i++;\n        return solve(arr, i, num, isNegative, signed);\n    }\n\n    public static int myAtoi(String s) {\n        char[] arr = s.toCharArray();\n        return solve(arr, 0, 0, false, false);\n    }\n\n    public static void main(String[] args) {\n        String s = \"  -0012a42\";\n        System.out.println(myAtoi(s));\n    }\n}",
                  link: 'https://leetcode.com/problems/string-to-integer-atoi/',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '0dd18922-193d-4644-8065-67fd2080d8a7',
                  isFolder: false,
                  name: 'ReverseStack.java',
                  code: 'import java.util.Stack;\n\npublic class ReverseStack {\n    public static void insertElement(int element, Stack<Integer> s) {\n        if (s.isEmpty()) {\n            s.push(element);\n        } else {\n            int top = s.pop();\n            insertElement(element, s);\n            s.push(top);\n        }\n    }\n    public static void reverseStack(Stack<Integer> s) {\n        if (s.isEmpty()) return;\n        int element = s.pop();\n        reverseStack(s);\n        insertElement(element, s);\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> s = new Stack<>();\n        s.push(30);\n        s.push(-5);\n        s.push(18);\n        s.push(14);\n        s.push(-3);\n\n        System.out.println("Stack elements before sorting: ");\n        SortStack.printStack(s);\n        reverseStack(s);\n        System.out.println(" \\n\\nStack elements after sorting:");\n        SortStack.printStack(s);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/reverse-stack-using-recursion_631875',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: '0cad52d1-685f-4125-a84f-f2d9de08ad6c',
                  isFolder: false,
                  name: 'SortStack.java',
                  code: 'import java.util.*;\n\npublic class SortStack {\n    static void insertElement(int element, Stack<Integer> s) {\n        if (s.isEmpty() || s.peek() <= element) {\n            s.push(element);\n        } else {\n            int top = s.pop();\n            insertElement(element, s);\n            s.push(top);\n        }\n    }\n\n    static void sortStack(Stack<Integer> s) {\n        if (s.isEmpty()) return;\n        int element = s.pop();\n        sortStack(s);\n        insertElement(element, s);\n    }\n\n    // Utility Method to print contents of stack\n    static void printStack(Stack<Integer> s) {\n        ListIterator<Integer> lt = s.listIterator();\n        // forwarding\n        while (lt.hasNext())\n            lt.next();\n        // printing from top to bottom\n        while (lt.hasPrevious())\n            System.out.print(lt.previous() + " ");\n    }\n\n    public static void main(String[] args) {\n        Stack<Integer> s = new Stack<>();\n        s.push(30);\n        s.push(-5);\n        s.push(18);\n        s.push(14);\n        s.push(-3);\n\n        System.out.println("Stack elements before sorting: ");\n        printStack(s);\n        sortStack(s);\n        System.out.println(" \\n\\nStack elements after sorting:");\n        printStack(s);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/sort-stack_1229505',
                  notes: '',
                  tags: ['Get a Strong Hold'],
                },
                {
                  id: 'db9020ce-82c7-410c-866a-f727251d597c',
                  isFolder: false,
                  name: 'CombinationSum.java',
                  code: 'import java.util.*;\n\npublic class CombinationSum {\n    public static void solve(int[] arr, int target, List<List<Integer>> ans, List<Integer> temp, int idx) {\n        if (arr.length == idx) {\n            if (target == 0) ans.add(new ArrayList<>(temp));\n            return;\n        }\n        if (arr[idx] <= target) {\n            temp.add(arr[idx]);\n            solve(arr, target - arr[idx], ans, temp, idx);\n            temp.remove(temp.size() - 1);\n        }\n        solve(arr, target, ans, temp, idx + 1);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {13,3,2,17};\n        int target = 14;\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(arr, target, ans, new ArrayList<>(), 0);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'fa57f8ca-ee29-4f51-813a-f11b499140a4',
                  isFolder: false,
                  name: 'CombinationSum2.java',
                  code: 'import java.util.*;\npublic class CombinationSum2 {\n    public static void solve(int[] arr, int k, int sum, int idx, HashSet<List<Integer>> hs, List<Integer> temp) {\n        if (sum > k || arr.length == idx) return;\n        if (sum == k) {\n            List<Integer> list = new ArrayList<>(temp);\n            Collections.sort(list);\n            hs.add(list);\n            return;\n        }\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i] == arr[i-1]) continue;\n            if (arr[i] > k) return;\n            temp.add(arr[i]);\n            solve(arr, k, sum + arr[i], idx + 1, hs, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public static List<List<Integer>> combinationSum2(int[] arr, int target) {\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n        HashSet<List<Integer>> hs = new HashSet<>();\n        solve(arr, target, 0, 0, hs, new ArrayList<>());\n        return new ArrayList<>(hs);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10,1,2,7,6,1,5};\n        int target = 8;\n        System.out.println(combinationSum2(arr, target));\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum-ii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'aab1d143-4acc-402d-be66-89692a910cd2',
                  isFolder: false,
                  name: 'CombinationSum3.java',
                  code: 'import java.util.*;\n\npublic class CombinationSum3 {\n    public static void solve(int k, int n, HashSet<Integer> hs, List<List<Integer>> ans, List<Integer> temp, int idx,\n            HashSet<List<Integer>> ansHs) {\n        if (n < 0)\n            return;\n        if (n == 0) {\n            if (temp.size() == k)\n                ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i <= 9; i++) {\n            if (i > n)\n                return;\n            temp.add(i);\n            solve(k, n - i, hs, ans, temp, i + 1, ansHs);\n            temp.remove(temp.size() - 1);\n        }\n    }\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> ans = new ArrayList<>();\n        HashSet<Integer> hs = new HashSet<>();\n        solve(k, n, hs, ans, new ArrayList<>(), 1, new HashSet<>());\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/combination-sum-iii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'c26f40e9-d7d5-411a-99a4-06d35df9d477',
                  isFolder: false,
                  name: 'GenerateAllBinaryStrings.java',
                  code: 'import java.util.*;\n\npublic class GenerateAllBinaryStrings {\n    public static void getAllStrings(int n, List<String> ans, StringBuilder sb, boolean hadOne) {\n        if (n == 0) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (hadOne) {\n            sb.append(0);\n            getAllStrings(n - 1, ans, sb, false);\n            sb.deleteCharAt(sb.length() - 1);\n        } else {\n            sb.append(0);\n            getAllStrings(n - 1, ans, sb, false);\n            sb.deleteCharAt(sb.length() - 1);\n            sb.append(1);\n            getAllStrings(n - 1, ans, sb, true);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n\n    public static List<String> generateString(int n) {\n        // Write your code here.\n        List<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        getAllStrings(n, ans, sb, false);\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        List<String> ans = generateString(n);\n        System.out.println(ans);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/-binary-strings-with-no-consecutive-1s._893001',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '286645c6-8420-45b6-9538-179ac300ea22',
                  isFolder: false,
                  name: 'GenerateParentheses.java',
                  code: 'import java.util.*;\n\npublic class GenerateParentheses {\n    public static void solve(int n, List<String> ans, StringBuilder sb, int closeCount, int openCount) {\n        if (openCount == n && closeCount == n) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (openCount < n) {\n            sb.append("(");\n            solve(n, ans, sb, closeCount, openCount + 1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        if (closeCount < openCount) {\n            sb.append(")");\n            solve(n, ans, sb, closeCount + 1, openCount);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n    public static List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        solve(n, ans, sb, 0, 0);\n        return ans;\n    }\n    public static void main(String[] args) {\n        int n = 3;\n        System.out.println(generateParenthesis(n));\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/generate-all-parenthesis_920445',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '2a292165-88b8-4220-aad0-e5e60bf55f87',
                  isFolder: false,
                  name: 'MoreSubsequences.java',
                  code: '// Link: https://www.codingninjas.com/studio/problems/more-subsequence_8842355\nimport java.util.*;\npublic class MoreSubsequences {\n    public static void solve(String s, StringBuilder sb, HashSet<String> ans, int idx) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        solve(s, sb, ans, idx + 1);\n\n        sb.append(s.charAt(idx));\n        solve(s, sb, ans, idx + 1);\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    public static int generateSubsequences(String s) {\n        // Write your code here\n        HashSet<String> ans = new HashSet<>();\n        solve(s, new StringBuilder(), ans, 0);\n        return ans.size();\n    }\n\n    public static String moreSubsequence(int n, int m, String a, String b) {\n        // Write your code here\n        return generateSubsequences(a) >= generateSubsequences(b) ? a : b;\n    }\n\n    public static void main(String[] args) {\n        String ans = moreSubsequence(9, 9, "cbfbdhcac", "bcbcfbeag");\n        System.out.println(ans);\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '848a1669-67cc-4090-a787-40d97bee968d',
                  isFolder: false,
                  name: 'PhoneKeypadCombination.java',
                  code: 'import java.util.*;\n\npublic class PhoneKeypadCombination {\n   public List<String> letterCombinations(String s) {\n        List<String> ans = new ArrayList<>();\n        if (s.length() == 0) return ans;\n        String[] mappings = {"", "", "abc","def", "ghi", "jkl","mno", "pqrs", "tuv","wxyz"};\n        solve(s, 0, ans, new StringBuilder(), mappings);\n        return ans;\n    }\n    void solve(String s, int idx, List<String> ans, StringBuilder sb, String[] mappings) {\n        if (idx == s.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        char ch = s.charAt(idx);\n        String map = mappings[ch - \'0\'];\n        for (int i = 0; i < map.length(); i++) {\n            sb.append(map.charAt(i));\n            solve(s, idx + 1, ans, sb, mappings);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}',
                  link: 'https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '68b39c8e-04fa-494d-ab2b-747e353937bd',
                  isFolder: false,
                  name: 'SubarraysWithKSum.java',
                  code: 'import java.util.*;\n\npublic class SubarraysWithKSum {\n    public static void solve(int[] arr, long k, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        if (idx == arr.length) {\n            if (k == 0) ans.add(new ArrayList<>(temp));\n            return;\n        }\n        temp.add(arr[idx]);\n        solve(arr, k - arr[idx], idx + 1, ans, temp);\n        temp.remove(temp.size() - 1);\n        solve(arr, k, idx + 1, ans, temp);\n    }\n\n//    Count total subsequences\n    public static int solveCount(int[] arr, long k, int sum, int idx) {\n        if (sum > k || idx == arr.length && sum != k) return 0;\n        if (sum == k) return 1;\n        return solveCount(arr, k, sum + arr[idx], idx + 1) + solveCount(arr, k, sum, idx + 1);\n    }\n\n    public static void subArraysWithSumK(int[] arr, long k) {\n        // Write your code here\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(arr);\n        solve(arr, k, 0, ans, new ArrayList<>());\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 1, 1, 1};\n        long k = 3;\n        subArraysWithSumK(arr, k);\n    }\n}',
                  link: "https://www.codingninjas.com/studio/problems/subarrays-with-sum-%E2%80%98k'_6922076",
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '226e0744-fd92-491a-80a1-a909740cbfba',
                  isFolder: false,
                  name: 'SubsetSum.java',
                  code: '//  Link: https://www.codingninjas.com/studio/problems/subset-sum_3843086\n\nimport java.util.ArrayList;\n\npublic class SubsetSum {\n    public static void solve(int[] arr, int idx, int sum, ArrayList<Integer> ans) {\n        if (idx == arr.length) {\n            ans.add(sum);\n            return;\n        }\n        // Exclude\n        solve(arr, idx + 1, sum, ans);\n        // Include\n        solve(arr, idx + 1, sum + arr[idx], ans);\n    }\n    public static ArrayList<Integer> subsetSum(int nums[]) {\n        // Write your code here..\n        ArrayList<Integer> ans = new ArrayList<>();\n        solve(nums, 0, 0, ans);\n        ans.sort(null);\n        return ans;\n    }\n}',
                  link: null,
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: 'b4387645-453f-4b7e-a656-1b1fa8424354',
                  isFolder: false,
                  name: 'SubsetSum2.java',
                  code: 'import java.util.*;\npublic class SubsetSum2 {\n    public static void solve(int[] arr, int idx, List<List<Integer>> ans, List<Integer> temp) {\n        ans.add(new ArrayList<>(temp));\n        for (int i = idx; i < arr.length; i++) {\n            if (i > idx && arr[i - 1] == arr[i]) continue;\n            temp.add(arr[i]);\n            solve(arr, i + 1, ans, temp);\n            temp.remove(temp.size() - 1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans = new ArrayList<>();\n        solve(nums, 0, ans, new ArrayList<>());\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/subsets-ii/',
                  notes: '',
                  tags: ['Subsequences Pattern'],
                },
                {
                  id: '3dda0308-ef0d-40a8-a7c2-ba8d88822dfd',
                  isFolder: false,
                  name: 'ExpressionAddOperators.java',
                  code: 'import java.util.*;\n\npublic class ExpressionAddOperators {\n    public static List<String> addOperators(String num, int target) {\n        List<String> ans = new ArrayList<>();\n        if (num == null || num.length() == 0) return ans;\n        solve(target, num, ans, "", 0, 0, 0);\n        return ans;\n    }\n\n    static void solve(int target, String num, List<String> ans, String path, int idx, long res, long prev) {\n        if (idx == num.length()) {\n            if (res == target) ans.add(path);\n            return;\n        }\n        for (int i = idx; i < num.length(); i++) {\n            if (i != idx && num.charAt(idx) == \'0\') break;\n            long curr = Long.parseLong(num.substring(idx, i+1));\n            if (idx == 0)\n                solve(target, num, ans, path + curr, i + 1, curr, curr);\n            else {\n                solve(target, num, ans, path + "+" + curr, i + 1, res + curr, curr);\n                solve(target, num, ans, path + "-" + curr, i + 1, res - curr, -curr);\n                solve(target, num, ans, path + "*" + curr, i + 1, res - prev + prev * curr, prev * curr);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String num = "232";\n        int target = 8;\n        System.out.println(addOperators(num, target));\n    }\n}',
                  link: 'https://leetcode.com/problems/expression-add-operators/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'a8bc3b07-4b86-4971-a04c-546839a5e849',
                  isFolder: false,
                  name: 'MNodesColoring.java',
                  code: 'public class MNodesColoring {\n    public static boolean isPossible(int[][] mat, int node, int n, int[] colors, int color) {\n        for (int i = 0; i < n; i++) {\n            if (mat[node][i] == 1 && color == colors[i]) return false;\n        }\n        return true;\n    }\n    public static boolean solve(int[][] mat, int m, int node, int n, int[] colors) {\n        if (node == n) return true;\n        for (int i = 1; i <= m; i++) {\n            if (isPossible(mat, node, n, colors, i)) {\n                colors[node] = i;\n                if (solve(mat, m, node + 1, n, colors)) return true;\n                colors[node] = 0;\n            }\n        }\n        return false;\n    }\n    public static String graphColoring(int [][]mat, int m) {\n        // Write your code here\n        int n = mat.length;\n        return solve(mat, m, 0, n, new int[n]) ? "YES" : "NO";\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/m-coloring-problem_981273',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '2c21720d-df36-4ce5-932d-0bc63d7d1ade',
                  isFolder: false,
                  name: 'NQueensProblem.java',
                  code: 'import java.util.Arrays;\n\npublic class NQueensProblem {\n\n    public static boolean safeToPlace(int i, int j, int[][] mat) {\n        int row = i, col = j;\n        while (row >= 0 && col >= 0) if (mat[row--][col--] == 1) return false;\n        row = i;\n        col = j;\n        while (col >= 0) if (mat[row][col--] == 1) return false;\n        col = j;\n        while (row < mat.length && col >= 0) if (mat[row++][col--] == 1) return false;\n        return true;\n    }\n\n    public static boolean solve(int[][] board, int col) {\n        if (col == board.length) {\n            for (int[] row : board)\n                System.out.println(Arrays.toString(row));\n            return true;\n        }\n\n        for (int row = 0; row < board.length; row++) {\n            if (safeToPlace(row, col, board)) {\n                board[row][col] = 1;\n                if (solve(board, col + 1)) return true;\n                board[row][col] = 0;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        int[][] board = new int[n][n];\n        solve(board, 0);\n    }\n}',
                  link: 'https://leetcode.com/problems/n-queens/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '45feef34-488f-497a-94f5-6613e1cebf90',
                  isFolder: false,
                  name: 'PalindromePartitioning.java',
                  code: 'import java.util.*;\npublic class PalindromePartitioning {\n    boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n\n    void solve(String s, List<List<String>> ans, List<String> temp, int idx) {\n        if (idx == s.length()) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for (int i = idx; i < s.length(); i++) {\n            if (!isPalindrome(s, idx, i)) continue;\n            temp.add(s.substring(idx, i+1));\n            solve(s, ans, temp, i + 1);\n            temp.remove(temp.size() - 1);\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> ans = new ArrayList<>();\n        solve(s, ans, new ArrayList<>(), 0);\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/palindrome-partitioning/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '5fe20931-3174-4677-8fcb-a5c334097355',
                  isFolder: false,
                  name: 'RatInAMaze.java',
                  code: 'import java.util.*;\n\npublic class RatInAMaze {\n    public static void func(int[][] mat, int i, int j, String path, List<String> paths, String directions, int[] di, int[] dj, boolean[][] visited) {\n        int m = mat.length; // rows\n        int n = mat[0].length; // cols\n        if (i < 0 || j < 0 || j >= n || i >= m || mat[i][j] == 0 || visited[i][j]) return;\n        if (i == m - 1 && j == n - 1) {\n            paths.add(path);\n            return;\n        }\n        for (int x = 0; x < 4; x++) {\n            visited[i][j] = true;\n            func(mat, i + di[x], j + dj[x], path + directions.charAt(x), paths, directions, di, dj, visited);\n            visited[i][j] = false;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n                {1, 0, 0, 0},\n                {1, 1, 0, 1},\n                {1, 1, 0, 0},\n                {0, 1, 1, 1},\n        };\n        List<String> paths = new ArrayList<>();\n        boolean[][] visited = new boolean[mat.length][mat[0].length];\n        String directions = "DLRU";\n        int[] di = {1, 0, 0, -1};\n        int[] dj = {0, -1, 1, 0};\n        func(mat, 0, 0, "", paths, directions, di, dj, visited);\n        System.out.println(paths);\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/rat-in-a-maze-_8842357',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: 'd2dc6b7a-8ca8-404b-a3b7-d9af5029a103',
                  isFolder: false,
                  name: 'SudokuSolver.java',
                  code: "public class SudokuSolver {\n    public static void printBoard(char[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            if (i % 3 == 0 && i != 0) {\n                System.out.println(\"- - - - - - - - - - - - - \");\n            }\n            for (int j = 0; j < board[i].length; j++) {\n                if (j % 3 == 0 && j != 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(board[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static boolean isPossible(char[][] board, int r, int c, char ch) {\n        for (int i = 0; i < 9; i++) {\n            if (board[r][i] == ch || board[i][c] == ch) return false;\n        }\n        int row = r / 3;\n        int col = c / 3;\n        for (int i = row * 3; i < (row + 1) * 3; i++) {\n            for (int j = col * 3; j < (col + 1) * 3; j++) {\n                if (board[i][j] == ch) return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean solve(char[][] board) {\n        for (int row = 0; row < board.length; row++) {\n            for (int col = 0; col < board[row].length; col++) {\n                if (board[row][col] == '.') {\n                    for (char ch = '1'; ch <= '9'; ch++) {\n                        if (isPossible(board, row, col, ch)) {\n                            board[row][col] = ch;\n                            if (solve(board)) return true;\n                            board[row][col] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void solveSudoku(char[][] board) {\n        if (solve(board)) {\n            printBoard(board);\n        };\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},\n                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},\n                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},\n                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},\n                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},\n                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},\n                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},\n                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},\n                {'.', '.', '.', '.', '8', '.', '.', '7', '9'}\n        };\n        solveSudoku(board);\n    }\n}",
                  link: 'https://leetcode.com/problems/sudoku-solver/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '80328817-9649-409e-a2e5-6fb9a14bf763',
                  isFolder: false,
                  name: 'WordBreak.java',
                  code: 'import java.util.List;\n\npublic class WordBreak {\n    static boolean check(String s, String b) {\n        return s.length() >= b.length() && s.startsWith(b);\n    }\n\n    static boolean solve(String s, List<String> words, int idx, int[] dp) {\n        if (idx == s.length())\n            return true;\n        for (int i = 0; i < words.size(); i++) {\n            if (!check(s.substring(idx), words.get(i)))\n                continue;\n            int x = idx + words.get(i).length();\n            if (dp[x] == 0 ? solve(s, words, x, dp) : dp[x] > 0)\n                return true;\n            dp[x] = -1;\n        }\n        return false;\n    }\n\n    public boolean wordBreak(String s, List<String> words) {\n        int[] dp = new int[s.length() + 1];\n        return solve(s, words, 0, dp);\n    }\n}',
                  link: 'https://leetcode.com/problems/word-break/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
                {
                  id: '54632911-4447-4c8d-a711-e7116d2a1753',
                  isFolder: false,
                  name: 'WordSearch.java',
                  code: "public class WordSearch {\n    static boolean solve(String word, int idx, int i, int j, int[] dx, int[] dy, boolean[][] visited, char[][] board) {\n        if (idx == word.length()) return true;\n        char ch = word.charAt(idx);\n        if (i < 0 || j < 0 || i == board.length || j == board[0].length || visited[i][j] || board[i][j] != ch) return false;\n        System.out.println(board[i][j]);\n        for (int x = 0; x < 4; x++) {\n            visited[i][j] = true;\n            if (solve(word, idx + 1, i + dx[x], j + dy[x], dx, dy, visited, board)) {\n                return true;\n            }\n            visited[i][j] = false;\n        }\n        return false;\n    }\n\n    public static boolean exist(char[][] board, String word) {\n        // DLRU\n        int[] dx = {0, -1, 1, 0};\n        int[] dy = {1, 0, 0, -1};\n        boolean[][] visited = new boolean[board.length][board[0].length];\n\n        char ch = word.charAt(0);\n        for (int i = 0; i < board.length; i++)\n            for (int j = 0; j < board[i].length; j++)\n                if (board[i][j] == ch && solve(word, 0, i, j, dx, dy, visited, board)) return true;\n        return false;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n                {'A', 'B', 'C', 'E'},\n                {'S', 'F', 'C', 'S'},\n                {'A', 'D', 'E', 'E'}\n        };\n        String word = \"ABCCED\";\n        System.out.println(exist(board, word));\n    }\n}",
                  link: 'https://leetcode.com/problems/word-search/',
                  notes: '',
                  tags: ['Trying out all Combos or Hard'],
                },
              ],
            },
            {
              id: 'ca7e0294-0e2f-41fd-af34-9737a4649c2d',
              isFolder: true,
              name: 'Sliding Window & Two Pointer Combined Problems',
              content: [
                {
                  id: '0aeab086-038e-490a-9cf7-1e7dbdad6dbf',
                  isFolder: false,
                  name: 'LongestSubstringwithAtMostKDistinctCharacters.java',
                  code: "public class LongestSubstringwithAtMostKDistinctCharacters {\n    public static int kDistinctChars(int k, String str) {\n        // Write your code here\n        int[] count = new int[26];\n        int i = 0, j = 0, unique = 0, maxLength = 0;\n        while (j < str.length()) {\n            int idx1 = str.charAt(j) - 'a';\n            count[idx1]++;\n            if (count[idx1] == 1) unique++;\n            while (unique > k) {\n                int idx2 = str.charAt(i++) - 'a';\n                count[idx2]--;\n                if (count[idx2] == 0) unique--;\n            }\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/longest-substring-with-at-most-k-distinct-characters_2221410',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'f369f9a7-f490-4939-8767-d610afe11532',
                  isFolder: false,
                  name: 'MinimumWindowSubsequence.java',
                  code: 'import java.util.*;\n\npublic class MinimumWindowSubsequence {\n    public static String minWindow(String s, String t) {\n        // Write your code here\n        int i = 0, j = 0, start, end, minLength = s.length() + 1, subStart = 0;\n        while (i < s.length() && j < t.length()) {\n            if (s.charAt(i) == t.charAt(j)) {\n                if (j == t.length() - 1) {\n                    end = i;\n                    while (j >= 0) {\n                        if (s.charAt(i) == t.charAt(j)) j--;\n                        i--;\n                    }\n                    start = i + 1;\n                    int size = end - start + 1;\n                    if (minLength > size) {\n                        minLength = size;\n                        subStart = start;\n                    }\n                    j = 0;\n                    i++;\n                } else j++;\n            }\n            i++;\n        }\n        return minLength > s.length() ? "" : s.substring(subStart, subStart + minLength);\n\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/minimum-window-subsequence_2181133',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: 'b1052375-38d0-4922-a123-ee64a419b8d0',
                  isFolder: false,
                  name: 'MinimumWindowSubstring.java',
                  code: 'import java.util.*;\n\npublic class MinimumWindowSubstring {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < t.length(); i++) {\n            char ch = t.charAt(i);\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n        }\n        int start = 0, subStart = 0, minLength = s.length() + 1, match = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char ch1 = s.charAt(end);\n            if (map.containsKey(ch1)) {\n                map.put(ch1, map.get(ch1) - 1);\n                if (map.get(ch1) == 0) match++;\n            }\n            while (match == map.size()) {\n                int size = end - start + 1;\n                if (minLength > size) {\n                    minLength = size;\n                    subStart = start;\n                }\n                char ch2 = s.charAt(start);\n                if (map.containsKey(ch2)) {\n                    map.put(ch2, map.get(ch2) + 1);\n                    if (map.get(ch2) == 1) match--;\n                }\n                start++;\n            }\n        }\n        return minLength > s.length() ? "" : s.substring(subStart, subStart + minLength);\n    }\n}',
                  link: 'https://leetcode.com/problems/minimum-window-substring/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '702ef9d3-739d-49cd-ad71-be0dfd57bc2d',
                  isFolder: false,
                  name: 'SubarrayswithKDifferentIntegers.java',
                  code: 'public class SubarrayswithKDifferentIntegers {\n    public static int atmost(int[] nums, int k) {\n        int[] bucket = new int[nums.length + 1];\n        int i = 0, j = 0, unique = 0, count = 0;\n        while (j < nums.length) {\n            int idx1 = nums[j];\n            bucket[idx1]++;\n            if (bucket[idx1] == 1) unique++;\n            while (unique > k) {\n                int idx2 = nums[i++];\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) unique--;\n            }\n            count += j - i + 1;\n            j++;\n        }\n        return count;\n    }\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atmost(nums, k) - atmost(nums, k - 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/subarrays-with-k-different-integers/',
                  notes: '',
                  tags: ['Hard Problems'],
                },
                {
                  id: '3d3dd95d-c309-4f92-9e9f-898dde02c233',
                  isFolder: false,
                  name: 'BinarySubArraysWithSum.java',
                  code: 'import java.util.*;\npublic class BinarySubArraysWithSum {\n    public static int atmost(int[] nums, int goal) {\n        int sum = 0, i = 0, j = 0, count = 0;\n        while (j < nums.length) {\n            sum += nums[j];\n            while (i <= j && sum > goal) {\n                sum -= nums[i];\n                i++;\n            }\n            count += j - i + 1;\n            j++;\n        }\n        return count;\n    }\n    public int numSubarraysWithSum(int[] nums, int goal) {\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        hm.put(0, 1);\n//        int sum = 0, count = 0;\n//        for (int i = 0; i < nums.length; i++) {\n//            sum += nums[i];\n//            if (hm.containsKey(sum - goal))\n//                count += hm.get(sum - goal);\n//            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n//        }\n//        return count;\n        return atmost(nums, goal) - atmost(nums, goal - 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/binary-subarrays-with-sum/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '3a8d04dc-76e5-47f5-8d82-861aeacca2d4',
                  isFolder: false,
                  name: 'CountNumberOfNiceSubArrays.java',
                  code: 'import java.util.*;\n\npublic class CountNumberOfNiceSubArrays {\n    public static int atmost(int[] nums, int goal) {\n        int sum = 0, i = 0, j = 0, count = 0;\n        while (j < nums.length) {\n            sum += nums[j]%2;\n            while (i <= j && sum > goal) {\n                sum -= nums[i]%2;\n                i++;\n            }\n            count += j - i + 1;\n            j++;\n        }\n        return count;\n    }\n    public int numberOfSubarrays(int[] nums, int k) {\n//        HashMap<Integer, Integer> hm = new HashMap<>();\n//        hm.put(0, 1);\n//        int sum = 0, count = 0;\n//        for (int i = 0; i < nums.length; i++) {\n//            sum += nums[i]%2 == 0 ? 0 : 1;\n//            if (hm.containsKey(sum - k))\n//                count += hm.get(sum - k);\n//            hm.put(sum, hm.getOrDefault(sum, 0) + 1);\n//        }\n//        return count;\n        return atmost(nums, k) - atmost(nums, k - 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/count-number-of-nice-subarrays/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: 'a9ff9dd3-326e-4892-ae98-6618449ba94a',
                  isFolder: false,
                  name: 'FruitIntoBaskets.java',
                  code: 'import java.util.*;\n\npublic class FruitIntoBaskets {\n    public static int findMaxFruits(int[] arr, int n) {\n        // Write your code here.\n        int i = 0, j = 0, count = 0, maxCount = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        while (j < n) {\n            hm.put(arr[j], hm.getOrDefault(arr[j], 0) + 1);\n            count++;\n            while (hm.size() > 2) {\n                int c = hm.get(arr[i]);\n                if (c == 1) hm.remove(arr[i]);\n                else hm.put(arr[i], c - 1);\n                count--;\n                i++;\n            }\n            maxCount = Math.max(maxCount, count);\n            j++;\n        }\n        return maxCount;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/fruits-and-baskets_985356',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '7a20bb3b-201d-4bbb-a6c5-686b65c96c6b',
                  isFolder: false,
                  name: 'LongestRepeatingCharacterReplacement.java',
                  code: "public class LongestRepeatingCharacterReplacement {\n    public static int getMaxFrequency(int[] arr) {\n        int maxFrequency = 0;\n        for (int i = 0; i < 26; i++)\n            maxFrequency = Math.max(maxFrequency, arr[i]);\n        return maxFrequency;\n    }\n    public int characterReplacement(String s, int k) {\n        int[] bucket = new int[26];\n        int i = 0, j = 0, maxLength = 0;\n        while (j < s.length()) {\n            int idx = s.charAt(j) - 'A';\n            bucket[idx]++;\n            while (j-i+1 - getMaxFrequency(bucket) > k)\n                bucket[s.charAt(i++) - 'A']--;\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/longest-repeating-character-replacement/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '4edef24a-4361-4917-aee3-41b5d790e115',
                  isFolder: false,
                  name: 'LongestSubStringWithoutRepeatingCharacters.java',
                  code: "import java.util.*;\npublic class LongestSubStringWithoutRepeatingCharacters {\n    public int lengthOfLongestSubstring(String s) {\n//        HashMap<Character, Integer> hm = new HashMap<>();\n//        int i = 0, j = 0, maxLength = 0;\n//        while (j < s.length()) {\n//            char ch = s.charAt(j);\n//            hm.put(ch, hm.getOrDefault(ch, 0) + 1);\n//            while (hm.size() < j - i + 1) {\n//                char ch2 = s.charAt(i);\n//                int c = hm.get(ch2);\n//                if (c == 1) hm.remove(ch2);\n//                else hm.put(ch2, c - 1);\n//                i++;\n//            }\n//            if (hm.size() == j - i + 1)\n//                maxLength = Math.max(maxLength, j - i + 1);\n//            j++;\n//        }\n//        return maxLength;\n//        Could have used a HashMap as well\n        int[] bucket = new int[128];\n        int i = 0, j = 0, unique = 0, maxLength = 0;\n        while (j < s.length()) {\n            int idx = s.charAt(j) - ' ';\n            bucket[idx]++;\n            if (bucket[idx] == 1) unique++;\n            while (unique < j - i + 1) {\n                int idx2 = s.charAt(i) - ' ';\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) unique--;\n                i++;\n            }\n            if (unique == j - i + 1) {\n                maxLength = Math.max(maxLength, j - i + 1);\n            }\n            j++;\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/longest-substring-without-repeating-characters/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '3512aed4-66dc-477e-8729-68f5c2fa5177',
                  isFolder: false,
                  name: 'MaximumConsecutiveOnes3.java',
                  code: 'public class MaximumConsecutiveOnes3 {\n    public int longestOnes(int[] nums, int k) {\n        int i = 0, j = 0, maxLength = 0, flips = 0;\n        while (j < nums.length) {\n            if (nums[j] == 0) flips++;\n            while (flips > k) if (nums[i++] == 0) flips--;\n//            if (flips <= k)\n            maxLength = Math.max(maxLength, j - i + 1);\n            j++;\n        }\n        return maxLength;\n    }\n}',
                  link: 'https://leetcode.com/problems/max-consecutive-ones-iii/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '7449e5ca-5734-4dfc-949f-976b9f911f91',
                  isFolder: false,
                  name: 'MaximumPointsFromCards.java',
                  code: 'public class MaximumPointsFromCards {\n    public int maxScore(int[] cardPoints, int k) {\n//        O(N)\n//        int n = cardPoints.length, sum = 0, i = 0, j = n - k;\n//        for (int point = j; point < n; point++)\n//            sum += cardPoints[point];\n//        int res = sum;\n//        while (j < n) {\n//            sum += cardPoints[i++] - cardPoints[j++];\n//            res = Math.max(res, sum);\n//        }\n//        return res;\n\n//        O(2N)\n        int n = cardPoints.length, totalSum = 0;\n        for (int point : cardPoints) totalSum += point;\n        if (k == n) return totalSum;\n\n        int window = 0, i = 0, j = 0, sum = 0, size = n - k;\n        while (j < n) {\n            window += cardPoints[j];\n            if (j - i + 1 == size) {\n                sum = Math.max(sum, totalSum - window);\n                window -= cardPoints[i++];\n            }\n            j++;\n        }\n        return sum;\n    }\n}',
                  link: 'https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
                {
                  id: '8fc0acd9-5af9-446e-973e-980252a9e63d',
                  isFolder: false,
                  name: 'NumberOfSubStringsContainingAll3Characters.java',
                  code: "public class NumberOfSubStringsContainingAll3Characters {\n    public static int countSubstring(String s){\n        // Write your code here.\n//        int count = 0;\n//        int i = 0, j = 0;\n//        int[] arr = {0, 0, 0};\n//        while (j < s.length()) {\n//            arr[s.charAt(j) - 'a']++;\n//            while (arr[0] > 0 && arr[1] > 0 && arr[2] > 0) {\n//                arr[s.charAt(i) - 'a']--;\n//                i++;\n//            }\n//            count += i;\n//            j++;\n//        }\n//        return count;\n        int count = 0;\n        int idx_a = -1, idx_b = -1, idx_c = -1;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == 'a') {\n                idx_a = i;\n            }\n            else if (ch == 'b') {\n                idx_b = i;\n            }\n            else if (ch == 'c') {\n                idx_c = i;\n            }\n            count += Math.min(idx_a, Math.min(idx_b, idx_c))+1;\n        }\n        return count;\n    }\n}",
                  link: 'https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/',
                  notes: '',
                  tags: ['Medium Problems'],
                },
              ],
            },
            {
              id: '199e5de3-f506-4b73-9cdf-90ed0ce6756f',
              isFolder: true,
              name: 'Stacks and Queues',
              content: [
                {
                  id: '5b66fcc7-5af0-4493-9f86-0e8a7ead3aa5',
                  isFolder: false,
                  name: 'CelebrityProblem.java',
                  code: 'import java.util.*;\n\npublic class CelebrityProblem {\n    int celebrity(int[][] M, int n) {\n        // code here\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            stack.push(i);\n        }\n        while (stack.size() > 1) {\n            int p1 = stack.pop();\n            int p2 = stack.pop();\n            if (M[p1][p2] == 1) {\n                stack.push(p2);\n            } else if (M[p2][p1] == 1) {\n                stack.push(p1);\n            }\n        }\n        int celeb = stack.pop();\n        // verify celeb\n        for (int i = 0; i < n; i++) {\n            if (i != celeb && M[i][celeb] == 0) return -1;\n            if (i != celeb && M[celeb][i] == 1) return -1;\n        }\n        return celeb;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/the-celebrity-problem_982769',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: 'e762460b-bba5-4fcb-a7b8-b2f750137997',
                  isFolder: false,
                  name: 'LFUCache.java',
                  code: 'import java.util.*;\nclass LFUCache {\n    static class Node {\n        int key, value, frequency;\n        Node next;\n        Node prev;\n        Node (int k, int v) {\n            this.key = k;\n            this.value = v;\n            this.next = null;\n            this.prev = null;\n            this.frequency = 1;\n        }\n    }\n    static class DLL {\n        Node head, tail;\n        int size;\n        DLL() {\n            this.head = new Node(-100, -100);\n            this.tail = new Node(-100, -100);\n            this.head.next = this.tail;\n            this.tail.prev = this.head;\n        }\n        void add(Node node) {\n            node.next = head.next;\n            node.prev = head;\n            head.next.prev = node;\n            head.next = node;\n            size += 1;\n        }\n        void remove(Node node) {\n            Node next = node.next;\n            Node prev = node.prev;\n            next.prev = prev;\n            prev.next = next;\n            size -= 1;\n        }\n    }\n    Map<Integer, Node> keyNode;\n    Map<Integer, DLL> freqList;\n    int maxSize;\n    int minFrequency = 1;\n    public LFUCache(int capacity) {\n        keyNode = new HashMap<>();\n        freqList = new HashMap<>();\n        maxSize = capacity;\n    }\n\n    void updateFrequency(Node node) {\n        DLL list = freqList.get(node.frequency);\n        list.remove(node);\n        if (list.size == 0 && node.frequency == minFrequency) minFrequency++;\n        node.frequency += 1;\n        if (freqList.containsKey(node.frequency)) {\n            freqList.get(node.frequency).add(node);\n        } else {\n            DLL newList = new DLL();\n            newList.add(node);\n            freqList.put(node.frequency, newList);\n        }\n    }\n\n    public int get(int key) {\n        if (keyNode.containsKey(key)) {\n            Node node = keyNode.get(key);\n            updateFrequency(node);\n            return node.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (maxSize == 0) return;\n        if (keyNode.containsKey(key)) {\n            Node node = keyNode.get(key);\n            node.value = value;\n            updateFrequency(node);\n        }\n        else {\n            Node node = new Node(key, value);\n            if (keyNode.size() == maxSize) {\n                DLL list = freqList.get(minFrequency);\n                keyNode.remove(list.tail.prev.key);\n                list.remove(list.tail.prev);\n            }\n            minFrequency = 1;\n            if (freqList.containsKey(node.frequency)) {\n                freqList.get(node.frequency).add(node);\n            } else {\n                DLL newList = new DLL();\n                newList.add(node);\n                freqList.put(node.frequency, newList);\n            }\n            keyNode.put(node.key, node);\n        }\n    }\n}\n\n/*\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */',
                  link: 'https://leetcode.com/problems/lfu-cache/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '6e788a07-e195-409c-8c22-a69a4ca27348',
                  isFolder: false,
                  name: 'LRUCache.java',
                  code: 'import java.util.*;\n\nclass LRUCache {\n    static class Node {\n        int key;\n        int value;\n        Node next;\n        Node prev;\n        Node (int key, int value)  {\n            this.next = null;\n            this.prev = null;\n            this.key = key;\n            this.value = value;\n        }\n    }\n    Node head = new Node(-1,-1);\n    Node tail = new Node(-1,-1);\n    int capacity;\n    HashMap<Integer, Node> hm = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (this.hm.containsKey(key)) {\n            Node temp = this.hm.get(key);\n            delete(temp);\n            insert(temp);\n            return temp.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (this.hm.containsKey(key)) delete(this.hm.get(key));\n        if (this.hm.size() == this.capacity) delete(this.tail.prev);\n        insert(new Node(key, value));\n    }\n\n    public void delete(Node node) {\n        this.hm.remove(node.key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    public void insert(Node node) {\n        this.hm.put(node.key, node);\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n}',
                  link: 'https://leetcode.com/problems/lru-cache/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '2c3c3243-8ecf-4f64-9a8c-bd724b94a7e2',
                  isFolder: false,
                  name: 'SlidingWindowMaximum.java',
                  code: 'import java.util.*;\n\npublic class SlidingWindowMaximum {\n    public static int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> q = new ArrayDeque<>();\n        int[] ans = new int[nums.length - k + 1];\n        int i = 0, j = 0;\n        while (j < nums.length) {\n            while (!q.isEmpty() && nums[q.peekLast()] < nums[j]) q.pollLast();\n            q.offer(j);\n            if (j - i + 1 == k) {\n                if (q.peekFirst() < i) q.pollFirst();\n                ans[i] = nums[q.peekFirst()];\n                i++;\n            }\n            j++;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, -1, -3, 5, 3, 6, 7};\n        int[] ans = maxSlidingWindow(arr, 3);\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: 'https://leetcode.com/problems/sliding-window-maximum/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '78fd07c0-fd40-4f70-92bf-095a5a9136f2',
                  isFolder: false,
                  name: 'StockSpanner.java',
                  code: 'import java.util.*;\nclass StockSpanner {\n    static class Pair {\n        int first, second;\n        Pair(int a, int b) {\n            this.first = a;\n            this.second = b;\n        }\n    }\n    static Stack<Pair> stack;\n    public StockSpanner() {\n        stack = new Stack<>();\n    }\n    \n    public int next(int price) {\n        if (stack.isEmpty()) {\n            Pair temp = new Pair(price, 1);\n            stack.add(temp);\n            return 1;\n        }\n        int val = 1;\n        while (!stack.isEmpty() && stack.peek().first <= price) {\n            val += stack.pop().second;\n        }\n        stack.push(new Pair(price, val));\n        return val;\n    }\n\n    public static void main(String[] args) {\n        StockSpanner obj = new StockSpanner();\n        int[] arr = {100, 80, 60, 70, 60, 75, 85};\n        int[] ans = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            ans[i] = obj.next(arr[i]);\n        }\n        System.out.println(Arrays.toString(ans));\n    }\n}',
                  link: 'https://leetcode.com/problems/online-stock-span/',
                  notes: '',
                  tags: ['Implementation Problems'],
                },
                {
                  id: '97bd4a5b-9b90-4cda-b1bc-c983b52c575b',
                  isFolder: false,
                  name: 'MinStack.java',
                  code: 'import java.util.*;\n\npublic class MinStack {\n    Stack<Integer> stack;\n    Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        minStack.push(minStack.isEmpty() ? val : Math.min(minStack.peek(), val));\n    }\n\n    public void pop() {\n        stack.pop();\n        minStack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}',
                  link: 'https://leetcode.com/problems/min-stack/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'dcd1db82-02a3-4c81-9d25-367f098ac9c9',
                  isFolder: false,
                  name: 'QueueUsingArray.java',
                  code: "public class QueueUsingArray {\n    class Queue {\n        int front, rear;\n        int []arr;\n\n        Queue() {\n            front = 0;\n            rear = 0;\n            arr = new int[100001];\n        }\n\n        // Enqueue (add) element 'e' at the end of the queue.\n        public void enqueue(int e) {\n            // Write your code here.\n            if (rear < arr.length) {\n                arr[rear++] = e;\n            }\n        }\n\n        // Dequeue (retrieve) the element from the front of the queue.\n        public int dequeue() {\n            // Write your code here.\n            if (front < rear) {\n                return arr[front++];\n            }\n            return -1;\n        }\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/implement-queue-using-arrays_8390825',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'c4d717d7-cbed-468a-9106-5c3c093dd1f9',
                  isFolder: false,
                  name: 'QueueUsingLinkedList.java',
                  code: 'class Node {\n    public int data;\n    public Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n};\n\nclass MQueue{\n    Node front;\n    Node rear;\n    void push(){};\n    MQueue() {\n        front = null;\n        rear = null;\n    }\n}\n\npublic class QueueUsingLinkedList extends MQueue {\n    public void push(int x) {\n        // Write Your Code Here\n        Node newNode = new Node(x);\n        if (front == null && rear == null) {\n            front = newNode;\n            rear = newNode;\n        } else {\n            rear.next = newNode;\n            rear = rear.next;\n        }\n    }\n\n    public int pop() {\n        // Write Your Code Here\n        if (front == null || rear == null) return -1;\n        Node temp = front;\n        if (front == rear) {\n            front = null;\n            rear = null;\n        } else {\n            front = front.next;\n        }\n        return temp.data;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/implement-queue-using-linked-list_8161235',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'b3a9003a-ba76-44a0-9cd4-907e6cc00f5c',
                  isFolder: false,
                  name: 'QueueUsingStack.java',
                  code: 'import java.util.*;\n\npublic class QueueUsingStack {\n    class MyQueue {\n        Stack<Integer> s1;\n        Stack<Integer> s2;\n\n        public MyQueue() {\n            s1 = new Stack<>();\n            s2 = new Stack<>();\n        }\n\n        public void push(int x) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n            s1.push(x);\n            while (!s2.isEmpty()) {\n                s1.push(s2.pop());\n            }\n        }\n\n        public int pop() {\n            return this.s1.pop();\n        }\n\n        public int peek() {\n            return this.s1.peek();\n        }\n\n        public boolean empty() {\n            return this.s1.isEmpty();\n        }\n    }\n\n}',
                  link: 'https://leetcode.com/problems/implement-queue-using-stacks/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: 'ab0ef80f-4e35-4238-bbb5-45ee71e279fd',
                  isFolder: false,
                  name: 'StackUsingArrays.java',
                  code: 'public class StackUsingArrays {\n    static class Stack {\n        int[] stack;\n        int index;\n        int capacity;\n        Stack(int capacity) {\n            // Write your code here.\n            this.stack = new int[capacity];\n            this.index = -1;\n            this.capacity = capacity;\n        }\n        public void push(int num) {\n            // Write your code here\n            if (this.index != this.capacity - 1) {\n                this.index += 1;\n                this.stack[this.index] = num;\n            }\n        }\n        public int pop() {\n            // Write your code here.\n            if (this.index != -1) {\n                return this.stack[this.index--];\n            }\n            return -1;\n        }\n        public int top() {\n            // Write your code here.\n            if (this.index != -1) {\n                return this.stack[this.index];\n            }\n            return -1;\n        }\n        public int isEmpty() {\n            // Write your code here.\n            return this.index == -1 ? 1 : 0;\n            // false = 0;\n        }\n        public int isFull() {\n            // Write your code here.\n            return this.index == this.capacity - 1 ? 1 : 0;\n        }\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/stack-implementation-using-array_3210209',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '58a8233a-3adb-4f4f-a080-6f1e21615641',
                  isFolder: false,
                  name: 'StackUsingLinkedList.java',
                  code: 'public class StackUsingLinkedList {\n    static class Node {\n        int data;\n        Node next;\n\n        Node() {\n            this.data = 0;\n            this.next = null;\n        }\n\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n\n        Node(int data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n\n    ;\n\n    static class Stack {\n        //Write your code here\n        Node head;\n        Node tail;\n        int length;\n\n        Stack() {\n            head = null;\n            tail = null;\n            length = 0;\n        }\n\n        int getSize() {\n            return this.length;\n        }\n\n        boolean isEmpty() {\n            return this.length == 0;\n        }\n\n        void push(int data) {\n            Node newNode = new Node(data);\n            if (tail == null || head == null) {\n                head = newNode;\n                tail = newNode;\n            } else {\n                tail.next = newNode;\n                tail = tail.next;\n            }\n            length++;\n        }\n\n        void pop() {\n            if (head == tail) {\n                head = null;\n                tail = null;\n                length = 0;\n            } else {\n                Node curr = head;\n                Node prev = null;\n                while (curr.next != null) {\n                    prev = curr;\n                    curr = curr.next;\n                }\n                prev.next = null;\n                tail = prev;\n                length--;\n            }\n        }\n\n        int getTop() {\n            if (tail != null) return tail.data;\n            return -1;\n        }\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/implement-stack-with-linked-list_1279905',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '2df06ef2-2da6-48c6-bccb-6af35e166a17',
                  isFolder: false,
                  name: 'StackUsingQueue.java',
                  code: 'import java.util.*;\n\npublic class StackUsingQueue {\n    class MyStack {\n        static Queue<Integer> queue;\n        public MyStack() {\n            queue = new LinkedList<>();\n        }\n\n        public void push(int x) {\n            queue.add(x);\n            for (int i =0; i < queue.size() - 1; i++) {\n                int element = queue.poll();\n                queue.add(element);\n            }\n        }\n\n        public int pop() {\n            return queue.remove();\n        }\n\n        public int top() {\n            return queue.peek();\n        }\n\n        public boolean empty() {\n            return queue.isEmpty();\n        }\n\n    }\n}',
                  link: 'https://leetcode.com/problems/implement-stack-using-queues/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '4e41732a-ea10-42de-bbca-1908ee2d237b',
                  isFolder: false,
                  name: 'ValidParentheses.java',
                  code: "import java.util.*;\n\npublic class ValidParentheses {\n    public boolean isValid(String s) {\n        HashMap<Character, Character> hm = new HashMap<>();\n        hm.put('(', ')');\n        hm.put('[', ']');\n        hm.put('{', '}');\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (hm.containsKey(ch)) {\n                stack.push(ch);\n            } else {\n                if (stack.isEmpty()) return false;\n                char element = stack.peek();\n                if (hm.get(element) != ch) return false;\n                stack.pop();\n            }\n        }\n        return stack.isEmpty();\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-parentheses/',
                  notes: '',
                  tags: ['Learning'],
                },
                {
                  id: '3950ef0a-fbd5-459e-a9f3-ca4bb10a6cc1',
                  isFolder: false,
                  name: 'AsteroidCollision.java',
                  code: 'import java.util.*;\n\npublic class AsteroidCollision {\n    public static boolean sameSign (int i, int j) {\n        return (i > 0 && j > 0) || (i < 0 && j < 0);\n    }\n    public static boolean rulesFollowed(Stack<Integer> stack, int asteroid) {\n        return stack.isEmpty() || stack.peek() > 0 && asteroid > 0 || stack.peek() < 0 && asteroid < 0 || stack.peek() < 0;\n    }\n\n    public static int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n        int idx = 0;\n        while (idx < asteroids.length) {\n            if (rulesFollowed(stack, asteroids[idx])) stack.push(asteroids[idx]);\n            else {\n                int val = Math.abs(asteroids[idx]);\n                if (stack.peek() == val) stack.pop();\n                else if (stack.peek() < val) {\n                    stack.pop();\n                    idx--;\n                }\n            }\n            idx++;\n        }\n        int size = stack.size();\n        int[] ans = new int[size];\n        while (!stack.isEmpty())\n            ans[--size] = stack.pop();\n        return ans;\n//        Stack<Integer> stack = new Stack<>();\n//        int j = -1;\n//        int idx = 0;\n//        while (idx < asteroids.length) {\n//            if (j == -1 || sameSign(asteroids[j], asteroids[idx]) || asteroids[j] < 0)\n//                asteroids[++j] = asteroids[idx];\n//            else {\n//                if (asteroids[j] == Math.abs(asteroids[idx])) {\n//                    asteroids[j] = 0;\n//                    j--;\n//                } else if (asteroids[j] < Math.abs(asteroids[idx])) {\n//                    asteroids[j] = 0;\n//                    j--;\n//                    idx--;\n//                }\n//            }\n//            idx++;\n//        }\n//        int[] ans = new int[j+1];\n//        System.arraycopy(asteroids, 0, ans, 0, j + 1);\n//        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {-2, -2, 1, -2};\n//        int[] arr = {5, -5};\n//        int[] arr = {5, 10, -5};\n        System.out.println(Arrays.toString(asteroidCollision(arr)));\n    }\n}',
                  link: 'https://leetcode.com/problems/asteroid-collision/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '2c9f8fd7-d47b-4b27-a472-22fb010a7988',
                  isFolder: false,
                  name: 'LargestRectangleInHistogram.java',
                  code: 'import java.util.*;\n\npublic class LargestRectangleInHistogram {\n    public static int[] getPSE(int[] arr, int n) {\n        int[] ans = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n\n    public static int[] getNSE(int[] arr, int n) {\n        int[] ans = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = n;\n        return ans;\n    }\n\n    public static int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        if (n == 1) return heights[0];\n        int[] nse = getNSE(heights, n);\n        int[] pse = getPSE(heights, n);\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            int area = (nse[i] - pse[i] - 1) * heights[i];\n            maxArea = Math.max(maxArea, area);\n        }\n        return maxArea;\n    }\n\n    public static void main(String[] args) {\n        int[] heights = {3};\n        System.out.println(largestRectangleArea(heights));\n    }\n}\n\n// [2,1,5,6,2,3]\n//',
                  link: 'https://leetcode.com/problems/largest-rectangle-in-histogram/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '9d521669-6106-49b5-a9c4-79f931c1dac7',
                  isFolder: false,
                  name: 'MaximalRectangle.java',
                  code: "import java.util.*;\n\npublic class MaximalRectangle {\n    public static int[] getPSE(char[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n\n    public static int[] getNSE(char[] arr, int n) {\n        int[] ans = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i])\n                ans[stack.pop()] = i;\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = n;\n        return ans;\n    }\n\n    public static int largestRectangleArea(char[] heights) {\n        int n = heights.length;\n        int[] nse = getNSE(heights, n), pse = getPSE(heights, n);\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++)\n            maxArea = Math.max(maxArea, (nse[i] - pse[i] - 1) * (heights[i] - '0'));\n        return maxArea;\n    }\n\n    public int maximalRectangle(char[][] M) {\n        int max = largestRectangleArea(M[0]);\n        for (int i = 1; i < M.length; i++) {\n            for (int j = 0; j < M[0].length; j++) {\n                M[i][j] = M[i][j] == '1' ? (char) (M[i][j] + M[i - 1][j] - '0') : '0';\n            }\n            max = Math.max(max, largestRectangleArea(M[i]));\n        }\n        return max;\n    }\n}",
                  link: 'https://leetcode.com/problems/maximal-rectangle/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '5dded973-8a04-4225-8bb6-8773caa920f2',
                  isFolder: false,
                  name: 'NearestSmallerElement.java',
                  code: 'import java.util.*;\npublic class NearestSmallerElement {\n    public int[] prevSmaller(int[] A) {\n        int[] ans = new int[A.length];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = A.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && A[stack.peek()] > A[i])\n                ans[stack.pop()] = A[i];\n            stack.push(i);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n}',
                  link: 'https://www.interviewbit.com/problems/nearest-smaller-element/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '348e449a-d8c1-44ac-ab40-f559364bd3bf',
                  isFolder: false,
                  name: 'NextGreaterElement.java',
                  code: 'import java.util.*;\npublic class NextGreaterElement {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        int[] ans = new int[nums1.length];\n        for (int i = 0; i < nums1.length; i++) {\n            hm.put(nums1[i], i);\n            ans[i] = -1;\n        }\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < nums2.length; i++) {\n            while (!stack.isEmpty() && nums2[i] > stack.peek())\n                ans[hm.get(stack.pop())] = nums2[i];\n            if (hm.containsKey(nums2[i]))\n                stack.push(nums2[i]);\n        }\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/next-greater-element-i/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '4a509e51-2124-421a-a9d6-c479bad0f041',
                  isFolder: false,
                  name: 'NextGreaterElement2.java',
                  code: 'import java.util.*;\n\npublic class NextGreaterElement2 {\n    public static int[] nextGreaterElementII(int []a) {\n        // Write your code here.\n        int n = a.length;\n        int[] ans = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < 2 * n; i++) {\n            int idx = i%n;\n            while (!stack.isEmpty() && a[stack.peek()] < a[idx])\n                ans[stack.pop()] = a[idx];\n            if (i < n) stack.push(idx);\n        }\n        while (!stack.isEmpty())\n            ans[stack.pop()] = -1;\n        return ans;\n    }\n}',
                  link: 'https://leetcode.com/problems/next-greater-element-ii/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '6b4043d5-eb8f-46c6-aae5-0de626ba495e',
                  isFolder: false,
                  name: 'NGEsToRight.java',
                  code: 'public class NGEsToRight {\n    public static int[] countGreater(int []arr, int []query) {\n        // Write your code here.\n        int[] ans = new int[query.length];\n        for (int i = 0; i < query.length; i++) {\n            int idx = query[i];\n            int c = 0;\n            for (int j = idx+1; j < arr.length; j++) {\n                if (arr[j] > arr[idx]) c++;\n            }\n            ans[i] = c;\n        }\n        return ans;\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/count-of-greater-elements-to-the-right_8365436',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: 'e5c3696f-dcc2-478b-a10b-362b9db45445',
                  isFolder: false,
                  name: 'RemoveKDigits.java',
                  code: 'import java.util.*;\npublic class RemoveKDigits {\n    public static String removeKdigits(String num, int k) {\n        if (num.length() <= k) return "0";\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < num.length(); i++) {\n            while (!stack.isEmpty() && k > 0 && num.charAt(i) < stack.peek()) {\n                stack.pop();\n                k--;\n            }\n            stack.push(num.charAt(i));\n        }\n        while (k > 0) {\n            stack.pop();\n            k--;\n        }\n        int size = stack.size();\n        char[] chars = new char[size];\n        while (!stack.isEmpty())\n            chars[--size] = stack.pop();\n        int i = 0;\n        while (i < chars.length && chars[i] == \'0\') i++;\n        if (i == chars.length) return "0";\n        return String.valueOf(chars, i, chars.length - i);\n    }\n\n    public static void main(String[] args) {\n        String s = "1001001";\n        int k = 2;\n        System.out.println(removeKdigits(s, k));\n    }\n}',
                  link: 'https://leetcode.com/problems/remove-k-digits/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '9d5ba298-a179-4d77-93a7-bb02ee53e68f',
                  isFolder: false,
                  name: 'SumOfSubArrayMinimum.java',
                  code: 'import java.util.*;\n\npublic class SumOfSubArrayMinimum {\n    public static long solve(int[] arr, int start, long sum) {\n        if (start == arr.length) return sum;\n        int min = Integer.MAX_VALUE;\n        for (int i = start; i < arr.length; i++) {\n            min = Math.min(min, arr[i]);\n            sum += min;\n        }\n        return solve(arr, start + 1, sum);\n    }\n\n    public int sumSubarrayMins(int[] arr) {\n//        O(N^2) solution\n//        return (int) (solve(arr, 0, 0)%1000000007);\n        int n = arr.length;\n        int[] pse = getPSE(arr, n), nse = getNSE(arr, n);\n        long res = 0;\n        for(int i = 0; i < n; i++)\n            res +=  (long) (i - pse[i]) * (nse[i] - i) * arr[i];\n        return (int)(res % (1e9 + 7));\n    }\n\n    public int[] getPSE(int[] arr, int n) {\n        int[] psee = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for(int i = n-1; i >= 0; i--){\n            while(!stk.isEmpty() && arr[i] <= arr[stk.peek()])\n                psee[stk.pop()] = i;\n            stk.push(i);\n        }\n        while(!stk.isEmpty())\n            psee[stk.pop()] = -1;\n        return psee;\n    }\n\n    public int[] getNSE(int[] arr, int n) {\n        int[] nse = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for(int i = 0; i < n; i++){\n            while(!stk.isEmpty() && arr[i] < arr[stk.peek()])\n                nse[stk.pop()] = i;\n            stk.push(i);\n        }\n        while(!stk.isEmpty())\n            nse[stk.pop()] = n;\n        return nse;\n    }\n}',
                  link: 'https://leetcode.com/problems/sum-of-subarray-minimums/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: 'b6647ef8-b311-48de-a076-c0e73512d72d',
                  isFolder: false,
                  name: 'SumOfSubarrayRanges.java',
                  code: 'import java.util.*;\n\npublic class SumOfSubarrayRanges {\n    public static long solve(int[] arr, int start, long sum) {\n        if (start == arr.length) return sum;\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        for (int i = start; i < arr.length; i++) {\n            min = Math.min(min, arr[i]);\n            max = Math.max(max, arr[i]);\n            sum += max - min;\n        }\n        return solve(arr, start + 1, sum);\n    }\n//    public long subArrayRanges(int[] nums) {\n//        return solve(nums, 0, 0);\n//    }\n\n    public int[] getPSE(int[] arr, int n) {\n        int[] pse = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stk.isEmpty() && arr[i] <= arr[stk.peek()])\n                pse[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            pse[stk.pop()] = -1;\n        return pse;\n    }\n\n    public int[] getPGE(int[] arr, int n) {\n        int[] pge = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stk.isEmpty() && arr[i] >= arr[stk.peek()])\n                pge[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            pge[stk.pop()] = -1;\n        return pge;\n    }\n\n    public int[] getNSE(int[] arr, int n) {\n        int[] nse = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stk.isEmpty() && arr[i] < arr[stk.peek()])\n                nse[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            nse[stk.pop()] = n;\n        return nse;\n    }\n\n    public int[] getNGE(int[] arr, int n) {\n        int[] nge = new int[n];\n        Stack<Integer> stk = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            while (!stk.isEmpty() && arr[i] > arr[stk.peek()])\n                nge[stk.pop()] = i;\n            stk.push(i);\n        }\n        while (!stk.isEmpty())\n            nge[stk.pop()] = n;\n        return nge;\n    }\n\n    public long subArrayRanges(int[] nums) {\n        int n = nums.length;\n        int[] pse = getPSE(nums, n), nse = getNSE(nums, n), pge = getPGE(nums, n), nge = getNGE(nums, n);\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += ((long) (i - nge[i]) * (pge[i] - i) - (long) (i - nse[i]) * (pse[i] - i)) * nums[i];\n        }\n        return sum;\n    }\n}',
                  link: 'https://leetcode.com/problems/sum-of-subarray-ranges/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '4206317e-c138-4a4e-9ed0-85a76c29589c',
                  isFolder: false,
                  name: 'TrappingRainwater.java',
                  code: 'public class TrappingRainwater {\n    public int trap(int[] height) {\n//        Takes O(n) extra space\n//        int n = height.length;\n//        int[] left = new int[n], right = new int[n];\n//        int totalWater = 0, maxL = 0, maxR = 0;\n//        for (int i = 0; i < n; i++) {\n//            maxL = Math.max(maxL, height[i]);\n//            maxR = Math.max(maxR, height[n-i-1]);\n//            left[i] = maxL;\n//            right[n-i-1] = maxR;\n//        }\n//        for (int i = 0; i < n; i++)\n//            totalWater += Math.min(left[i], right[i]) - height[i];\n//        return totalWater;\n\n//        Constant space solution\n        int l = 0, r = height.length - 1;\n        int maxL = height[l], maxR = height[r];\n        int total = 0;\n        while (l < r) {\n            if (maxL < maxR) {\n                maxL = Math.max(maxL, height[++l]);\n                total += maxL - height[l];\n            } else {\n                maxR = Math.max(maxR, height[--r]);\n                total += maxR - height[r];\n            }\n        }\n        return total;\n    }\n}',
                  link: 'https://leetcode.com/problems/trapping-rain-water/',
                  notes: '',
                  tags: ['Monotonic StackQueue Problems [VVV. Imp]'],
                },
                {
                  id: '335e521e-5d7d-4f2c-8c40-e58aa2fb9e2e',
                  isFolder: false,
                  name: 'InfixToPostfixUsingStack.java',
                  code: "import java.util.*;\npublic class InfixToPostfixUsingStack {\n    public static int pref(char operator) {\n        if (operator == '^') return 3;\n        if (operator == '*' || operator == '/') return 2;\n        if (operator == '+' || operator == '-') return 1;\n        return -1;\n    }\n    public static String infixToPostfix(String exp) {\n        // Write your code here\n        Stack<String> val = new Stack<>();\n        Stack<Character> op = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else if (ch == '(') op.push(ch);\n            else if (ch == ')') {\n                while (op.peek() != '(') {\n                    String val2 = val.pop();\n                    val.push(val.pop() + val2 + op.pop());\n                }\n                op.pop();\n            } else {\n                while (!op.isEmpty() && pref(op.peek()) >= pref(ch)) {\n                    String val2 = val.pop();\n                    val.push(val.pop() + val2 + op.pop());\n                }\n                op.push(ch);\n            }\n        }\n        while (!op.isEmpty()) {\n            String val2 = val.pop();\n            val.push(val.pop() + val2 + op.pop());\n        }\n        return val.peek();\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/day-23-:-infix-to-postfix-_1382146',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: '64d5d057-0285-424e-ac28-6f5fad26db0a',
                  isFolder: false,
                  name: 'InfixToPrefixUsingStack.java',
                  code: "import java.util.Stack;\n\npublic class InfixToPrefixUsingStack {\n    public static int pref(char operator) {\n        if (operator == '^') return 3;\n        if (operator == '*' || operator == '/') return 2;\n        if (operator == '+' || operator == '-') return 1;\n        return -1;\n    }\n    public static String convertInfixToPrefix(String exp) {\n        Stack<String> val = new Stack<>();\n        Stack<Character> op = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else if (ch == '(') op.push(ch);\n            else if (ch == ')') {\n                while (op.peek() != '(') {\n                    String val2 = val.pop();\n                    val.push(op.pop() + val.pop() + val2);\n                }\n                op.pop();\n            } else {\n                while (!op.isEmpty() && pref(ch) <= pref(op.peek())) {\n                    String val2 = val.pop();\n                    val.push(op.pop() + val.pop() + val2);\n                }\n                op.push(ch);\n            }\n        }\n        while (!op.isEmpty()) {\n            String val2 = val.pop();\n            val.push(op.pop() + val.pop() + val2);\n        }\n        return val.peek();\n    }\n}",
                  link: null,
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: '5c630e36-4861-4310-963d-881f4c952d7c',
                  isFolder: false,
                  name: 'PostfixToInfixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PostfixToInfixUsingStack {\n    public static String postToInfix(String exp) {\n        // Write your code here.\n        Stack<String> val = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else {\n                String val1 = val.pop();\n                val.push("(" + val.pop() + ch + val1 + ")");\n            }\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/postfix-to-infix_8382386',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: '7724243f-0f56-4c53-8c54-31fc62e0e424',
                  isFolder: false,
                  name: 'PostfixToPrefixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PostfixToPrefixUsingStack {\n    public static String postfixToPrefix(String exp) {\n        // Write your code here\n        Stack<String> val = new Stack<>();\n        for (int i = 0; i < exp.length(); i++) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else {\n                String val1 = val.pop();\n                val.push(ch + val.pop() + val1);\n            }\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/postfix-to-prefix_1788455',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: 'f794526c-5b8a-4cd6-900c-eb071c277ef8',
                  isFolder: false,
                  name: 'PrefixToInfixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PrefixToInfixUsingStack {\n    public static String prefixToInfixConversion(String exp) {\n        // Write your code here\n        Stack<String> val = new Stack<>();\n        for (int i = exp.length() - 1; i >= 0; i--) {\n            char ch = exp.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else val.push("(" + val.pop() + ch + val.pop() + ")");\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/studio/problems/prefix-to-infix_1215000',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
                {
                  id: '86fe1528-7e17-4bdc-a479-b2b067921172',
                  isFolder: false,
                  name: 'PrefixToPostfixUsingStack.java',
                  code: 'import java.util.Stack;\n\npublic class PrefixToPostfixUsingStack {\n    public static String preToPost(String s) {\n        // Write Your Code Here\n        Stack<String> val = new Stack<>();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char ch = s.charAt(i);\n            if (Character.isLetterOrDigit(ch)) val.push(String.valueOf(ch));\n            else val.push(val.pop() + val.pop() + ch);\n        }\n        return val.peek();\n    }\n}',
                  link: 'https://www.codingninjas.com/codestudio/problems/convert-prefix-to-postfix_8391014',
                  notes: '',
                  tags: ['Prefix, Infix, PostFix Conversion Problems'],
                },
              ],
            },
            {
              id: '2a81a3dc-b888-46cb-aaba-91f4acd029f0',
              isFolder: true,
              name: 'Strings',
              content: [
                {
                  id: 'b3d2590e-4203-4506-a57a-cf4cc8b0e038',
                  isFolder: false,
                  name: 'IsomorphicStrings.java',
                  code: 'import java.util.*;\n\npublic class IsomorphicStrings {\n    public static boolean isIsomorphic(String s, String t) {\n        //    Brute force\n        //        Instead of char array use Stack array\n\n        //    Optimal approach\n        char[] mapST = new char[128];\n        char[] mapTS = new char[128];\n        for (int i = 0; i < s.length(); i++) {\n            char sChar = s.charAt(i);\n            char tChar = t.charAt(i);\n            if (mapST[sChar] != 0 && mapST[sChar] != tChar\n                    || mapTS[tChar] != 0 && mapTS[tChar] != sChar) {\n                return false;\n            }\n            mapST[sChar] = tChar;\n            mapTS[tChar] = sChar;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        String s = "edd";\n        String t = "add";\n        System.out.println(isIsomorphic(s, t));\n    }\n}',
                  link: 'https://leetcode.com/problems/isomorphic-strings/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'a496e9bf-eef2-463c-bf84-b4895383cd0f',
                  isFolder: false,
                  name: 'LargestOddNumberInString.java',
                  code: 'class LargestOddNumberInString {\n    public String largestOddNumber(String num) {\n        for (int i = num.length() - 1; i >= 0; i--) {\n            int value = num.charAt(i) - \'0\';\n            if (value % 2 == 1) return num.substring(0, i+1);\n        }\n        return "";\n    }\n}',
                  link: 'https://leetcode.com/problems/largest-odd-number-in-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '5f80bad1-c73b-47b5-bc7a-c5706777e43a',
                  isFolder: false,
                  name: 'LongestCommonPrefix.java',
                  code: 'import java.util.*;\n\npublic class LongestCommonPrefix {\n    public static String longestCommonPrefix(String[] strs) {\n//        Brute force\n//        Arrays.sort(strs);\n//        String f = strs[0], l = strs[strs.length - 1];\n//        int len = Math.min(f.length(), l.length());\n//        int i = 0;\n//        while (i < len) {\n//            if (f.charAt(i) != l.charAt(i)) break;\n//            i++;\n//        }\n//        return f.substring(0, i);\n//        Optimal solution\n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (!strs[i].startsWith(prefix)) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n            }\n        }\n        return prefix;\n    }\n\n    public static void main(String[] args) {\n        String[] strs = {"flower", "flow", "flight"};\n        System.out.println(longestCommonPrefix(strs));\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-common-prefix/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '52151a0e-9fa8-419f-9136-fa5640cec11f',
                  isFolder: false,
                  name: 'RemoveOutermostParentheses.java',
                  code: "import java.util.*;\n\npublic class RemoveOutermostParentheses {\n    public static String removeOuterParentheses(String s) {\n//        Brute force approach\n//        StringBuilder sb = new StringBuilder();\n//        Stack<Character> stack = new Stack<>();\n//        for (int i = 0; i < s.length(); i++) {\n//            char ch = s.charAt(i);\n//            if (ch == '(') {\n//                if (stack.size() > 0) {\n//                    sb.append(ch);\n//                }\n//                stack.push(ch);\n//            } else if (ch == ')') {\n//                stack.pop();\n//                if (stack.size() > 0) {\n//                    sb.append(ch);\n//                }\n//            }\n//        }\n//        return sb.toString();\n\n//        Optimal approach\n        int counter = 0;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') {\n                if (counter > 0) {\n                    sb.append(ch);\n                }\n                counter++;\n            } else if (ch == ')') {\n                if (counter > 1) {\n                    sb.append(ch);\n                }\n                counter--;\n            }\n        }\n        return sb.toString();\n    }\n}",
                  link: 'https://leetcode.com/problems/remove-outermost-parentheses/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'e3063afe-a997-4821-9dc7-29c67fd5524d',
                  isFolder: false,
                  name: 'ReverseWordsInAString.java',
                  code: 'public class ReverseWordsInAString {\n    public static String reverseWords(String s) {\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == \' \') i--;\n            // first character\n            j = i;\n            while (i >= 0 && s.charAt(i) != \' \') i--;\n            if (i == - 1) {\n                sb.append(s, 0, j+1);\n            } else {\n                sb.append(s, i+1, j+1).append(" ");\n            }\n        }\n        return sb.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        String s = "the sky is blue";\n        System.out.println(reverseWords(s));\n    }\n}',
                  link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '74715c54-a5bb-4b17-80d5-b4702dcf2faa',
                  isFolder: false,
                  name: 'RotateStrings.java',
                  code: 'import java.util.*;\npublic class RotateStrings {\n    public static boolean rotateString(String s, String goal) {\n//        Brute force solution\n//        if (s.length() != goal.length()) return false;\n//        if (s.equals(goal)) return true;\n//        StringBuilder sb = new StringBuilder(goal);\n//        for (int i = 0; i < s.length(); i++) {\n//            sb.append(sb.charAt(0)).replace(0,1,"");\n//            if (s.contentEquals(sb)) return true;\n//        }\n//        return false;\n\n//        Trick solution\n        return (s + s).contains(goal);\n\n//        Queue solution\n//        if (s.length() != goal.length()) return false;\n//        Queue<Character> q1 = new LinkedList<>();\n//        Queue<Character> q2 = new LinkedList<>();\n//        for (int i = 0; i < s.length(); i++) {\n//            q1.add(s.charAt(i));\n//            q2.add(goal.charAt(i));\n//        }\n//        int k = s.length() - 2;\n//        while (k != 0) {\n//            q1.add(q1.remove());\n//            if (q1.equals(q2)) return true;\n//            k--;\n//        }\n//        return false;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(rotateString("abcde","cdeab"));\n    }\n}',
                  link: 'https://leetcode.com/problems/rotate-string/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: 'd3c3b81b-c4e6-4287-b136-eaa4b81ce5cc',
                  isFolder: false,
                  name: 'ValidAnagram.java',
                  code: "public class ValidAnagram {\n    public static boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) return false;\n        }\n        return true;\n    }\n}",
                  link: 'https://leetcode.com/problems/valid-anagram/description/',
                  notes: '',
                  tags: ['Basic and Easy String Problems'],
                },
                {
                  id: '4f198022-1669-42f0-bb6a-b6000f1fb8d2',
                  isFolder: false,
                  name: 'CountWithKDifferentCharacters.java',
                  code: "import java.util.*;\n\npublic class CountWithKDifferentCharacters {\n    public static int helper(String str, int k) {\n        int[] bucket = new int[26];\n        int result = 0,  i = 0, j = 0, c = 0;\n        while (j < str.length()) {\n            int idx = str.charAt(j) - 'a';\n            bucket[idx]++;\n            if (bucket[idx] == 1) c++;\n            while (c > k) {\n                int idx2 = str.charAt(i) - 'a';\n                bucket[idx2]--;\n                if (bucket[idx2] == 0) c--;\n                i++;\n            }\n            result += j - i + 1;\n            j++;\n        }\n        return result;\n    }\n    public static int countSubStrings(String str, int k) {\n        // Brute force solution: Generate all substrings and check the count of substrings containing k different characters\n//        int count = 0;\n//        for (int i = 0; i < str.length(); i++) {\n//            for (int j = i; j < str.length(); j++) {\n//                String s = str.substring(i, j+1);\n//                HashSet<Character> hs = new HashSet<>();\n//                for (int x = 0; x < s.length(); x++) {\n//                    hs.add(s.charAt(x));\n//                }\n//                if (hs.size() == k) count++;\n//            }\n//        }\n//        return count;\n\n        // Better solution: Use 2 nested loops (subarray trick) and array instead of HashSet\n//        int count = 0;\n//        for (int i = 0; i < str.length(); i++) {\n//            int[] bucket = new int[26];\n//            int c = 0;\n//            for (int j = i; j < str.length(); j++) {\n//                char ch = str.charAt(j);\n//                bucket[ch - 'a']++;\n//                if (bucket[ch - 'a'] == 1) c++;\n//                if (c == k) count++;\n//            }\n//        }\n//        return count;\n\n        // Optimal solution: To get the exact k we need the difference of atmost k and atmost k-1\n        return helper(str, k) - helper(str, k-1);\n    }\n\n    public static void main(String[] args) {\n        String s = \"aacfssa\";\n        int k = 3;\n        int count = countSubStrings(s, k);\n        System.out.println(count);\n    }\n}",
                  link: 'https://www.codingninjas.com/studio/problems/count-with-k-different-characters_1214627',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '0682d522-0ccb-4023-b70e-6e8867538768',
                  isFolder: false,
                  name: 'LongestPalindromicSubstring.java',
                  code: 'public class LongestPalindromicSubstring {\n    public static boolean isPalindrome(String str) {\n        int i = 0;\n        while (i < str.length() / 2) {\n            if (str.charAt(i) != str.charAt(str.length() - i - 1)) return false;\n            i++;\n        }\n        return true;\n    }\n\n    public static int expandFromMid(int left, int right, String s) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    public String longestPalindrome(String s) {\n//        Brute force\n//        String maxL = "";\n//        for (int i = 0; i < s.length(); i++) {\n//            for (int j = i; j < s.length(); j++) {\n//                if (s.charAt(i) == s.charAt(j)) {\n//                    String sub = s.substring(i, j + 1);\n//                    if (sub.length() > maxL.length() && isPalindrome(sub)) {\n//                        maxL = sub;\n//                    }\n//                }\n//            }\n//        }\n//        return maxL;\n\n//        Optimized approach: Go to each element and try to expand outwards, store max\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = expandFromMid(i, i, s);\n            int len2 = expandFromMid(i, i + 1, s);\n            int len = Math.max(len1, len2);\n            if (len > end - start + 1) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n}',
                  link: 'https://leetcode.com/problems/longest-palindromic-substring/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '3f3c7b01-7a4c-4838-85fb-ff79d308c810',
                  isFolder: false,
                  name: 'MaximumNestingDepthOfParentheses.java',
                  code: "class MaximumNestingDepthOfParentheses {\n    public int maxDepth(String s) {\n        int maxLength = 0, count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') count++;\n            else if (ch == ')') count--;\n            maxLength = Math.max(maxLength, count);\n        }\n        return maxLength;\n    }\n}",
                  link: 'https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '8609332e-e44f-4219-86d6-fd4a34180086',
                  isFolder: false,
                  name: 'ReverseWordsInAString.java',
                  code: "public class ReverseWordsInAString {\n    public String reverseWords(String s) {\n        int i = s.length() - 1, j = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0) {\n            while (i >= 0 && s.charAt(i) == ' ') i--;\n            j = i;\n            while (i >= 0 && s.charAt(i) != ' ') i--;\n            if (i == - 1) sb.append(s, 0, j+1);\n            else sb.append(s, i+1, j+1).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n}",
                  link: 'https://leetcode.com/problems/reverse-words-in-a-string/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '6f26a284-c633-4d45-b649-72b8411de54e',
                  isFolder: false,
                  name: 'RomanToIntegers.java',
                  code: "import java.util.HashMap;\n\npublic class RomanToIntegers {\n    public static int romanToInt(String s) {\n        HashMap<Character, Integer> hm = new HashMap<>();\n        hm.put('I', 1);\n        hm.put('V', 5);\n        hm.put('X', 10);\n        hm.put('L', 50);\n        hm.put('C', 100);\n        hm.put('D', 500);\n        hm.put('M', 1000);\n        char[] sArr = s.toCharArray();\n        int sum = 0;\n        for (int i = 0; i < sArr.length; i++) {\n            if (i < sArr.length - 1 && hm.get(sArr[i]) >= hm.get(sArr[i+1])) {\n                sum += hm.get(sArr[i]);\n            } else {\n                sum -= hm.get(sArr[i]);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        String s = \"III\";\n        System.out.println(romanToInt(s));\n    }\n}",
                  link: 'https://leetcode.com/problems/roman-to-integer/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '949b8082-2969-4fc5-91ea-ecf73b306488',
                  isFolder: false,
                  name: 'SortCharacterByFrequency.java',
                  code: 'import java.util.*;\n\npublic class SortCharacterByFrequency {\n    public static HashMap<Character, Integer> getFrequencyMap(char[] s) {\n        HashMap<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length; i++) {\n            map.put(s[i], map.getOrDefault(s[i], 0) + 1);\n        }\n        return map;\n    }\n\n    public static void addFrequencyChar(StringBuilder sb, int times, char ch) {\n        while (times != 0) {\n            sb.append(ch);\n            times--;\n        }\n    }\n\n    public static String frequencySort(String s) {\n//      Brute force solution\n//        HashMap<Character, Integer> hm = getFrequencyMap(s.toCharArray());\n//        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(Map.Entry.comparingByValue(Collections.reverseOrder()));\n//        pq.addAll(hm.entrySet());\n//        StringBuilder sb = new StringBuilder();\n//        while (!pq.isEmpty()) {\n//            Map.Entry<Character, Integer> map = pq.poll();\n//            addFrequencyChar(sb, map.getValue(), map.getKey());\n//        }\n//        return sb.toString();\n\n//        Optimized Solution\n        HashMap<Character, Integer> hm = getFrequencyMap(s.toCharArray());\n        List<Character>[] list = new List[s.length() + 1];\n        for (Map.Entry<Character, Integer> map: hm.entrySet()) {\n            int i = map.getValue();\n            if (list[i] == null)\n                list[i] = new ArrayList<>();\n            list[i].add(map.getKey());\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = s.length(); i > 0; i--)\n            if (list[i] != null)\n                for (char ch : list[i]) addFrequencyChar(sb, i, ch);\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(frequencySort("treerrrazt"));\n    }\n}',
                  link: 'https://leetcode.com/problems/sort-characters-by-frequency/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: '0b47f466-45de-4b33-a530-d42945e2a20a',
                  isFolder: false,
                  name: 'StringToIntegerATOI.java',
                  code: "public class StringToIntegerATOI {\n    public int myAtoi(String s) {\n        boolean isNegative = false;\n        char[] sArray = s.toCharArray();\n        int n = sArray.length;\n        int i = 0;\n        while (i < n && sArray[i] == ' ') i++;\n        if (i < n && sArray[i] == '-') {\n            isNegative = true;\n            i++;\n        } else if (i < n && sArray[i] == '+') i++;\n        double num = 0;\n        while (i < n && sArray[i] - '0' >= 0 && sArray[i] - '0' <= 9) {\n            num = num*10 + (sArray[i] - '0');\n            i++;\n        }\n        num = isNegative ? -num : num;\n        if (num > Integer.MAX_VALUE)\n            num = Integer.MAX_VALUE;\n        else if (num < Integer.MIN_VALUE)\n            num = Integer.MIN_VALUE;\n        return (int)num;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n    }\n}",
                  link: 'https://leetcode.com/problems/string-to-integer-atoi/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
                {
                  id: 'c8c7219c-8c79-48c2-93b3-8189ecb6b002',
                  isFolder: false,
                  name: 'SumOfBeautyOfAllSubstrings.java',
                  code: "public class SumOfBeautyOfAllSubstrings {\n    public static int calcBeauty(String sub) {\n        int[] count = new int[26];\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\n        for (int i = 0; i < sub.length(); i++) {\n            int idx = sub.charAt(i) - 'a';\n            count[idx]++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                low = Math.min(low, count[i]);\n            }\n            high = Math.max(high, count[i]);\n        }\n        int c = high - low;\n        return Math.max(c, 0);\n    }\n\n    public static int beautySum(String s) {\n        int sum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int[] count = new int[26];\n            int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\n            for (int j = i; j < s.length(); j++) {\n                count[s.charAt(j) - 'a']++;\n                for (int c : count) {\n                    if (c != 0)\n                        low = Math.min(low, c);\n                    high = Math.max(high, c);\n                }\n                sum += high - low;\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        String s = \"xzvfsppsjfbxdwkqe\";\n        int ans = beautySum(s);\n        System.out.println(ans);\n    }\n}",
                  link: 'https://leetcode.com/problems/sum-of-beauty-of-all-substrings/',
                  notes: '',
                  tags: ['Medium String Problems'],
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};

export default data;
